//go:build ignore
// +build ignore

package main

/*
	Generate asset_versions_gen.go.
*/

import (
	"context"
	"fmt"
	"io"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"sort"
	"strings"

	"go.skia.org/infra/go/bazel"
	"go.skia.org/infra/go/cipd"
	"go.skia.org/infra/go/exec"
	"go.skia.org/infra/go/skerr"
	"go.skia.org/infra/go/sklog"
	"go.skia.org/infra/go/util"
)

const (
	TARGET_FILE = "asset_versions_gen.go"
	HEADER      = `// Code generated by "go run gen_versions.go"; DO NOT EDIT

package cipd

var PACKAGES = map[string]*Package{
`
	FOOTER = `}`
)

func genAssetVersionsGo(depsEntries map[bazel.DependencyID]bazel.Dependency, pkgDir, rootDir string) error {
	// Pull out only the CIPD dependencies.
	var pkgs []*cipd.Package
	for _, entry := range depsEntries {
		if !strings.HasPrefix(entry.GetFunction(), "cipd") {
			continue
		}
		pkg := &cipd.Package{
			Path:    ".", // TODO(borenet): How to fill this in?
			Name:    string(entry.GetID()),
			Version: entry.GetVersion(),
		}
		pkgs = append(pkgs, pkg)
	}

	// List the assets.
	assetsDir := path.Join(rootDir, "infra", "bots", "assets")
	entries, err := os.ReadDir(assetsDir)
	if err != nil {
		return skerr.Wrap(err)
	}
	for _, e := range entries {
		if e.IsDir() {
			contents, err := os.ReadFile(path.Join(assetsDir, e.Name(), "VERSION"))
			if err == nil {
				name := e.Name()
				fullName := fmt.Sprintf("skia/bots/%s", name)
				pkgs = append(pkgs, &cipd.Package{
					Path:    name,
					Name:    fullName,
					Version: cipd.VersionTag(strings.TrimSpace(string(contents))),
				})
			} else if !os.IsNotExist(err) {
				return skerr.Wrap(err)
			}
		}
	}

	// Write the file.
	sort.Sort(cipd.PackageSlice(pkgs))
	targetFile := path.Join(pkgDir, TARGET_FILE)
	if err := util.WithWriteFile(targetFile, func(w io.Writer) error {
		_, err := w.Write([]byte(HEADER))
		if err != nil {
			return err
		}
		for _, pkg := range pkgs {
			_, err := fmt.Fprintf(w, `	"%s": &Package{
		Path: "%s",
		Name: "%s",
		Version: "%s",
	},
`, pkg.Name, pkg.Path, pkg.Name, pkg.Version)
			if err != nil {
				return err
			}
		}
		_, err = w.Write([]byte(FOOTER))
		return err
	}); err != nil {
		return skerr.Wrap(err)
	}
	if _, err := exec.RunCwd(context.Background(), ".", "gofmt", "-s", "-w", targetFile); err != nil {
		return skerr.Wrap(err)
	}
	return nil
}

func main() {
	// Read and parse the MODULE.bazel file.
	_, filename, _, _ := runtime.Caller(0)
	pkgDir := path.Dir(filename)
	rootDir := path.Join(pkgDir, "..", "..")

	contents, err := os.ReadFile(filepath.Join(rootDir, "MODULE.bazel"))
	if err != nil {
		sklog.Fatal(err)
	}
	entries, err := bazel.ParseDeps(string(contents))
	if err != nil {
		sklog.Fatal(err)
	}

	if err := genAssetVersionsGo(entries, pkgDir, rootDir); err != nil {
		sklog.Fatal(err)
	}
}
