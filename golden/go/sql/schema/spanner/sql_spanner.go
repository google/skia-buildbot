package spanner

// Generated by //go/sql/exporter/
// DO NOT EDIT

const Schema = `CREATE TABLE IF NOT EXISTS Changelists (
  changelist_id TEXT PRIMARY KEY,
  system TEXT NOT NULL,
  status TEXT NOT NULL,
  owner_email TEXT NOT NULL,
  subject TEXT NOT NULL,
  last_ingested_data TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE TABLE IF NOT EXISTS CommitsWithData (
  commit_id TEXT PRIMARY KEY,
  tile_id INT8 NOT NULL
);
CREATE TABLE IF NOT EXISTS DiffMetrics (
  left_digest BYTEA,
  right_digest BYTEA,
  num_pixels_diff INT8 NOT NULL,
  percent_pixels_diff FLOAT4 NOT NULL,
  max_rgba_diffs INT8[] NOT NULL,
  max_channel_diff INT8 NOT NULL,
  combined_metric FLOAT4 NOT NULL,
  dimensions_differ BOOL NOT NULL,
  ts TIMESTAMP WITH TIME ZONE NOT NULL,
  PRIMARY KEY (left_digest, right_digest)
);
CREATE TABLE IF NOT EXISTS ExpectationDeltas (
  expectation_record_id TEXT,
  grouping_id BYTEA,
  digest BYTEA,
  label_before VARCHAR(1) NOT NULL,
  label_after VARCHAR(1) NOT NULL,
  PRIMARY KEY (expectation_record_id, grouping_id, digest)
);
CREATE TABLE IF NOT EXISTS ExpectationRecords (
  expectation_record_id TEXT PRIMARY KEY DEFAULT spanner.generate_uuid(),
  branch_name TEXT,
  user_name TEXT NOT NULL,
  triage_time TIMESTAMP WITH TIME ZONE NOT NULL,
  num_changes INT8 NOT NULL
);
CREATE TABLE IF NOT EXISTS Expectations (
  grouping_id BYTEA,
  digest BYTEA,
  label VARCHAR(1) NOT NULL,
  expectation_record_id TEXT,
  PRIMARY KEY (grouping_id, digest)
);
CREATE TABLE IF NOT EXISTS GitCommits (
  git_hash TEXT PRIMARY KEY,
  commit_id TEXT NOT NULL,
  commit_time TIMESTAMP WITH TIME ZONE NOT NULL,
  author_email TEXT NOT NULL,
  subject TEXT NOT NULL
);
CREATE TABLE IF NOT EXISTS Groupings (
  grouping_id BYTEA PRIMARY KEY,
  keys JSONB NOT NULL
);
CREATE TABLE IF NOT EXISTS IgnoreRules (
  ignore_rule_id TEXT PRIMARY KEY DEFAULT spanner.generate_uuid(),
  creator_email TEXT NOT NULL,
  updated_email TEXT NOT NULL,
  expires TIMESTAMP WITH TIME ZONE NOT NULL,
  note TEXT,
  query JSONB NOT NULL
);
CREATE TABLE IF NOT EXISTS MetadataCommits (
  commit_id TEXT PRIMARY KEY,
  commit_metadata TEXT NOT NULL
);
CREATE TABLE IF NOT EXISTS Options (
  options_id BYTEA PRIMARY KEY,
  keys JSONB NOT NULL
);
CREATE TABLE IF NOT EXISTS Patchsets (
  patchset_id TEXT PRIMARY KEY,
  system TEXT NOT NULL,
  changelist_id TEXT NOT NULL REFERENCES Changelists (changelist_id),
  ps_order INT8 NOT NULL,
  git_hash TEXT NOT NULL,
  commented_on_cl BOOL NOT NULL,
  created_ts TIMESTAMP WITH TIME ZONE
);
CREATE TABLE IF NOT EXISTS PrimaryBranchDiffCalculationWork (
  grouping_id BYTEA PRIMARY KEY,
  last_calculated_ts TIMESTAMP WITH TIME ZONE NOT NULL,
  calculation_lease_ends TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE TABLE IF NOT EXISTS PrimaryBranchParams (
  tile_id INT8,
  key TEXT,
  value TEXT,
  PRIMARY KEY (tile_id, key, value)
);
CREATE TABLE IF NOT EXISTS ProblemImages (
  digest TEXT PRIMARY KEY,
  num_errors INT8 NOT NULL,
  latest_error TEXT NOT NULL,
  error_ts TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE TABLE IF NOT EXISTS SecondaryBranchDiffCalculationWork (
  branch_name TEXT,
  grouping_id BYTEA,
  last_updated_ts TIMESTAMP WITH TIME ZONE NOT NULL,
  digests TEXT[] NOT NULL,
  last_calculated_ts TIMESTAMP WITH TIME ZONE NOT NULL,
  calculation_lease_ends TIMESTAMP WITH TIME ZONE NOT NULL,
  PRIMARY KEY (branch_name, grouping_id)
);
CREATE TABLE IF NOT EXISTS SecondaryBranchExpectations (
  branch_name TEXT,
  grouping_id BYTEA,
  digest BYTEA,
  label VARCHAR(1) NOT NULL,
  expectation_record_id TEXT NOT NULL,
  PRIMARY KEY (branch_name, grouping_id, digest)
);
CREATE TABLE IF NOT EXISTS SecondaryBranchParams (
  branch_name TEXT,
  version_name TEXT,
  key TEXT,
  value TEXT,
  PRIMARY KEY (branch_name, version_name, key, value)
);
CREATE TABLE IF NOT EXISTS SecondaryBranchValues (
  branch_name TEXT,
  version_name TEXT,
  secondary_branch_trace_id BYTEA,
  digest BYTEA NOT NULL,
  grouping_id BYTEA NOT NULL,
  options_id BYTEA NOT NULL,
  source_file_id BYTEA NOT NULL,
  tryjob_id string,
  PRIMARY KEY (branch_name, version_name, secondary_branch_trace_id, source_file_id)
);
CREATE TABLE IF NOT EXISTS SourceFiles (
  source_file_id BYTEA PRIMARY KEY,
  source_file TEXT NOT NULL,
  last_ingested TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE TABLE IF NOT EXISTS TiledTraceDigests (
  trace_id BYTEA,
  tile_id INT8,
  digest BYTEA NOT NULL,
  grouping_id BYTEA NOT NULL,
  PRIMARY KEY (trace_id, tile_id, digest)
);
CREATE TABLE IF NOT EXISTS TraceValues (
  shard INT8,
  trace_id BYTEA,
  commit_id TEXT,
  digest BYTEA NOT NULL,
  grouping_id BYTEA NOT NULL,
  options_id BYTEA NOT NULL,
  source_file_id BYTEA NOT NULL,
  PRIMARY KEY (shard, commit_id, trace_id)
);
CREATE TABLE IF NOT EXISTS Traces (
  trace_id BYTEA PRIMARY KEY,
  corpus TEXT GENERATED ALWAYS AS (keys->>'source_type') STORED NOT NULL,
  grouping_id BYTEA NOT NULL,
  keys JSONB NOT NULL,
  matches_any_ignore_rule BOOL
);
CREATE TABLE IF NOT EXISTS TrackingCommits (
  repo TEXT PRIMARY KEY,
  last_git_hash TEXT NOT NULL
);
CREATE TABLE IF NOT EXISTS Tryjobs (
  tryjob_id TEXT PRIMARY KEY,
  system TEXT NOT NULL,
  changelist_id TEXT NOT NULL REFERENCES Changelists (changelist_id),
  patchset_id TEXT NOT NULL REFERENCES Patchsets (patchset_id),
  display_name TEXT NOT NULL,
  last_ingested_data TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE TABLE IF NOT EXISTS ValuesAtHead (
  trace_id BYTEA PRIMARY KEY,
  most_recent_commit_id TEXT NOT NULL,
  digest BYTEA NOT NULL,
  options_id BYTEA NOT NULL,
  grouping_id BYTEA NOT NULL,
  corpus TEXT GENERATED ALWAYS AS (keys->>'source_type') STORED NOT NULL,
  keys JSONB NOT NULL,
  matches_any_ignore_rule BOOL
);
CREATE TABLE IF NOT EXISTS DeprecatedIngestedFiles (
  source_file_id BYTEA PRIMARY KEY,
  source_file TEXT NOT NULL,
  last_ingested TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE TABLE IF NOT EXISTS DeprecatedExpectationUndos (
  id INT8 PRIMARY KEY,
  expectation_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  ts TIMESTAMP WITH TIME ZONE NOT NULL
);
CREATE INDEX IF NOT EXISTS system_status_ingested_idx on Changelists (system, status, last_ingested_data);
CREATE INDEX IF NOT EXISTS status_ingested_idx on Changelists (status, last_ingested_data DESC);
CREATE INDEX IF NOT EXISTS branch_ts_idx on ExpectationRecords (branch_name, triage_time);
CREATE INDEX IF NOT EXISTS label_idx on Expectations (label);
CREATE INDEX IF NOT EXISTS commit_idx on GitCommits (commit_id);
CREATE INDEX IF NOT EXISTS cl_order_idx on Patchsets (changelist_id, ps_order);
CREATE INDEX IF NOT EXISTS calculated_idx on PrimaryBranchDiffCalculationWork (last_calculated_ts);
CREATE INDEX IF NOT EXISTS calculated_idx on SecondaryBranchDiffCalculationWork (last_calculated_ts);
CREATE INDEX IF NOT EXISTS grouping_digest_idx on TiledTraceDigests (grouping_id, digest);
CREATE INDEX IF NOT EXISTS tile_trace_idx on TiledTraceDigests (tile_id, trace_id);
CREATE INDEX IF NOT EXISTS trace_commit_idx on TraceValues (trace_id, commit_id) INCLUDE (digest, options_id, grouping_id);
CREATE INDEX IF NOT EXISTS grouping_ignored_idx on Traces (grouping_id, matches_any_ignore_rule);
CREATE INDEX IF NOT EXISTS ignored_grouping_idx on Traces (matches_any_ignore_rule, grouping_id);
CREATE INDEX IF NOT EXISTS keys_idx on Traces (keys);
CREATE INDEX IF NOT EXISTS cl_idx on Tryjobs (changelist_id);
CREATE INDEX IF NOT EXISTS ignored_grouping_idx on ValuesAtHead (matches_any_ignore_rule, grouping_id);
CREATE INDEX IF NOT EXISTS corpus_commit_ignore_idx on ValuesAtHead (corpus, most_recent_commit_id, matches_any_ignore_rule) INCLUDE (grouping_id, digest);
CREATE INDEX IF NOT EXISTS keys_idx on ValuesAtHead (keys);
`
