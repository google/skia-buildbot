// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	paramtools "go.skia.org/infra/go/paramtools"

	provider "go.skia.org/infra/perf/go/git/provider"

	query "go.skia.org/infra/go/query"

	time "time"

	tracecache "go.skia.org/infra/perf/go/tracecache"

	tracestore "go.skia.org/infra/perf/go/tracestore"

	types "go.skia.org/infra/perf/go/types"
)

// TraceStore is an autogenerated mock type for the TraceStore type
type TraceStore struct {
	mock.Mock
}

// CommitNumberOfTileStart provides a mock function with given fields: commitNumber
func (_m *TraceStore) CommitNumberOfTileStart(commitNumber types.CommitNumber) types.CommitNumber {
	ret := _m.Called(commitNumber)

	if len(ret) == 0 {
		panic("no return value specified for CommitNumberOfTileStart")
	}

	var r0 types.CommitNumber
	if rf, ok := ret.Get(0).(func(types.CommitNumber) types.CommitNumber); ok {
		r0 = rf(commitNumber)
	} else {
		r0 = ret.Get(0).(types.CommitNumber)
	}

	return r0
}

// GetLastNSources provides a mock function with given fields: ctx, traceID, n
func (_m *TraceStore) GetLastNSources(ctx context.Context, traceID string, n int) ([]tracestore.Source, error) {
	ret := _m.Called(ctx, traceID, n)

	if len(ret) == 0 {
		panic("no return value specified for GetLastNSources")
	}

	var r0 []tracestore.Source
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) ([]tracestore.Source, error)); ok {
		return rf(ctx, traceID, n)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) []tracestore.Source); ok {
		r0 = rf(ctx, traceID, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]tracestore.Source)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, traceID, n)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestTile provides a mock function with given fields: _a0
func (_m *TraceStore) GetLatestTile(_a0 context.Context) (types.TileNumber, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestTile")
	}

	var r0 types.TileNumber
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (types.TileNumber, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) types.TileNumber); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(types.TileNumber)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParamSet provides a mock function with given fields: ctx, tileNumber
func (_m *TraceStore) GetParamSet(ctx context.Context, tileNumber types.TileNumber) (paramtools.ReadOnlyParamSet, error) {
	ret := _m.Called(ctx, tileNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetParamSet")
	}

	var r0 paramtools.ReadOnlyParamSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TileNumber) (paramtools.ReadOnlyParamSet, error)); ok {
		return rf(ctx, tileNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TileNumber) paramtools.ReadOnlyParamSet); ok {
		r0 = rf(ctx, tileNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(paramtools.ReadOnlyParamSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TileNumber) error); ok {
		r1 = rf(ctx, tileNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSource provides a mock function with given fields: ctx, commitNumber, traceId
func (_m *TraceStore) GetSource(ctx context.Context, commitNumber types.CommitNumber, traceId string) (string, error) {
	ret := _m.Called(ctx, commitNumber, traceId)

	if len(ret) == 0 {
		panic("no return value specified for GetSource")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.CommitNumber, string) (string, error)); ok {
		return rf(ctx, commitNumber, traceId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.CommitNumber, string) string); ok {
		r0 = rf(ctx, commitNumber, traceId)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.CommitNumber, string) error); ok {
		r1 = rf(ctx, commitNumber, traceId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSourceIds provides a mock function with given fields: ctx, commitNumbers, traceNames
func (_m *TraceStore) GetSourceIds(ctx context.Context, commitNumbers []types.CommitNumber, traceNames []string) (map[string]map[types.CommitNumber]string, error) {
	ret := _m.Called(ctx, commitNumbers, traceNames)

	if len(ret) == 0 {
		panic("no return value specified for GetSourceIds")
	}

	var r0 map[string]map[types.CommitNumber]string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []types.CommitNumber, []string) (map[string]map[types.CommitNumber]string, error)); ok {
		return rf(ctx, commitNumbers, traceNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []types.CommitNumber, []string) map[string]map[types.CommitNumber]string); ok {
		r0 = rf(ctx, commitNumbers, traceNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]map[types.CommitNumber]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []types.CommitNumber, []string) error); ok {
		r1 = rf(ctx, commitNumbers, traceNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OffsetFromCommitNumber provides a mock function with given fields: commitNumber
func (_m *TraceStore) OffsetFromCommitNumber(commitNumber types.CommitNumber) int32 {
	ret := _m.Called(commitNumber)

	if len(ret) == 0 {
		panic("no return value specified for OffsetFromCommitNumber")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(types.CommitNumber) int32); ok {
		r0 = rf(commitNumber)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// QueryTraces provides a mock function with given fields: ctx, tileNumber, q, cache
func (_m *TraceStore) QueryTraces(ctx context.Context, tileNumber types.TileNumber, q *query.Query, cache *tracecache.TraceCache) (types.TraceSet, []provider.Commit, map[string]*types.TraceSourceInfo, error) {
	ret := _m.Called(ctx, tileNumber, q, cache)

	if len(ret) == 0 {
		panic("no return value specified for QueryTraces")
	}

	var r0 types.TraceSet
	var r1 []provider.Commit
	var r2 map[string]*types.TraceSourceInfo
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TileNumber, *query.Query, *tracecache.TraceCache) (types.TraceSet, []provider.Commit, map[string]*types.TraceSourceInfo, error)); ok {
		return rf(ctx, tileNumber, q, cache)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TileNumber, *query.Query, *tracecache.TraceCache) types.TraceSet); ok {
		r0 = rf(ctx, tileNumber, q, cache)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TraceSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TileNumber, *query.Query, *tracecache.TraceCache) []provider.Commit); ok {
		r1 = rf(ctx, tileNumber, q, cache)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]provider.Commit)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.TileNumber, *query.Query, *tracecache.TraceCache) map[string]*types.TraceSourceInfo); ok {
		r2 = rf(ctx, tileNumber, q, cache)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(map[string]*types.TraceSourceInfo)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, types.TileNumber, *query.Query, *tracecache.TraceCache) error); ok {
		r3 = rf(ctx, tileNumber, q, cache)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// QueryTracesIDOnly provides a mock function with given fields: ctx, tileNumber, q
func (_m *TraceStore) QueryTracesIDOnly(ctx context.Context, tileNumber types.TileNumber, q *query.Query) (<-chan paramtools.Params, error) {
	ret := _m.Called(ctx, tileNumber, q)

	if len(ret) == 0 {
		panic("no return value specified for QueryTracesIDOnly")
	}

	var r0 <-chan paramtools.Params
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TileNumber, *query.Query) (<-chan paramtools.Params, error)); ok {
		return rf(ctx, tileNumber, q)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TileNumber, *query.Query) <-chan paramtools.Params); ok {
		r0 = rf(ctx, tileNumber, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan paramtools.Params)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TileNumber, *query.Query) error); ok {
		r1 = rf(ctx, tileNumber, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadTraces provides a mock function with given fields: ctx, tileNumber, keys
func (_m *TraceStore) ReadTraces(ctx context.Context, tileNumber types.TileNumber, keys []string) (types.TraceSet, []provider.Commit, map[string]*types.TraceSourceInfo, error) {
	ret := _m.Called(ctx, tileNumber, keys)

	if len(ret) == 0 {
		panic("no return value specified for ReadTraces")
	}

	var r0 types.TraceSet
	var r1 []provider.Commit
	var r2 map[string]*types.TraceSourceInfo
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TileNumber, []string) (types.TraceSet, []provider.Commit, map[string]*types.TraceSourceInfo, error)); ok {
		return rf(ctx, tileNumber, keys)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TileNumber, []string) types.TraceSet); ok {
		r0 = rf(ctx, tileNumber, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TraceSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TileNumber, []string) []provider.Commit); ok {
		r1 = rf(ctx, tileNumber, keys)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]provider.Commit)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.TileNumber, []string) map[string]*types.TraceSourceInfo); ok {
		r2 = rf(ctx, tileNumber, keys)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(map[string]*types.TraceSourceInfo)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, types.TileNumber, []string) error); ok {
		r3 = rf(ctx, tileNumber, keys)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// ReadTracesForCommitRange provides a mock function with given fields: ctx, keys, begin, end
func (_m *TraceStore) ReadTracesForCommitRange(ctx context.Context, keys []string, begin types.CommitNumber, end types.CommitNumber) (types.TraceSet, []provider.Commit, map[string]*types.TraceSourceInfo, error) {
	ret := _m.Called(ctx, keys, begin, end)

	if len(ret) == 0 {
		panic("no return value specified for ReadTracesForCommitRange")
	}

	var r0 types.TraceSet
	var r1 []provider.Commit
	var r2 map[string]*types.TraceSourceInfo
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) (types.TraceSet, []provider.Commit, map[string]*types.TraceSourceInfo, error)); ok {
		return rf(ctx, keys, begin, end)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) types.TraceSet); ok {
		r0 = rf(ctx, keys, begin, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TraceSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) []provider.Commit); ok {
		r1 = rf(ctx, keys, begin, end)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]provider.Commit)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) map[string]*types.TraceSourceInfo); ok {
		r2 = rf(ctx, keys, begin, end)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(map[string]*types.TraceSourceInfo)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) error); ok {
		r3 = rf(ctx, keys, begin, end)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// StartBackgroundMetricsGathering provides a mock function with no fields
func (_m *TraceStore) StartBackgroundMetricsGathering() {
	_m.Called()
}

// TileNumber provides a mock function with given fields: commitNumber
func (_m *TraceStore) TileNumber(commitNumber types.CommitNumber) types.TileNumber {
	ret := _m.Called(commitNumber)

	if len(ret) == 0 {
		panic("no return value specified for TileNumber")
	}

	var r0 types.TileNumber
	if rf, ok := ret.Get(0).(func(types.CommitNumber) types.TileNumber); ok {
		r0 = rf(commitNumber)
	} else {
		r0 = ret.Get(0).(types.TileNumber)
	}

	return r0
}

// TileSize provides a mock function with no fields
func (_m *TraceStore) TileSize() int32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TileSize")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func() int32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// WriteTraces provides a mock function with given fields: ctx, commitNumber, params, values, paramset, source, timestamp
func (_m *TraceStore) WriteTraces(ctx context.Context, commitNumber types.CommitNumber, params []paramtools.Params, values []float32, paramset paramtools.ParamSet, source string, timestamp time.Time) error {
	ret := _m.Called(ctx, commitNumber, params, values, paramset, source, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for WriteTraces")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.CommitNumber, []paramtools.Params, []float32, paramtools.ParamSet, string, time.Time) error); ok {
		r0 = rf(ctx, commitNumber, params, values, paramset, source, timestamp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewTraceStore creates a new instance of TraceStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTraceStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *TraceStore {
	mock := &TraceStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
