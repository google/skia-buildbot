// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: config.proto

package config

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Mode describes the valid operating modes of an autoroller.
// These must be kept in sync with autoroll/go/modes/modes.go.
type Mode int32

const (
	// RUNNING is the typical operating mode of the autoroller. It will upload and
	// land CLs as new revisions appear in the Child.
	Mode_RUNNING Mode = 0
	// STOPPED prevents the autoroller from uploading any CLs. The roller will
	// continue to update any local checkouts to prevent them from getting too far
	// out of date, and any requested manual rolls will be fulfilled.
	Mode_STOPPED Mode = 1
	// DRY_RUN is similar to RUNNING but does not land the roll CLs after the
	// commit queue finishes. Instead, the active roll is left open until new
	// revisions appear in the child, at which point the roll is closed and a new
	// one is uploaded.
	Mode_DRY_RUN Mode = 2
	// OFFLINE is similar to STOPPED, but the roller does not update its checkouts
	// and requests for manual rolls are ignored.
	Mode_OFFLINE Mode = 3
)

// Enum value maps for Mode.
var (
	Mode_name = map[int32]string{
		0: "RUNNING",
		1: "STOPPED",
		2: "DRY_RUN",
		3: "OFFLINE",
	}
	Mode_value = map[string]int32{
		"RUNNING": 0,
		"STOPPED": 1,
		"DRY_RUN": 2,
		"OFFLINE": 3,
	}
)

func (x Mode) Enum() *Mode {
	p := new(Mode)
	*p = x
	return p
}

func (x Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_config_proto_enumTypes[0].Descriptor()
}

func (Mode) Type() protoreflect.EnumType {
	return &file_config_proto_enumTypes[0]
}

func (x Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Mode.Descriptor instead.
func (Mode) EnumDescriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{0}
}

// BuiltIn lists the built-in commit message templates.
type CommitMsgConfig_BuiltIn int32

const (
	// DEFAULT is the default commit message template.
	CommitMsgConfig_DEFAULT CommitMsgConfig_BuiltIn = 0
	// ANDROID is the commit message template used for Android rollers.
	CommitMsgConfig_ANDROID CommitMsgConfig_BuiltIn = 1
	// ANDROID_NO_CR is the commit message template used for Android rollers
	// where the service account does not have CR+2 access.
	CommitMsgConfig_ANDROID_NO_CR CommitMsgConfig_BuiltIn = 2
	// CANARY is the commit message template used for canary rolls.
	CommitMsgConfig_CANARY CommitMsgConfig_BuiltIn = 3
)

// Enum value maps for CommitMsgConfig_BuiltIn.
var (
	CommitMsgConfig_BuiltIn_name = map[int32]string{
		0: "DEFAULT",
		1: "ANDROID",
		2: "ANDROID_NO_CR",
		3: "CANARY",
	}
	CommitMsgConfig_BuiltIn_value = map[string]int32{
		"DEFAULT":       0,
		"ANDROID":       1,
		"ANDROID_NO_CR": 2,
		"CANARY":        3,
	}
)

func (x CommitMsgConfig_BuiltIn) Enum() *CommitMsgConfig_BuiltIn {
	p := new(CommitMsgConfig_BuiltIn)
	*p = x
	return p
}

func (x CommitMsgConfig_BuiltIn) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommitMsgConfig_BuiltIn) Descriptor() protoreflect.EnumDescriptor {
	return file_config_proto_enumTypes[1].Descriptor()
}

func (CommitMsgConfig_BuiltIn) Type() protoreflect.EnumType {
	return &file_config_proto_enumTypes[1]
}

func (x CommitMsgConfig_BuiltIn) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommitMsgConfig_BuiltIn.Descriptor instead.
func (CommitMsgConfig_BuiltIn) EnumDescriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{1, 0}
}

// Config lists the built-in Gerrit configs, named for the projects which
// use them.
type GerritConfig_Config int32

const (
	GerritConfig_ANDROID                   GerritConfig_Config = 0
	GerritConfig_ANGLE                     GerritConfig_Config = 1
	GerritConfig_CHROMIUM                  GerritConfig_Config = 2
	GerritConfig_CHROMIUM_NO_CQ            GerritConfig_Config = 3
	GerritConfig_LIBASSISTANT              GerritConfig_Config = 4
	GerritConfig_CHROMIUM_BOT_COMMIT       GerritConfig_Config = 5
	GerritConfig_CHROMIUM_BOT_COMMIT_NO_CQ GerritConfig_Config = 6
	GerritConfig_ANDROID_NO_CR             GerritConfig_Config = 7
	GerritConfig_ANDROID_NO_CR_NO_PR       GerritConfig_Config = 8
	GerritConfig_CHROMIUM_NO_CR            GerritConfig_Config = 9
)

// Enum value maps for GerritConfig_Config.
var (
	GerritConfig_Config_name = map[int32]string{
		0: "ANDROID",
		1: "ANGLE",
		2: "CHROMIUM",
		3: "CHROMIUM_NO_CQ",
		4: "LIBASSISTANT",
		5: "CHROMIUM_BOT_COMMIT",
		6: "CHROMIUM_BOT_COMMIT_NO_CQ",
		7: "ANDROID_NO_CR",
		8: "ANDROID_NO_CR_NO_PR",
		9: "CHROMIUM_NO_CR",
	}
	GerritConfig_Config_value = map[string]int32{
		"ANDROID":                   0,
		"ANGLE":                     1,
		"CHROMIUM":                  2,
		"CHROMIUM_NO_CQ":            3,
		"LIBASSISTANT":              4,
		"CHROMIUM_BOT_COMMIT":       5,
		"CHROMIUM_BOT_COMMIT_NO_CQ": 6,
		"ANDROID_NO_CR":             7,
		"ANDROID_NO_CR_NO_PR":       8,
		"CHROMIUM_NO_CR":            9,
	}
)

func (x GerritConfig_Config) Enum() *GerritConfig_Config {
	p := new(GerritConfig_Config)
	*p = x
	return p
}

func (x GerritConfig_Config) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GerritConfig_Config) Descriptor() protoreflect.EnumDescriptor {
	return file_config_proto_enumTypes[2].Descriptor()
}

func (GerritConfig_Config) Type() protoreflect.EnumType {
	return &file_config_proto_enumTypes[2]
}

func (x GerritConfig_Config) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GerritConfig_Config.Descriptor instead.
func (GerritConfig_Config) EnumDescriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{2, 0}
}

// LogLevel categorizes messages similarly to log severity.
type NotifierConfig_LogLevel int32

const (
	NotifierConfig_SILENT  NotifierConfig_LogLevel = 0
	NotifierConfig_ERROR   NotifierConfig_LogLevel = 1
	NotifierConfig_WARNING NotifierConfig_LogLevel = 2
	NotifierConfig_INFO    NotifierConfig_LogLevel = 3
	NotifierConfig_DEBUG   NotifierConfig_LogLevel = 4
)

// Enum value maps for NotifierConfig_LogLevel.
var (
	NotifierConfig_LogLevel_name = map[int32]string{
		0: "SILENT",
		1: "ERROR",
		2: "WARNING",
		3: "INFO",
		4: "DEBUG",
	}
	NotifierConfig_LogLevel_value = map[string]int32{
		"SILENT":  0,
		"ERROR":   1,
		"WARNING": 2,
		"INFO":    3,
		"DEBUG":   4,
	}
)

func (x NotifierConfig_LogLevel) Enum() *NotifierConfig_LogLevel {
	p := new(NotifierConfig_LogLevel)
	*p = x
	return p
}

func (x NotifierConfig_LogLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NotifierConfig_LogLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_config_proto_enumTypes[3].Descriptor()
}

func (NotifierConfig_LogLevel) Type() protoreflect.EnumType {
	return &file_config_proto_enumTypes[3]
}

func (x NotifierConfig_LogLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NotifierConfig_LogLevel.Descriptor instead.
func (NotifierConfig_LogLevel) EnumDescriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{32, 0}
}

// MsgType categorizes notifications based on their type.
type NotifierConfig_MsgType int32

const (
	NotifierConfig_ISSUE_UPDATE                NotifierConfig_MsgType = 0
	NotifierConfig_LAST_N_FAILED               NotifierConfig_MsgType = 1
	NotifierConfig_MODE_CHANGE                 NotifierConfig_MsgType = 2
	NotifierConfig_NEW_FAILURE                 NotifierConfig_MsgType = 3
	NotifierConfig_NEW_SUCCESS                 NotifierConfig_MsgType = 4
	NotifierConfig_ROLL_CREATION_FAILED        NotifierConfig_MsgType = 5
	NotifierConfig_SAFETY_THROTTLE             NotifierConfig_MsgType = 6
	NotifierConfig_STRATEGY_CHANGE             NotifierConfig_MsgType = 7
	NotifierConfig_SUCCESS_THROTTLE            NotifierConfig_MsgType = 8
	NotifierConfig_MANUAL_ROLL_CREATION_FAILED NotifierConfig_MsgType = 9
)

// Enum value maps for NotifierConfig_MsgType.
var (
	NotifierConfig_MsgType_name = map[int32]string{
		0: "ISSUE_UPDATE",
		1: "LAST_N_FAILED",
		2: "MODE_CHANGE",
		3: "NEW_FAILURE",
		4: "NEW_SUCCESS",
		5: "ROLL_CREATION_FAILED",
		6: "SAFETY_THROTTLE",
		7: "STRATEGY_CHANGE",
		8: "SUCCESS_THROTTLE",
		9: "MANUAL_ROLL_CREATION_FAILED",
	}
	NotifierConfig_MsgType_value = map[string]int32{
		"ISSUE_UPDATE":                0,
		"LAST_N_FAILED":               1,
		"MODE_CHANGE":                 2,
		"NEW_FAILURE":                 3,
		"NEW_SUCCESS":                 4,
		"ROLL_CREATION_FAILED":        5,
		"SAFETY_THROTTLE":             6,
		"STRATEGY_CHANGE":             7,
		"SUCCESS_THROTTLE":            8,
		"MANUAL_ROLL_CREATION_FAILED": 9,
	}
)

func (x NotifierConfig_MsgType) Enum() *NotifierConfig_MsgType {
	p := new(NotifierConfig_MsgType)
	*p = x
	return p
}

func (x NotifierConfig_MsgType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NotifierConfig_MsgType) Descriptor() protoreflect.EnumDescriptor {
	return file_config_proto_enumTypes[4].Descriptor()
}

func (NotifierConfig_MsgType) Type() protoreflect.EnumType {
	return &file_config_proto_enumTypes[4]
}

func (x NotifierConfig_MsgType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NotifierConfig_MsgType.Descriptor instead.
func (NotifierConfig_MsgType) EnumDescriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{32, 1}
}

// Config provides configuration for one AutoRoller.
type Config struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_name is the name for this roller. It is used as the unique ID for
	// the roller and must be non-empty.
	// TODO(borenet): Use an actual DB-generated ID for the roller.
	RollerName string `protobuf:"bytes,1,opt,name=roller_name,json=rollerName,proto3" json:"roller_name,omitempty"`
	// child_bug_link is a link to file a bug for the child project.
	ChildBugLink string `protobuf:"bytes,29,opt,name=child_bug_link,json=childBugLink,proto3" json:"child_bug_link,omitempty"`
	// child_display_name is the human-readable display name of the child.
	ChildDisplayName string `protobuf:"bytes,2,opt,name=child_display_name,json=childDisplayName,proto3" json:"child_display_name,omitempty"`
	// parent_bug_link is a link to file a bug for the parent project.
	ParentBugLink string `protobuf:"bytes,30,opt,name=parent_bug_link,json=parentBugLink,proto3" json:"parent_bug_link,omitempty"`
	// parent_display_name is the human-readable display name of the parent.
	ParentDisplayName string `protobuf:"bytes,3,opt,name=parent_display_name,json=parentDisplayName,proto3" json:"parent_display_name,omitempty"`
	// parent_waterfall is the URL of the waterfall display of the parent repo.
	ParentWaterfall string `protobuf:"bytes,4,opt,name=parent_waterfall,json=parentWaterfall,proto3" json:"parent_waterfall,omitempty"`
	// owner_primary is the primary owner of this roller.
	OwnerPrimary string `protobuf:"bytes,5,opt,name=owner_primary,json=ownerPrimary,proto3" json:"owner_primary,omitempty"`
	// owner_secondary is the secondary owner of this roller.
	OwnerSecondary string `protobuf:"bytes,6,opt,name=owner_secondary,json=ownerSecondary,proto3" json:"owner_secondary,omitempty"`
	// contacts is a list of email addresses of contacts for this roller, used
	// for sending PSAs, asking questions, etc. At least one contact is required.
	Contacts []string `protobuf:"bytes,7,rep,name=contacts,proto3" json:"contacts,omitempty"`
	// service_account is the full email address of the service account for this
	// roller.
	ServiceAccount string `protobuf:"bytes,8,opt,name=service_account,json=serviceAccount,proto3" json:"service_account,omitempty"`
	// is_internal indicates whether this roller is internal, ie. only visible
	// to Googlers.
	// TODO(borenet): Is this necessary?
	IsInternal bool `protobuf:"varint,9,opt,name=is_internal,json=isInternal,proto3" json:"is_internal,omitempty"`
	// reviewer are the email addresses to add as reviewers on rolls, or URL(s)
	// from which to obtain those email addresses. At least one reviewer is
	// required.
	Reviewer []string `protobuf:"bytes,10,rep,name=reviewer,proto3" json:"reviewer,omitempty"`
	// reviewer_backup are backup email addresses to add as reviewers on rolls,
	// in case obtaining the email addresses from the URL fails. Only required
	// if a URL is specified for the reviewer.
	ReviewerBackup []string `protobuf:"bytes,11,rep,name=reviewer_backup,json=reviewerBackup,proto3" json:"reviewer_backup,omitempty"`
	// roll_cooldown is a period of time after a successful roll attempt during
	// which no new roll attempts will be created. Optional. The default is 10m.
	RollCooldown string `protobuf:"bytes,12,opt,name=roll_cooldown,json=rollCooldown,proto3" json:"roll_cooldown,omitempty"`
	// dry_run_cooldown specifies how long successful dry run CLs will be left
	// open before closing in favor of a new roll.
	DryRunCooldown string `protobuf:"bytes,35,opt,name=dry_run_cooldown,json=dryRunCooldown,proto3" json:"dry_run_cooldown,omitempty"`
	// time_window in which the roller is allowed to upload roll CLs. See the
	// go/time_window package for supported format.
	TimeWindow string `protobuf:"bytes,13,opt,name=time_window,json=timeWindow,proto3" json:"time_window,omitempty"`
	// supports_manual_rolls indicates whether this roller supports manual
	// rolls.
	SupportsManualRolls bool `protobuf:"varint,14,opt,name=supports_manual_rolls,json=supportsManualRolls,proto3" json:"supports_manual_rolls,omitempty"`
	// commit_msg provides configuration for the commit message.
	CommitMsg *CommitMsgConfig `protobuf:"bytes,15,opt,name=commit_msg,json=commitMsg,proto3" json:"commit_msg,omitempty"`
	// code_review provides configuration for code review.
	//
	// Types that are valid to be assigned to CodeReview:
	//
	//	*Config_Gerrit
	//	*Config_Github
	//	*Config_Google3
	CodeReview isConfig_CodeReview `protobuf_oneof:"code_review"`
	// kubernetes provides configuration for Kubernetes.
	Kubernetes *KubernetesConfig `protobuf:"bytes,19,opt,name=kubernetes,proto3" json:"kubernetes,omitempty"`
	// repo_manager provides configuration for the repo manager.
	//
	// Types that are valid to be assigned to RepoManager:
	//
	//	*Config_ParentChildRepoManager
	//	*Config_AndroidRepoManager
	//	*Config_CommandRepoManager
	//	*Config_FreetypeRepoManager
	//	*Config_Google3RepoManager
	RepoManager isConfig_RepoManager `protobuf_oneof:"repo_manager"`
	// notifiers configures any extra notifications used by this roller. Optional.
	Notifiers []*NotifierConfig `protobuf:"bytes,26,rep,name=notifiers,proto3" json:"notifiers,omitempty"`
	// safety_throttle provides configuration for safety-throttling the roller
	// in case of persistent errors.
	SafetyThrottle *ThrottleConfig `protobuf:"bytes,27,opt,name=safety_throttle,json=safetyThrottle,proto3" json:"safety_throttle,omitempty"`
	// transitive_deps is an optional mapping of dependency ID (eg. repo URL)
	// to the paths within the parent and child repo, respectively, where
	// those dependencies are versioned, eg. "DEPS".
	// TODO(borenet): Where is this used? Why isn't it nested within the repo
	// manager config?
	TransitiveDeps []*TransitiveDepConfig `protobuf:"bytes,28,rep,name=transitive_deps,json=transitiveDeps,proto3" json:"transitive_deps,omitempty"`
	// use_workload_identity indicates whether the roller uses workload
	// identity. See skbug.com/12323
	UseWorkloadIdentity bool `protobuf:"varint,31,opt,name=use_workload_identity,json=useWorkloadIdentity,proto3" json:"use_workload_identity,omitempty"`
	// valid_modes lists the valid modes for the roller. If not specified, all
	// modes are allowed.
	ValidModes []Mode `protobuf:"varint,32,rep,packed,name=valid_modes,json=validModes,proto3,enum=autoroll.config.Mode" json:"valid_modes,omitempty"`
	// max_roll_cq_attempts indicates the maximum number of commit queue
	// attempts before abandoning a roll CL. If not set, the default is 3.
	MaxRollCqAttempts int32 `protobuf:"varint,33,opt,name=max_roll_cq_attempts,json=maxRollCqAttempts,proto3" json:"max_roll_cq_attempts,omitempty"`
	// max_roll_cls_to_same_revision indicates the maximum number of roll CLs to
	// the same revision before giving up. If not set, the default is 3.
	MaxRollClsToSameRevision int32 `protobuf:"varint,34,opt,name=max_roll_cls_to_same_revision,json=maxRollClsToSameRevision,proto3" json:"max_roll_cls_to_same_revision,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *Config) Reset() {
	*x = Config{}
	mi := &file_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{0}
}

func (x *Config) GetRollerName() string {
	if x != nil {
		return x.RollerName
	}
	return ""
}

func (x *Config) GetChildBugLink() string {
	if x != nil {
		return x.ChildBugLink
	}
	return ""
}

func (x *Config) GetChildDisplayName() string {
	if x != nil {
		return x.ChildDisplayName
	}
	return ""
}

func (x *Config) GetParentBugLink() string {
	if x != nil {
		return x.ParentBugLink
	}
	return ""
}

func (x *Config) GetParentDisplayName() string {
	if x != nil {
		return x.ParentDisplayName
	}
	return ""
}

func (x *Config) GetParentWaterfall() string {
	if x != nil {
		return x.ParentWaterfall
	}
	return ""
}

func (x *Config) GetOwnerPrimary() string {
	if x != nil {
		return x.OwnerPrimary
	}
	return ""
}

func (x *Config) GetOwnerSecondary() string {
	if x != nil {
		return x.OwnerSecondary
	}
	return ""
}

func (x *Config) GetContacts() []string {
	if x != nil {
		return x.Contacts
	}
	return nil
}

func (x *Config) GetServiceAccount() string {
	if x != nil {
		return x.ServiceAccount
	}
	return ""
}

func (x *Config) GetIsInternal() bool {
	if x != nil {
		return x.IsInternal
	}
	return false
}

func (x *Config) GetReviewer() []string {
	if x != nil {
		return x.Reviewer
	}
	return nil
}

func (x *Config) GetReviewerBackup() []string {
	if x != nil {
		return x.ReviewerBackup
	}
	return nil
}

func (x *Config) GetRollCooldown() string {
	if x != nil {
		return x.RollCooldown
	}
	return ""
}

func (x *Config) GetDryRunCooldown() string {
	if x != nil {
		return x.DryRunCooldown
	}
	return ""
}

func (x *Config) GetTimeWindow() string {
	if x != nil {
		return x.TimeWindow
	}
	return ""
}

func (x *Config) GetSupportsManualRolls() bool {
	if x != nil {
		return x.SupportsManualRolls
	}
	return false
}

func (x *Config) GetCommitMsg() *CommitMsgConfig {
	if x != nil {
		return x.CommitMsg
	}
	return nil
}

func (x *Config) GetCodeReview() isConfig_CodeReview {
	if x != nil {
		return x.CodeReview
	}
	return nil
}

func (x *Config) GetGerrit() *GerritConfig {
	if x != nil {
		if x, ok := x.CodeReview.(*Config_Gerrit); ok {
			return x.Gerrit
		}
	}
	return nil
}

func (x *Config) GetGithub() *GitHubConfig {
	if x != nil {
		if x, ok := x.CodeReview.(*Config_Github); ok {
			return x.Github
		}
	}
	return nil
}

func (x *Config) GetGoogle3() *Google3Config {
	if x != nil {
		if x, ok := x.CodeReview.(*Config_Google3); ok {
			return x.Google3
		}
	}
	return nil
}

func (x *Config) GetKubernetes() *KubernetesConfig {
	if x != nil {
		return x.Kubernetes
	}
	return nil
}

func (x *Config) GetRepoManager() isConfig_RepoManager {
	if x != nil {
		return x.RepoManager
	}
	return nil
}

func (x *Config) GetParentChildRepoManager() *ParentChildRepoManagerConfig {
	if x != nil {
		if x, ok := x.RepoManager.(*Config_ParentChildRepoManager); ok {
			return x.ParentChildRepoManager
		}
	}
	return nil
}

func (x *Config) GetAndroidRepoManager() *AndroidRepoManagerConfig {
	if x != nil {
		if x, ok := x.RepoManager.(*Config_AndroidRepoManager); ok {
			return x.AndroidRepoManager
		}
	}
	return nil
}

func (x *Config) GetCommandRepoManager() *CommandRepoManagerConfig {
	if x != nil {
		if x, ok := x.RepoManager.(*Config_CommandRepoManager); ok {
			return x.CommandRepoManager
		}
	}
	return nil
}

func (x *Config) GetFreetypeRepoManager() *FreeTypeRepoManagerConfig {
	if x != nil {
		if x, ok := x.RepoManager.(*Config_FreetypeRepoManager); ok {
			return x.FreetypeRepoManager
		}
	}
	return nil
}

func (x *Config) GetGoogle3RepoManager() *Google3RepoManagerConfig {
	if x != nil {
		if x, ok := x.RepoManager.(*Config_Google3RepoManager); ok {
			return x.Google3RepoManager
		}
	}
	return nil
}

func (x *Config) GetNotifiers() []*NotifierConfig {
	if x != nil {
		return x.Notifiers
	}
	return nil
}

func (x *Config) GetSafetyThrottle() *ThrottleConfig {
	if x != nil {
		return x.SafetyThrottle
	}
	return nil
}

func (x *Config) GetTransitiveDeps() []*TransitiveDepConfig {
	if x != nil {
		return x.TransitiveDeps
	}
	return nil
}

func (x *Config) GetUseWorkloadIdentity() bool {
	if x != nil {
		return x.UseWorkloadIdentity
	}
	return false
}

func (x *Config) GetValidModes() []Mode {
	if x != nil {
		return x.ValidModes
	}
	return nil
}

func (x *Config) GetMaxRollCqAttempts() int32 {
	if x != nil {
		return x.MaxRollCqAttempts
	}
	return 0
}

func (x *Config) GetMaxRollClsToSameRevision() int32 {
	if x != nil {
		return x.MaxRollClsToSameRevision
	}
	return 0
}

type isConfig_CodeReview interface {
	isConfig_CodeReview()
}

type Config_Gerrit struct {
	// gerrit provides configuration for code review using Gerrit.
	Gerrit *GerritConfig `protobuf:"bytes,16,opt,name=gerrit,proto3,oneof"`
}

type Config_Github struct {
	// github provides configuration for code review using GitHub.
	Github *GitHubConfig `protobuf:"bytes,17,opt,name=github,proto3,oneof"`
}

type Config_Google3 struct {
	// google3 provides configuration for code review using Google3.
	Google3 *Google3Config `protobuf:"bytes,18,opt,name=google3,proto3,oneof"`
}

func (*Config_Gerrit) isConfig_CodeReview() {}

func (*Config_Github) isConfig_CodeReview() {}

func (*Config_Google3) isConfig_CodeReview() {}

type isConfig_RepoManager interface {
	isConfig_RepoManager()
}

type Config_ParentChildRepoManager struct {
	ParentChildRepoManager *ParentChildRepoManagerConfig `protobuf:"bytes,20,opt,name=parent_child_repo_manager,json=parentChildRepoManager,proto3,oneof"`
}

type Config_AndroidRepoManager struct {
	AndroidRepoManager *AndroidRepoManagerConfig `protobuf:"bytes,21,opt,name=android_repo_manager,json=androidRepoManager,proto3,oneof"`
}

type Config_CommandRepoManager struct {
	CommandRepoManager *CommandRepoManagerConfig `protobuf:"bytes,22,opt,name=command_repo_manager,json=commandRepoManager,proto3,oneof"`
}

type Config_FreetypeRepoManager struct {
	FreetypeRepoManager *FreeTypeRepoManagerConfig `protobuf:"bytes,23,opt,name=freetype_repo_manager,json=freetypeRepoManager,proto3,oneof"`
}

type Config_Google3RepoManager struct {
	Google3RepoManager *Google3RepoManagerConfig `protobuf:"bytes,25,opt,name=google3_repo_manager,json=google3RepoManager,proto3,oneof"`
}

func (*Config_ParentChildRepoManager) isConfig_RepoManager() {}

func (*Config_AndroidRepoManager) isConfig_RepoManager() {}

func (*Config_CommandRepoManager) isConfig_RepoManager() {}

func (*Config_FreetypeRepoManager) isConfig_RepoManager() {}

func (*Config_Google3RepoManager) isConfig_RepoManager() {}

// CommitMsgConfig provides configuration for commit messages.
type CommitMsgConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// bug_project indicates which project (eg. in Monorail) the bugs attached
	// to various revisions are associated with.  If provided, any "Bug: " lines
	// from revisions in the roll which match the given project name will be
	// included in the roll itself.
	BugProject string `protobuf:"bytes,1,opt,name=bug_project,json=bugProject,proto3" json:"bug_project,omitempty"`
	// child_log_url_tmpl is a template for building log URLs using the IDs of
	// the from- and to-revisions of the child for a given roll.
	ChildLogUrlTmpl string `protobuf:"bytes,2,opt,name=child_log_url_tmpl,json=childLogUrlTmpl,proto3" json:"child_log_url_tmpl,omitempty"`
	// cq_extra_trybots are additional tryjobs to trigger as part of the commit
	// queue for every roll.
	CqExtraTrybots []string `protobuf:"bytes,3,rep,name=cq_extra_trybots,json=cqExtraTrybots,proto3" json:"cq_extra_trybots,omitempty"`
	// cq_do_not_cancel_trybots indicates that the commit queue should not
	// cancel tryjobs from old patch sets when a new patch set is uploaded.
	CqDoNotCancelTrybots bool `protobuf:"varint,4,opt,name=cq_do_not_cancel_trybots,json=cqDoNotCancelTrybots,proto3" json:"cq_do_not_cancel_trybots,omitempty"`
	// include_log indicates whether the list of revisions contained in the roll
	// should be included as part of the commit message.
	IncludeLog bool `protobuf:"varint,5,opt,name=include_log,json=includeLog,proto3" json:"include_log,omitempty"`
	// include_revision_count indicates whether the number of revisions
	// contained in the roll should be included in the subject line of the
	// commit message.
	IncludeRevisionCount bool `protobuf:"varint,6,opt,name=include_revision_count,json=includeRevisionCount,proto3" json:"include_revision_count,omitempty"`
	// include_tbr_line indicates whether the "TBR:" line should be included in
	// the commit message. This is required for some commit queues.
	IncludeTbrLine bool `protobuf:"varint,7,opt,name=include_tbr_line,json=includeTbrLine,proto3" json:"include_tbr_line,omitempty"`
	// include_tests indicates whether the "Test: " lines from the revisions in
	// the roll should be propagated through to the roll itself.
	IncludeTests bool `protobuf:"varint,8,opt,name=include_tests,json=includeTests,proto3" json:"include_tests,omitempty"`
	// extra_footers are any extra footers which should be added to all roll
	// commit messages.
	ExtraFooters []string `protobuf:"bytes,11,rep,name=extra_footers,json=extraFooters,proto3" json:"extra_footers,omitempty"`
	// word_wrap indicates that the commit message should be limited to the
	// given number of characters per line if provided.
	WordWrap int32 `protobuf:"varint,12,opt,name=word_wrap,json=wordWrap,proto3" json:"word_wrap,omitempty"`
	// built_in is the name of a built-in commit message template.
	BuiltIn CommitMsgConfig_BuiltIn `protobuf:"varint,9,opt,name=built_in,json=builtIn,proto3,enum=autoroll.config.CommitMsgConfig_BuiltIn" json:"built_in,omitempty"`
	// custom is a full custom commit message template string. It is possible to
	// specify a built-in template and then override parts of it in the custom
	// template.
	Custom        string `protobuf:"bytes,10,opt,name=custom,proto3" json:"custom,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitMsgConfig) Reset() {
	*x = CommitMsgConfig{}
	mi := &file_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitMsgConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitMsgConfig) ProtoMessage() {}

func (x *CommitMsgConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitMsgConfig.ProtoReflect.Descriptor instead.
func (*CommitMsgConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{1}
}

func (x *CommitMsgConfig) GetBugProject() string {
	if x != nil {
		return x.BugProject
	}
	return ""
}

func (x *CommitMsgConfig) GetChildLogUrlTmpl() string {
	if x != nil {
		return x.ChildLogUrlTmpl
	}
	return ""
}

func (x *CommitMsgConfig) GetCqExtraTrybots() []string {
	if x != nil {
		return x.CqExtraTrybots
	}
	return nil
}

func (x *CommitMsgConfig) GetCqDoNotCancelTrybots() bool {
	if x != nil {
		return x.CqDoNotCancelTrybots
	}
	return false
}

func (x *CommitMsgConfig) GetIncludeLog() bool {
	if x != nil {
		return x.IncludeLog
	}
	return false
}

func (x *CommitMsgConfig) GetIncludeRevisionCount() bool {
	if x != nil {
		return x.IncludeRevisionCount
	}
	return false
}

func (x *CommitMsgConfig) GetIncludeTbrLine() bool {
	if x != nil {
		return x.IncludeTbrLine
	}
	return false
}

func (x *CommitMsgConfig) GetIncludeTests() bool {
	if x != nil {
		return x.IncludeTests
	}
	return false
}

func (x *CommitMsgConfig) GetExtraFooters() []string {
	if x != nil {
		return x.ExtraFooters
	}
	return nil
}

func (x *CommitMsgConfig) GetWordWrap() int32 {
	if x != nil {
		return x.WordWrap
	}
	return 0
}

func (x *CommitMsgConfig) GetBuiltIn() CommitMsgConfig_BuiltIn {
	if x != nil {
		return x.BuiltIn
	}
	return CommitMsgConfig_DEFAULT
}

func (x *CommitMsgConfig) GetCustom() string {
	if x != nil {
		return x.Custom
	}
	return ""
}

// GerritConfig provides configuration for code review using Gerrit.
type GerritConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// url of the Gerrit host.
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// project name for uploaded CLs.
	Project string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
	// config indicates the mode of operation used by the Gerrit host, which
	// informs the roller of, for example, which labels to set. See the
	// autoroll/go/codereview package for possible values.
	Config        GerritConfig_Config `protobuf:"varint,3,opt,name=config,proto3,enum=autoroll.config.GerritConfig_Config" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GerritConfig) Reset() {
	*x = GerritConfig{}
	mi := &file_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GerritConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GerritConfig) ProtoMessage() {}

func (x *GerritConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GerritConfig.ProtoReflect.Descriptor instead.
func (*GerritConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{2}
}

func (x *GerritConfig) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *GerritConfig) GetProject() string {
	if x != nil {
		return x.Project
	}
	return ""
}

func (x *GerritConfig) GetConfig() GerritConfig_Config {
	if x != nil {
		return x.Config
	}
	return GerritConfig_ANDROID
}

// GitHubConfig provides configuration for code review using GitHub.
type GitHubConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// repo_owner is the owner of the GitHub repo.
	RepoOwner string `protobuf:"bytes,1,opt,name=repo_owner,json=repoOwner,proto3" json:"repo_owner,omitempty"`
	// repo_name is the name of the GitHub repo.
	RepoName string `protobuf:"bytes,2,opt,name=repo_name,json=repoName,proto3" json:"repo_name,omitempty"`
	// checks_wait_for indicates which GitHub checks must succeed before a pull
	// request may be merged. If they are failing, we wait for them to succeed
	// (eg. tree-status checks). Note: These checks are ignored during dry runs
	// because the PR is not going to be submitted so the tree-status checks
	// will not be important in that case.
	ChecksWaitFor []string `protobuf:"bytes,3,rep,name=checks_wait_for,json=checksWaitFor,proto3" json:"checks_wait_for,omitempty"`
	// token_secret is the name of the secret containing the auth token used to
	// access the GitHub API.
	TokenSecret string `protobuf:"bytes,4,opt,name=token_secret,json=tokenSecret,proto3" json:"token_secret,omitempty"`
	// ssh_key_secret is the name of the secret containing the SSH key used to
	// access GitHub repos.
	SshKeySecret  string `protobuf:"bytes,5,opt,name=ssh_key_secret,json=sshKeySecret,proto3" json:"ssh_key_secret,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GitHubConfig) Reset() {
	*x = GitHubConfig{}
	mi := &file_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitHubConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitHubConfig) ProtoMessage() {}

func (x *GitHubConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitHubConfig.ProtoReflect.Descriptor instead.
func (*GitHubConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{3}
}

func (x *GitHubConfig) GetRepoOwner() string {
	if x != nil {
		return x.RepoOwner
	}
	return ""
}

func (x *GitHubConfig) GetRepoName() string {
	if x != nil {
		return x.RepoName
	}
	return ""
}

func (x *GitHubConfig) GetChecksWaitFor() []string {
	if x != nil {
		return x.ChecksWaitFor
	}
	return nil
}

func (x *GitHubConfig) GetTokenSecret() string {
	if x != nil {
		return x.TokenSecret
	}
	return ""
}

func (x *GitHubConfig) GetSshKeySecret() string {
	if x != nil {
		return x.SshKeySecret
	}
	return ""
}

// Google3Config is an empty configuration object for Google3.
type Google3Config struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Google3Config) Reset() {
	*x = Google3Config{}
	mi := &file_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Google3Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Google3Config) ProtoMessage() {}

func (x *Google3Config) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Google3Config.ProtoReflect.Descriptor instead.
func (*Google3Config) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{4}
}

// KubernetesConfig provides Kubernetes configuration for the autoroll backend
// service for this roller.
type KubernetesConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cpu is the requested number of CPUs, eg. "250m".
	Cpu string `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// memory is the requested memory, eg. "2Gi".
	Memory string `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// readiness_failure_threshold indicates how many times the ready check may
	// fail.
	ReadinessFailureThreshold int32 `protobuf:"varint,3,opt,name=readiness_failure_threshold,json=readinessFailureThreshold,proto3" json:"readiness_failure_threshold,omitempty"`
	// readiness_initial_delay_seconds indicates how long to wait before
	// performing the ready check for the first time.
	ReadinessInitialDelaySeconds int32 `protobuf:"varint,4,opt,name=readiness_initial_delay_seconds,json=readinessInitialDelaySeconds,proto3" json:"readiness_initial_delay_seconds,omitempty"`
	// readiness_period_seconds indicates how often to perform the ready check.
	ReadinessPeriodSeconds int32 `protobuf:"varint,5,opt,name=readiness_period_seconds,json=readinessPeriodSeconds,proto3" json:"readiness_period_seconds,omitempty"`
	// disk indicates the size of the requested persistent disk.  If not
	// specified, no persistent disk is used.
	Disk string `protobuf:"bytes,6,opt,name=disk,proto3" json:"disk,omitempty"`
	// image used for the autoroll backend container.
	Image string `protobuf:"bytes,8,opt,name=image,proto3" json:"image,omitempty"`
	// extra_flags to pass to the autoroll-be binary.
	ExtraFlags    []string `protobuf:"bytes,9,rep,name=extra_flags,json=extraFlags,proto3" json:"extra_flags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KubernetesConfig) Reset() {
	*x = KubernetesConfig{}
	mi := &file_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KubernetesConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KubernetesConfig) ProtoMessage() {}

func (x *KubernetesConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KubernetesConfig.ProtoReflect.Descriptor instead.
func (*KubernetesConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{5}
}

func (x *KubernetesConfig) GetCpu() string {
	if x != nil {
		return x.Cpu
	}
	return ""
}

func (x *KubernetesConfig) GetMemory() string {
	if x != nil {
		return x.Memory
	}
	return ""
}

func (x *KubernetesConfig) GetReadinessFailureThreshold() int32 {
	if x != nil {
		return x.ReadinessFailureThreshold
	}
	return 0
}

func (x *KubernetesConfig) GetReadinessInitialDelaySeconds() int32 {
	if x != nil {
		return x.ReadinessInitialDelaySeconds
	}
	return 0
}

func (x *KubernetesConfig) GetReadinessPeriodSeconds() int32 {
	if x != nil {
		return x.ReadinessPeriodSeconds
	}
	return 0
}

func (x *KubernetesConfig) GetDisk() string {
	if x != nil {
		return x.Disk
	}
	return ""
}

func (x *KubernetesConfig) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *KubernetesConfig) GetExtraFlags() []string {
	if x != nil {
		return x.ExtraFlags
	}
	return nil
}

// AndroidRepoManagerConfig provides configuration for a roller which rolls into
// Android.
type AndroidRepoManagerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// child_repo_url is the URL of the child repo.
	ChildRepoUrl string `protobuf:"bytes,1,opt,name=child_repo_url,json=childRepoUrl,proto3" json:"child_repo_url,omitempty"`
	// child_branch is the Git branch of the child repo to track.
	ChildBranch string `protobuf:"bytes,2,opt,name=child_branch,json=childBranch,proto3" json:"child_branch,omitempty"`
	// child_path is the path to the child repo within the parent.
	ChildPath string `protobuf:"bytes,3,opt,name=child_path,json=childPath,proto3" json:"child_path,omitempty"`
	// parent_repo_url is the URL of the parent repo.
	ParentRepoUrl string `protobuf:"bytes,4,opt,name=parent_repo_url,json=parentRepoUrl,proto3" json:"parent_repo_url,omitempty"`
	// parent_branch is the Git branch of the parent repo to track.
	ParentBranch string `protobuf:"bytes,5,opt,name=parent_branch,json=parentBranch,proto3" json:"parent_branch,omitempty"`
	// child_rev_link_tmpl is a template used to create links to revisions of
	// the child repo. If not supplied, no links will be created.
	ChildRevLinkTmpl string `protobuf:"bytes,6,opt,name=child_rev_link_tmpl,json=childRevLinkTmpl,proto3" json:"child_rev_link_tmpl,omitempty"`
	// child_subdir indicates the subdirectory of the working directory (not the
	// parent repo) in which the child_path should be rooted. In most cases this
	// should be empty, but if child_path is relative to the parent repo dir
	// (eg. when DEPS specifies use_relative_paths), then this is required.
	ChildSubdir string `protobuf:"bytes,7,opt,name=child_subdir,json=childSubdir,proto3" json:"child_subdir,omitempty"`
	// metadata about the child project which should be updated in a file
	// checked into the parent repo.
	Metadata *AndroidRepoManagerConfig_ProjectMetadataFileConfig `protobuf:"bytes,9,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// include_authors_as_reviewers determines whether the authors of rolled
	// changes should be included as change reviewers.
	IncludeAuthorsAsReviewers bool `protobuf:"varint,10,opt,name=include_authors_as_reviewers,json=includeAuthorsAsReviewers,proto3" json:"include_authors_as_reviewers,omitempty"`
	// pre_upload describes command(s) to run before uploading roll CLs.
	PreUploadCommands *PreUploadConfig `protobuf:"bytes,11,opt,name=pre_upload_commands,json=preUploadCommands,proto3" json:"pre_upload_commands,omitempty"`
	// auto_approver_secret indicates that the roller should use the given
	// secret containing an auto-approver service account key to approve its own
	// changes.
	AutoApproverSecret string `protobuf:"bytes,12,opt,name=auto_approver_secret,json=autoApproverSecret,proto3" json:"auto_approver_secret,omitempty"`
	// default_bug_project indicates the Monorail project used when no project
	// is specified in "Bug: 123" lines in commit messages.
	DefaultBugProject string `protobuf:"bytes,13,opt,name=default_bug_project,json=defaultBugProject,proto3" json:"default_bug_project,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AndroidRepoManagerConfig) Reset() {
	*x = AndroidRepoManagerConfig{}
	mi := &file_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AndroidRepoManagerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AndroidRepoManagerConfig) ProtoMessage() {}

func (x *AndroidRepoManagerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AndroidRepoManagerConfig.ProtoReflect.Descriptor instead.
func (*AndroidRepoManagerConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{6}
}

func (x *AndroidRepoManagerConfig) GetChildRepoUrl() string {
	if x != nil {
		return x.ChildRepoUrl
	}
	return ""
}

func (x *AndroidRepoManagerConfig) GetChildBranch() string {
	if x != nil {
		return x.ChildBranch
	}
	return ""
}

func (x *AndroidRepoManagerConfig) GetChildPath() string {
	if x != nil {
		return x.ChildPath
	}
	return ""
}

func (x *AndroidRepoManagerConfig) GetParentRepoUrl() string {
	if x != nil {
		return x.ParentRepoUrl
	}
	return ""
}

func (x *AndroidRepoManagerConfig) GetParentBranch() string {
	if x != nil {
		return x.ParentBranch
	}
	return ""
}

func (x *AndroidRepoManagerConfig) GetChildRevLinkTmpl() string {
	if x != nil {
		return x.ChildRevLinkTmpl
	}
	return ""
}

func (x *AndroidRepoManagerConfig) GetChildSubdir() string {
	if x != nil {
		return x.ChildSubdir
	}
	return ""
}

func (x *AndroidRepoManagerConfig) GetMetadata() *AndroidRepoManagerConfig_ProjectMetadataFileConfig {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *AndroidRepoManagerConfig) GetIncludeAuthorsAsReviewers() bool {
	if x != nil {
		return x.IncludeAuthorsAsReviewers
	}
	return false
}

func (x *AndroidRepoManagerConfig) GetPreUploadCommands() *PreUploadConfig {
	if x != nil {
		return x.PreUploadCommands
	}
	return nil
}

func (x *AndroidRepoManagerConfig) GetAutoApproverSecret() string {
	if x != nil {
		return x.AutoApproverSecret
	}
	return ""
}

func (x *AndroidRepoManagerConfig) GetDefaultBugProject() string {
	if x != nil {
		return x.DefaultBugProject
	}
	return ""
}

// CommandRepoManagerConfig provides configuration for a roller which runs
// specified commands to perform different functions.
type CommandRepoManagerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// git_checkout configures the Git checkout of the parent repo.
	GitCheckout *GitCheckoutConfig `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	// short_rev_regex is a regular expression used to shorten revision IDs for
	// display.
	ShortRevRegex string `protobuf:"bytes,2,opt,name=short_rev_regex,json=shortRevRegex,proto3" json:"short_rev_regex,omitempty"`
	// get_tip_rev is a command used to obtain the latest revision of the Child.
	GetTipRev *CommandRepoManagerConfig_CommandConfig `protobuf:"bytes,3,opt,name=get_tip_rev,json=getTipRev,proto3" json:"get_tip_rev,omitempty"`
	// get_pinned_rev is a command used to obtain the currently-pinned revision
	// of the Child.
	GetPinnedRev *CommandRepoManagerConfig_CommandConfig `protobuf:"bytes,4,opt,name=get_pinned_rev,json=getPinnedRev,proto3" json:"get_pinned_rev,omitempty"`
	// set_pinned_rev is a command used to update the currently-pinned revision
	// of the Child.
	SetPinnedRev  *CommandRepoManagerConfig_CommandConfig `protobuf:"bytes,5,opt,name=set_pinned_rev,json=setPinnedRev,proto3" json:"set_pinned_rev,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommandRepoManagerConfig) Reset() {
	*x = CommandRepoManagerConfig{}
	mi := &file_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommandRepoManagerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommandRepoManagerConfig) ProtoMessage() {}

func (x *CommandRepoManagerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommandRepoManagerConfig.ProtoReflect.Descriptor instead.
func (*CommandRepoManagerConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{7}
}

func (x *CommandRepoManagerConfig) GetGitCheckout() *GitCheckoutConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

func (x *CommandRepoManagerConfig) GetShortRevRegex() string {
	if x != nil {
		return x.ShortRevRegex
	}
	return ""
}

func (x *CommandRepoManagerConfig) GetGetTipRev() *CommandRepoManagerConfig_CommandConfig {
	if x != nil {
		return x.GetTipRev
	}
	return nil
}

func (x *CommandRepoManagerConfig) GetGetPinnedRev() *CommandRepoManagerConfig_CommandConfig {
	if x != nil {
		return x.GetPinnedRev
	}
	return nil
}

func (x *CommandRepoManagerConfig) GetSetPinnedRev() *CommandRepoManagerConfig_CommandConfig {
	if x != nil {
		return x.SetPinnedRev
	}
	return nil
}

// FreeTypeRepoManagerConfig provides configuration for the FreeType roller.
type FreeTypeRepoManagerConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Parent        *FreeTypeParentConfig  `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	Child         *GitilesChildConfig    `protobuf:"bytes,2,opt,name=child,proto3" json:"child,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FreeTypeRepoManagerConfig) Reset() {
	*x = FreeTypeRepoManagerConfig{}
	mi := &file_config_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreeTypeRepoManagerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreeTypeRepoManagerConfig) ProtoMessage() {}

func (x *FreeTypeRepoManagerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreeTypeRepoManagerConfig.ProtoReflect.Descriptor instead.
func (*FreeTypeRepoManagerConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{8}
}

func (x *FreeTypeRepoManagerConfig) GetParent() *FreeTypeParentConfig {
	if x != nil {
		return x.Parent
	}
	return nil
}

func (x *FreeTypeRepoManagerConfig) GetChild() *GitilesChildConfig {
	if x != nil {
		return x.Child
	}
	return nil
}

// Google3RepoManagerConfig provides configuration for a roller into Google3.
type Google3RepoManagerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// child_branch is the branch of the child repo to track.
	ChildBranch string `protobuf:"bytes,1,opt,name=child_branch,json=childBranch,proto3" json:"child_branch,omitempty"`
	// child_repo is the URL of the child repo.
	ChildRepo     string `protobuf:"bytes,2,opt,name=child_repo,json=childRepo,proto3" json:"child_repo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Google3RepoManagerConfig) Reset() {
	*x = Google3RepoManagerConfig{}
	mi := &file_config_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Google3RepoManagerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Google3RepoManagerConfig) ProtoMessage() {}

func (x *Google3RepoManagerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Google3RepoManagerConfig.ProtoReflect.Descriptor instead.
func (*Google3RepoManagerConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{9}
}

func (x *Google3RepoManagerConfig) GetChildBranch() string {
	if x != nil {
		return x.ChildBranch
	}
	return ""
}

func (x *Google3RepoManagerConfig) GetChildRepo() string {
	if x != nil {
		return x.ChildRepo
	}
	return ""
}

// ParentChildRepoManagerConfig provides configuration for a roller which
// combines a pre-defined Parent and Child type.
type ParentChildRepoManagerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// parent is the entity which depends on the child and receives the rolls.
	//
	// Types that are valid to be assigned to Parent:
	//
	//	*ParentChildRepoManagerConfig_CopyParent
	//	*ParentChildRepoManagerConfig_DepsLocalGithubParent
	//	*ParentChildRepoManagerConfig_DepsLocalGerritParent
	//	*ParentChildRepoManagerConfig_GitCheckoutGithubFileParent
	//	*ParentChildRepoManagerConfig_GitilesParent
	//	*ParentChildRepoManagerConfig_GoModGerritParent
	//	*ParentChildRepoManagerConfig_GitCheckoutGerritParent
	Parent isParentChildRepoManagerConfig_Parent `protobuf_oneof:"parent"`
	// child is the entity which is depended on by the parent and is rolled.
	//
	// Types that are valid to be assigned to Child:
	//
	//	*ParentChildRepoManagerConfig_CipdChild
	//	*ParentChildRepoManagerConfig_FuchsiaSdkChild
	//	*ParentChildRepoManagerConfig_GitCheckoutChild
	//	*ParentChildRepoManagerConfig_GitCheckoutGithubChild
	//	*ParentChildRepoManagerConfig_GitilesChild
	//	*ParentChildRepoManagerConfig_SemverGcsChild
	//	*ParentChildRepoManagerConfig_DockerChild
	Child isParentChildRepoManagerConfig_Child `protobuf_oneof:"child"`
	// revision_filter filters out revisions of the child which should not be
	// considered as roll candidates.
	BuildbucketRevisionFilter []*BuildbucketRevisionFilterConfig `protobuf:"bytes,12,rep,name=buildbucket_revision_filter,json=buildbucketRevisionFilter,proto3" json:"buildbucket_revision_filter,omitempty"`
	CipdRevisionFilter        []*CIPDRevisionFilterConfig        `protobuf:"bytes,13,rep,name=cipd_revision_filter,json=cipdRevisionFilter,proto3" json:"cipd_revision_filter,omitempty"`
	ValidHttpRevisionFilter   []*ValidHttpRevisionFilterConfig   `protobuf:"bytes,15,rep,name=valid_http_revision_filter,json=validHttpRevisionFilter,proto3" json:"valid_http_revision_filter,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *ParentChildRepoManagerConfig) Reset() {
	*x = ParentChildRepoManagerConfig{}
	mi := &file_config_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParentChildRepoManagerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParentChildRepoManagerConfig) ProtoMessage() {}

func (x *ParentChildRepoManagerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParentChildRepoManagerConfig.ProtoReflect.Descriptor instead.
func (*ParentChildRepoManagerConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{10}
}

func (x *ParentChildRepoManagerConfig) GetParent() isParentChildRepoManagerConfig_Parent {
	if x != nil {
		return x.Parent
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetCopyParent() *CopyParentConfig {
	if x != nil {
		if x, ok := x.Parent.(*ParentChildRepoManagerConfig_CopyParent); ok {
			return x.CopyParent
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetDepsLocalGithubParent() *DEPSLocalGitHubParentConfig {
	if x != nil {
		if x, ok := x.Parent.(*ParentChildRepoManagerConfig_DepsLocalGithubParent); ok {
			return x.DepsLocalGithubParent
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetDepsLocalGerritParent() *DEPSLocalGerritParentConfig {
	if x != nil {
		if x, ok := x.Parent.(*ParentChildRepoManagerConfig_DepsLocalGerritParent); ok {
			return x.DepsLocalGerritParent
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetGitCheckoutGithubFileParent() *GitCheckoutGitHubFileParentConfig {
	if x != nil {
		if x, ok := x.Parent.(*ParentChildRepoManagerConfig_GitCheckoutGithubFileParent); ok {
			return x.GitCheckoutGithubFileParent
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetGitilesParent() *GitilesParentConfig {
	if x != nil {
		if x, ok := x.Parent.(*ParentChildRepoManagerConfig_GitilesParent); ok {
			return x.GitilesParent
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetGoModGerritParent() *GoModGerritParentConfig {
	if x != nil {
		if x, ok := x.Parent.(*ParentChildRepoManagerConfig_GoModGerritParent); ok {
			return x.GoModGerritParent
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetGitCheckoutGerritParent() *GitCheckoutGerritParentConfig {
	if x != nil {
		if x, ok := x.Parent.(*ParentChildRepoManagerConfig_GitCheckoutGerritParent); ok {
			return x.GitCheckoutGerritParent
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetChild() isParentChildRepoManagerConfig_Child {
	if x != nil {
		return x.Child
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetCipdChild() *CIPDChildConfig {
	if x != nil {
		if x, ok := x.Child.(*ParentChildRepoManagerConfig_CipdChild); ok {
			return x.CipdChild
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetFuchsiaSdkChild() *FuchsiaSDKChildConfig {
	if x != nil {
		if x, ok := x.Child.(*ParentChildRepoManagerConfig_FuchsiaSdkChild); ok {
			return x.FuchsiaSdkChild
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetGitCheckoutChild() *GitCheckoutChildConfig {
	if x != nil {
		if x, ok := x.Child.(*ParentChildRepoManagerConfig_GitCheckoutChild); ok {
			return x.GitCheckoutChild
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetGitCheckoutGithubChild() *GitCheckoutGitHubChildConfig {
	if x != nil {
		if x, ok := x.Child.(*ParentChildRepoManagerConfig_GitCheckoutGithubChild); ok {
			return x.GitCheckoutGithubChild
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetGitilesChild() *GitilesChildConfig {
	if x != nil {
		if x, ok := x.Child.(*ParentChildRepoManagerConfig_GitilesChild); ok {
			return x.GitilesChild
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetSemverGcsChild() *SemVerGCSChildConfig {
	if x != nil {
		if x, ok := x.Child.(*ParentChildRepoManagerConfig_SemverGcsChild); ok {
			return x.SemverGcsChild
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetDockerChild() *DockerChildConfig {
	if x != nil {
		if x, ok := x.Child.(*ParentChildRepoManagerConfig_DockerChild); ok {
			return x.DockerChild
		}
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetBuildbucketRevisionFilter() []*BuildbucketRevisionFilterConfig {
	if x != nil {
		return x.BuildbucketRevisionFilter
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetCipdRevisionFilter() []*CIPDRevisionFilterConfig {
	if x != nil {
		return x.CipdRevisionFilter
	}
	return nil
}

func (x *ParentChildRepoManagerConfig) GetValidHttpRevisionFilter() []*ValidHttpRevisionFilterConfig {
	if x != nil {
		return x.ValidHttpRevisionFilter
	}
	return nil
}

type isParentChildRepoManagerConfig_Parent interface {
	isParentChildRepoManagerConfig_Parent()
}

type ParentChildRepoManagerConfig_CopyParent struct {
	CopyParent *CopyParentConfig `protobuf:"bytes,1,opt,name=copy_parent,json=copyParent,proto3,oneof"`
}

type ParentChildRepoManagerConfig_DepsLocalGithubParent struct {
	DepsLocalGithubParent *DEPSLocalGitHubParentConfig `protobuf:"bytes,2,opt,name=deps_local_github_parent,json=depsLocalGithubParent,proto3,oneof"`
}

type ParentChildRepoManagerConfig_DepsLocalGerritParent struct {
	DepsLocalGerritParent *DEPSLocalGerritParentConfig `protobuf:"bytes,3,opt,name=deps_local_gerrit_parent,json=depsLocalGerritParent,proto3,oneof"`
}

type ParentChildRepoManagerConfig_GitCheckoutGithubFileParent struct {
	GitCheckoutGithubFileParent *GitCheckoutGitHubFileParentConfig `protobuf:"bytes,4,opt,name=git_checkout_github_file_parent,json=gitCheckoutGithubFileParent,proto3,oneof"`
}

type ParentChildRepoManagerConfig_GitilesParent struct {
	GitilesParent *GitilesParentConfig `protobuf:"bytes,5,opt,name=gitiles_parent,json=gitilesParent,proto3,oneof"`
}

type ParentChildRepoManagerConfig_GoModGerritParent struct {
	GoModGerritParent *GoModGerritParentConfig `protobuf:"bytes,14,opt,name=go_mod_gerrit_parent,json=goModGerritParent,proto3,oneof"`
}

type ParentChildRepoManagerConfig_GitCheckoutGerritParent struct {
	GitCheckoutGerritParent *GitCheckoutGerritParentConfig `protobuf:"bytes,17,opt,name=git_checkout_gerrit_parent,json=gitCheckoutGerritParent,proto3,oneof"`
}

func (*ParentChildRepoManagerConfig_CopyParent) isParentChildRepoManagerConfig_Parent() {}

func (*ParentChildRepoManagerConfig_DepsLocalGithubParent) isParentChildRepoManagerConfig_Parent() {}

func (*ParentChildRepoManagerConfig_DepsLocalGerritParent) isParentChildRepoManagerConfig_Parent() {}

func (*ParentChildRepoManagerConfig_GitCheckoutGithubFileParent) isParentChildRepoManagerConfig_Parent() {
}

func (*ParentChildRepoManagerConfig_GitilesParent) isParentChildRepoManagerConfig_Parent() {}

func (*ParentChildRepoManagerConfig_GoModGerritParent) isParentChildRepoManagerConfig_Parent() {}

func (*ParentChildRepoManagerConfig_GitCheckoutGerritParent) isParentChildRepoManagerConfig_Parent() {
}

type isParentChildRepoManagerConfig_Child interface {
	isParentChildRepoManagerConfig_Child()
}

type ParentChildRepoManagerConfig_CipdChild struct {
	CipdChild *CIPDChildConfig `protobuf:"bytes,6,opt,name=cipd_child,json=cipdChild,proto3,oneof"`
}

type ParentChildRepoManagerConfig_FuchsiaSdkChild struct {
	FuchsiaSdkChild *FuchsiaSDKChildConfig `protobuf:"bytes,7,opt,name=fuchsia_sdk_child,json=fuchsiaSdkChild,proto3,oneof"`
}

type ParentChildRepoManagerConfig_GitCheckoutChild struct {
	GitCheckoutChild *GitCheckoutChildConfig `protobuf:"bytes,8,opt,name=git_checkout_child,json=gitCheckoutChild,proto3,oneof"`
}

type ParentChildRepoManagerConfig_GitCheckoutGithubChild struct {
	GitCheckoutGithubChild *GitCheckoutGitHubChildConfig `protobuf:"bytes,9,opt,name=git_checkout_github_child,json=gitCheckoutGithubChild,proto3,oneof"`
}

type ParentChildRepoManagerConfig_GitilesChild struct {
	GitilesChild *GitilesChildConfig `protobuf:"bytes,10,opt,name=gitiles_child,json=gitilesChild,proto3,oneof"`
}

type ParentChildRepoManagerConfig_SemverGcsChild struct {
	SemverGcsChild *SemVerGCSChildConfig `protobuf:"bytes,11,opt,name=semver_gcs_child,json=semverGcsChild,proto3,oneof"`
}

type ParentChildRepoManagerConfig_DockerChild struct {
	DockerChild *DockerChildConfig `protobuf:"bytes,16,opt,name=docker_child,json=dockerChild,proto3,oneof"`
}

func (*ParentChildRepoManagerConfig_CipdChild) isParentChildRepoManagerConfig_Child() {}

func (*ParentChildRepoManagerConfig_FuchsiaSdkChild) isParentChildRepoManagerConfig_Child() {}

func (*ParentChildRepoManagerConfig_GitCheckoutChild) isParentChildRepoManagerConfig_Child() {}

func (*ParentChildRepoManagerConfig_GitCheckoutGithubChild) isParentChildRepoManagerConfig_Child() {}

func (*ParentChildRepoManagerConfig_GitilesChild) isParentChildRepoManagerConfig_Child() {}

func (*ParentChildRepoManagerConfig_SemverGcsChild) isParentChildRepoManagerConfig_Child() {}

func (*ParentChildRepoManagerConfig_DockerChild) isParentChildRepoManagerConfig_Child() {}

// CopyParentConfig provides configuration for a Parent which copies the Child
// into itself. It uses Gitiles and Gerrit instead of a local checkout.
type CopyParentConfig struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	Gitiles       *GitilesParentConfig          `protobuf:"bytes,1,opt,name=gitiles,proto3" json:"gitiles,omitempty"`
	Copies        []*CopyParentConfig_CopyEntry `protobuf:"bytes,2,rep,name=copies,proto3" json:"copies,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CopyParentConfig) Reset() {
	*x = CopyParentConfig{}
	mi := &file_config_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CopyParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyParentConfig) ProtoMessage() {}

func (x *CopyParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyParentConfig.ProtoReflect.Descriptor instead.
func (*CopyParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{11}
}

func (x *CopyParentConfig) GetGitiles() *GitilesParentConfig {
	if x != nil {
		return x.Gitiles
	}
	return nil
}

func (x *CopyParentConfig) GetCopies() []*CopyParentConfig_CopyEntry {
	if x != nil {
		return x.Copies
	}
	return nil
}

// DEPSLocalGitHubParentConfig provides configuration for a Parent which uses a
// local Git checkout with DEPS and uploads pull requests to GitHub.
type DEPSLocalGitHubParentConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DepsLocal     *DEPSLocalParentConfig `protobuf:"bytes,1,opt,name=deps_local,json=depsLocal,proto3" json:"deps_local,omitempty"`
	Github        *GitHubConfig          `protobuf:"bytes,2,opt,name=github,proto3" json:"github,omitempty"`
	ForkRepoUrl   string                 `protobuf:"bytes,3,opt,name=fork_repo_url,json=forkRepoUrl,proto3" json:"fork_repo_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DEPSLocalGitHubParentConfig) Reset() {
	*x = DEPSLocalGitHubParentConfig{}
	mi := &file_config_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DEPSLocalGitHubParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DEPSLocalGitHubParentConfig) ProtoMessage() {}

func (x *DEPSLocalGitHubParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DEPSLocalGitHubParentConfig.ProtoReflect.Descriptor instead.
func (*DEPSLocalGitHubParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{12}
}

func (x *DEPSLocalGitHubParentConfig) GetDepsLocal() *DEPSLocalParentConfig {
	if x != nil {
		return x.DepsLocal
	}
	return nil
}

func (x *DEPSLocalGitHubParentConfig) GetGithub() *GitHubConfig {
	if x != nil {
		return x.Github
	}
	return nil
}

func (x *DEPSLocalGitHubParentConfig) GetForkRepoUrl() string {
	if x != nil {
		return x.ForkRepoUrl
	}
	return ""
}

// DEPSLocalGerritParentConfig provides configuration for a Parent which uses a
// local Git checkout with DEPS and uploads CLs to Gerrit.
type DEPSLocalGerritParentConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DepsLocal     *DEPSLocalParentConfig `protobuf:"bytes,1,opt,name=deps_local,json=depsLocal,proto3" json:"deps_local,omitempty"`
	Gerrit        *GerritConfig          `protobuf:"bytes,2,opt,name=gerrit,proto3" json:"gerrit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DEPSLocalGerritParentConfig) Reset() {
	*x = DEPSLocalGerritParentConfig{}
	mi := &file_config_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DEPSLocalGerritParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DEPSLocalGerritParentConfig) ProtoMessage() {}

func (x *DEPSLocalGerritParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DEPSLocalGerritParentConfig.ProtoReflect.Descriptor instead.
func (*DEPSLocalGerritParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{13}
}

func (x *DEPSLocalGerritParentConfig) GetDepsLocal() *DEPSLocalParentConfig {
	if x != nil {
		return x.DepsLocal
	}
	return nil
}

func (x *DEPSLocalGerritParentConfig) GetGerrit() *GerritConfig {
	if x != nil {
		return x.Gerrit
	}
	return nil
}

// GitCheckoutGitHubParentConfig provides configuration for a Parent which
// uses a local Git checkout and uploads pull requests to GitHub.
// TODO(borenet): Why doesn't this contain the GitHubConfig? Is this even
// needed?
type GitCheckoutGitHubParentConfig struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	GitCheckout   *GitCheckoutParentConfig `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	ForkRepoUrl   string                   `protobuf:"bytes,2,opt,name=fork_repo_url,json=forkRepoUrl,proto3" json:"fork_repo_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GitCheckoutGitHubParentConfig) Reset() {
	*x = GitCheckoutGitHubParentConfig{}
	mi := &file_config_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitCheckoutGitHubParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitCheckoutGitHubParentConfig) ProtoMessage() {}

func (x *GitCheckoutGitHubParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitCheckoutGitHubParentConfig.ProtoReflect.Descriptor instead.
func (*GitCheckoutGitHubParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{14}
}

func (x *GitCheckoutGitHubParentConfig) GetGitCheckout() *GitCheckoutParentConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

func (x *GitCheckoutGitHubParentConfig) GetForkRepoUrl() string {
	if x != nil {
		return x.ForkRepoUrl
	}
	return ""
}

// GitCheckoutGerritParentConfig provides configuration for a Parent which
// uses a local Git checkout and uploads CLs to Gerrit.
type GitCheckoutGerritParentConfig struct {
	state       protoimpl.MessageState   `protogen:"open.v1"`
	GitCheckout *GitCheckoutParentConfig `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	// pre_upload describes command(s) to run before uploading roll CLs.
	PreUploadCommands *PreUploadConfig `protobuf:"bytes,2,opt,name=pre_upload_commands,json=preUploadCommands,proto3" json:"pre_upload_commands,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GitCheckoutGerritParentConfig) Reset() {
	*x = GitCheckoutGerritParentConfig{}
	mi := &file_config_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitCheckoutGerritParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitCheckoutGerritParentConfig) ProtoMessage() {}

func (x *GitCheckoutGerritParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitCheckoutGerritParentConfig.ProtoReflect.Descriptor instead.
func (*GitCheckoutGerritParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{15}
}

func (x *GitCheckoutGerritParentConfig) GetGitCheckout() *GitCheckoutParentConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

func (x *GitCheckoutGerritParentConfig) GetPreUploadCommands() *PreUploadConfig {
	if x != nil {
		return x.PreUploadCommands
	}
	return nil
}

// GitCheckoutGitHubFileParentConfig provides configuration for a Parent which
// uses a local Git checkout and uploads pull requests to GitHub.
type GitCheckoutGitHubFileParentConfig struct {
	state       protoimpl.MessageState         `protogen:"open.v1"`
	GitCheckout *GitCheckoutGitHubParentConfig `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	// pre_upload describes command(s) to run before uploading roll CLs.
	PreUploadCommands *PreUploadConfig `protobuf:"bytes,3,opt,name=pre_upload_commands,json=preUploadCommands,proto3" json:"pre_upload_commands,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GitCheckoutGitHubFileParentConfig) Reset() {
	*x = GitCheckoutGitHubFileParentConfig{}
	mi := &file_config_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitCheckoutGitHubFileParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitCheckoutGitHubFileParentConfig) ProtoMessage() {}

func (x *GitCheckoutGitHubFileParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitCheckoutGitHubFileParentConfig.ProtoReflect.Descriptor instead.
func (*GitCheckoutGitHubFileParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{16}
}

func (x *GitCheckoutGitHubFileParentConfig) GetGitCheckout() *GitCheckoutGitHubParentConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

func (x *GitCheckoutGitHubFileParentConfig) GetPreUploadCommands() *PreUploadConfig {
	if x != nil {
		return x.PreUploadCommands
	}
	return nil
}

// GitilesParentConfig provides configuration for a Parent which uses Gitiles.
type GitilesParentConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gitiles       *GitilesConfig         `protobuf:"bytes,1,opt,name=gitiles,proto3" json:"gitiles,omitempty"`
	Dep           *DependencyConfig      `protobuf:"bytes,2,opt,name=dep,proto3" json:"dep,omitempty"`
	Gerrit        *GerritConfig          `protobuf:"bytes,3,opt,name=gerrit,proto3" json:"gerrit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GitilesParentConfig) Reset() {
	*x = GitilesParentConfig{}
	mi := &file_config_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitilesParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitilesParentConfig) ProtoMessage() {}

func (x *GitilesParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitilesParentConfig.ProtoReflect.Descriptor instead.
func (*GitilesParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{17}
}

func (x *GitilesParentConfig) GetGitiles() *GitilesConfig {
	if x != nil {
		return x.Gitiles
	}
	return nil
}

func (x *GitilesParentConfig) GetDep() *DependencyConfig {
	if x != nil {
		return x.Dep
	}
	return nil
}

func (x *GitilesParentConfig) GetGerrit() *GerritConfig {
	if x != nil {
		return x.Gerrit
	}
	return nil
}

// GitilesConfig provides configuration for a Git repo in Gitiles.
type GitilesConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// branch to track.
	Branch string `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	// repo_url from which to load Git data.
	RepoUrl string `protobuf:"bytes,2,opt,name=repo_url,json=repoUrl,proto3" json:"repo_url,omitempty"`
	// dependencies is an optional specification of dependencies to track.
	// Revisions generated by the checkout will contain the pinned versions of
	// these dependencies.
	Dependencies []*VersionFileConfig `protobuf:"bytes,3,rep,name=dependencies,proto3" json:"dependencies,omitempty"`
	// default_bug_project indicates the Monorail project used when no project
	// is specified in "Bug: 123" lines in commit messages.
	DefaultBugProject string `protobuf:"bytes,4,opt,name=default_bug_project,json=defaultBugProject,proto3" json:"default_bug_project,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GitilesConfig) Reset() {
	*x = GitilesConfig{}
	mi := &file_config_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitilesConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitilesConfig) ProtoMessage() {}

func (x *GitilesConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitilesConfig.ProtoReflect.Descriptor instead.
func (*GitilesConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{18}
}

func (x *GitilesConfig) GetBranch() string {
	if x != nil {
		return x.Branch
	}
	return ""
}

func (x *GitilesConfig) GetRepoUrl() string {
	if x != nil {
		return x.RepoUrl
	}
	return ""
}

func (x *GitilesConfig) GetDependencies() []*VersionFileConfig {
	if x != nil {
		return x.Dependencies
	}
	return nil
}

func (x *GitilesConfig) GetDefaultBugProject() string {
	if x != nil {
		return x.DefaultBugProject
	}
	return ""
}

// GoModGerritParentConfig provides configuration for a Parent which uses Go
// modules and uploads pull requests to Gerrit.
type GoModGerritParentConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GoMod         *GoModParentConfig     `protobuf:"bytes,1,opt,name=go_mod,json=goMod,proto3" json:"go_mod,omitempty"`
	Gerrit        *GerritConfig          `protobuf:"bytes,2,opt,name=gerrit,proto3" json:"gerrit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GoModGerritParentConfig) Reset() {
	*x = GoModGerritParentConfig{}
	mi := &file_config_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GoModGerritParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GoModGerritParentConfig) ProtoMessage() {}

func (x *GoModGerritParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GoModGerritParentConfig.ProtoReflect.Descriptor instead.
func (*GoModGerritParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{19}
}

func (x *GoModGerritParentConfig) GetGoMod() *GoModParentConfig {
	if x != nil {
		return x.GoMod
	}
	return nil
}

func (x *GoModGerritParentConfig) GetGerrit() *GerritConfig {
	if x != nil {
		return x.Gerrit
	}
	return nil
}

// GoModParentConfig provides configuration for a Parent which uses Go modules.
type GoModParentConfig struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	GitCheckout *GitCheckoutConfig     `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	// module_path is the Go module path of the dependency.
	ModulePath string `protobuf:"bytes,2,opt,name=module_path,json=modulePath,proto3" json:"module_path,omitempty"`
	// find_and_replace lists additional files in which all instances of the
	// previous primary revision ID should be replaced with the new primary
	// revision ID.
	FindAndReplace []string `protobuf:"bytes,3,rep,name=find_and_replace,json=findAndReplace,proto3" json:"find_and_replace,omitempty"`
	// pre_upload describes command(s) to run before uploading roll CLs.
	PreUploadCommands *PreUploadConfig `protobuf:"bytes,5,opt,name=pre_upload_commands,json=preUploadCommands,proto3" json:"pre_upload_commands,omitempty"`
	// go_cmd is an alternate command to run to invoke Go, eg. for hermetic
	// installation via Bazel.
	GoCmd         string `protobuf:"bytes,6,opt,name=go_cmd,json=goCmd,proto3" json:"go_cmd,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GoModParentConfig) Reset() {
	*x = GoModParentConfig{}
	mi := &file_config_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GoModParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GoModParentConfig) ProtoMessage() {}

func (x *GoModParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GoModParentConfig.ProtoReflect.Descriptor instead.
func (*GoModParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{20}
}

func (x *GoModParentConfig) GetGitCheckout() *GitCheckoutConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

func (x *GoModParentConfig) GetModulePath() string {
	if x != nil {
		return x.ModulePath
	}
	return ""
}

func (x *GoModParentConfig) GetFindAndReplace() []string {
	if x != nil {
		return x.FindAndReplace
	}
	return nil
}

func (x *GoModParentConfig) GetPreUploadCommands() *PreUploadConfig {
	if x != nil {
		return x.PreUploadCommands
	}
	return nil
}

func (x *GoModParentConfig) GetGoCmd() string {
	if x != nil {
		return x.GoCmd
	}
	return ""
}

// DEPSLocalConfig provides configuration for a Parent which uses a local
// checkout and DEPS to manage dependencies.
type DEPSLocalParentConfig struct {
	state       protoimpl.MessageState   `protogen:"open.v1"`
	GitCheckout *GitCheckoutParentConfig `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	// child_path is the path to the child repo within the parent.
	ChildPath string `protobuf:"bytes,2,opt,name=child_path,json=childPath,proto3" json:"child_path,omitempty"`
	// child_subdir is the subdirectory of the workdir in which the child_path
	// should be rooted.  In most cases, this should be empty, but if child_path
	// is relative to the parent repo dir (eg. when DEPS specifies
	// use_relative_paths), then this is required.
	ChildSubdir string `protobuf:"bytes,3,opt,name=child_subdir,json=childSubdir,proto3" json:"child_subdir,omitempty"`
	// checkout_path is the path to the repo within the checkout root
	CheckoutPath string `protobuf:"bytes,4,opt,name=checkout_path,json=checkoutPath,proto3" json:"checkout_path,omitempty"`
	// gclient_spec overrides the default gclient spec.
	GclientSpec string `protobuf:"bytes,5,opt,name=gclient_spec,json=gclientSpec,proto3" json:"gclient_spec,omitempty"`
	// run_hooks indicates whether to run "gclient runhooks" after syncing.
	RunHooks bool `protobuf:"varint,7,opt,name=run_hooks,json=runHooks,proto3" json:"run_hooks,omitempty"`
	// pre_upload describes command(s) to run before uploading roll CLs.
	PreUploadCommands *PreUploadConfig `protobuf:"bytes,8,opt,name=pre_upload_commands,json=preUploadCommands,proto3" json:"pre_upload_commands,omitempty"`
	// parent_subdir is the subdirectory of the workdir in which the parent repo
	// should be checked out. In most cases this should be empty, but if the
	// gclient spec uses `"name": "."` it may be required.
	ParentSubdir  string `protobuf:"bytes,9,opt,name=parent_subdir,json=parentSubdir,proto3" json:"parent_subdir,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DEPSLocalParentConfig) Reset() {
	*x = DEPSLocalParentConfig{}
	mi := &file_config_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DEPSLocalParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DEPSLocalParentConfig) ProtoMessage() {}

func (x *DEPSLocalParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DEPSLocalParentConfig.ProtoReflect.Descriptor instead.
func (*DEPSLocalParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{21}
}

func (x *DEPSLocalParentConfig) GetGitCheckout() *GitCheckoutParentConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

func (x *DEPSLocalParentConfig) GetChildPath() string {
	if x != nil {
		return x.ChildPath
	}
	return ""
}

func (x *DEPSLocalParentConfig) GetChildSubdir() string {
	if x != nil {
		return x.ChildSubdir
	}
	return ""
}

func (x *DEPSLocalParentConfig) GetCheckoutPath() string {
	if x != nil {
		return x.CheckoutPath
	}
	return ""
}

func (x *DEPSLocalParentConfig) GetGclientSpec() string {
	if x != nil {
		return x.GclientSpec
	}
	return ""
}

func (x *DEPSLocalParentConfig) GetRunHooks() bool {
	if x != nil {
		return x.RunHooks
	}
	return false
}

func (x *DEPSLocalParentConfig) GetPreUploadCommands() *PreUploadConfig {
	if x != nil {
		return x.PreUploadCommands
	}
	return nil
}

func (x *DEPSLocalParentConfig) GetParentSubdir() string {
	if x != nil {
		return x.ParentSubdir
	}
	return ""
}

// GitCheckoutParentConfig provides configuration for a Parent which uses a
// local checkout to create changes.
type GitCheckoutParentConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GitCheckout   *GitCheckoutConfig     `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	Dep           *DependencyConfig      `protobuf:"bytes,2,opt,name=dep,proto3" json:"dep,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GitCheckoutParentConfig) Reset() {
	*x = GitCheckoutParentConfig{}
	mi := &file_config_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitCheckoutParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitCheckoutParentConfig) ProtoMessage() {}

func (x *GitCheckoutParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitCheckoutParentConfig.ProtoReflect.Descriptor instead.
func (*GitCheckoutParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{22}
}

func (x *GitCheckoutParentConfig) GetGitCheckout() *GitCheckoutConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

func (x *GitCheckoutParentConfig) GetDep() *DependencyConfig {
	if x != nil {
		return x.Dep
	}
	return nil
}

// FreeTypeParentConfig provides configuration for the FreeType Parent.
type FreeTypeParentConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gitiles       *GitilesParentConfig   `protobuf:"bytes,1,opt,name=gitiles,proto3" json:"gitiles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FreeTypeParentConfig) Reset() {
	*x = FreeTypeParentConfig{}
	mi := &file_config_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreeTypeParentConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreeTypeParentConfig) ProtoMessage() {}

func (x *FreeTypeParentConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreeTypeParentConfig.ProtoReflect.Descriptor instead.
func (*FreeTypeParentConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{23}
}

func (x *FreeTypeParentConfig) GetGitiles() *GitilesParentConfig {
	if x != nil {
		return x.Gitiles
	}
	return nil
}

// CIPDChildConfig provides configuration for a CIPD package Child.
type CIPDChildConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name of the package.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// tag to track.
	Tag string `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	// gitiles_repo is an optional config for a git repo which should be used
	// for generating the list of revisions in a roll. Both the old and new
	// CIPD package version must provide a git_revision tag in order for this
	// to work. If provided, the revision ID will be of the form
	// `git_revision:<hash>` instead of using the CIPD package instance ID.
	// Deprecated in favor of source_repo.
	GitilesRepo string `protobuf:"bytes,4,opt,name=gitiles_repo,json=gitilesRepo,proto3" json:"gitiles_repo,omitempty"`
	// revision_id_tag is a tag key whose value will be used as the revision ID
	// instead of the CIPD package instance ID.  Overrides git_revision for the
	// revision ID if gitiles_repo was provided.
	RevisionIdTag string `protobuf:"bytes,5,opt,name=revision_id_tag,json=revisionIdTag,proto3" json:"revision_id_tag,omitempty"`
	// revision_id_tag_strip_key indicates that the revision ID should not
	// include the revision_id_tag key.  Only relevant if revision_id_tag is
	// set.
	RevisionIdTagStripKey bool `protobuf:"varint,6,opt,name=revision_id_tag_strip_key,json=revisionIdTagStripKey,proto3" json:"revision_id_tag_strip_key,omitempty"`
	// source_repo is an optional config for a gitiles repo which should be used
	// for generating the list of revisions in a roll. Both the old and new
	// CIPD package version must provide a git_revision tag in order for this
	// to work. If provided, the revision ID will be of the form
	// `git_revision:<hash>` instead of using the CIPD package instance ID.
	SourceRepo    *GitilesConfig `protobuf:"bytes,7,opt,name=source_repo,json=sourceRepo,proto3" json:"source_repo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CIPDChildConfig) Reset() {
	*x = CIPDChildConfig{}
	mi := &file_config_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CIPDChildConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CIPDChildConfig) ProtoMessage() {}

func (x *CIPDChildConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CIPDChildConfig.ProtoReflect.Descriptor instead.
func (*CIPDChildConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{24}
}

func (x *CIPDChildConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CIPDChildConfig) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *CIPDChildConfig) GetGitilesRepo() string {
	if x != nil {
		return x.GitilesRepo
	}
	return ""
}

func (x *CIPDChildConfig) GetRevisionIdTag() string {
	if x != nil {
		return x.RevisionIdTag
	}
	return ""
}

func (x *CIPDChildConfig) GetRevisionIdTagStripKey() bool {
	if x != nil {
		return x.RevisionIdTagStripKey
	}
	return false
}

func (x *CIPDChildConfig) GetSourceRepo() *GitilesConfig {
	if x != nil {
		return x.SourceRepo
	}
	return nil
}

// FuchsiaSDKChildConfig provides configuration for the Fuchsia SDK Child.
type FuchsiaSDKChildConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// include_mac_sdk indicates whether to also roll the version of the Mac
	// SDK. Note that the dependency is not tracked separately; the Mac SDK is
	// simply rolled to the newest available version.
	// DEPRECATED: The presence of latest_mac_path indicates whether the Mac
	// SDK is included.
	IncludeMacSdk bool `protobuf:"varint,1,opt,name=include_mac_sdk,json=includeMacSdk,proto3" json:"include_mac_sdk,omitempty"`
	// gcs_bucket containing the SDK tarballs.
	GcsBucket string `protobuf:"bytes,2,opt,name=gcs_bucket,json=gcsBucket,proto3" json:"gcs_bucket,omitempty"`
	// latest_linux_path is the path to the file containing the ID of the latest
	// Linux SDK.
	LatestLinuxPath string `protobuf:"bytes,3,opt,name=latest_linux_path,json=latestLinuxPath,proto3" json:"latest_linux_path,omitempty"`
	// latest_mac_path is the path to the file containing the ID of the latest
	// Mac SDK.
	LatestMacPath string `protobuf:"bytes,4,opt,name=latest_mac_path,json=latestMacPath,proto3" json:"latest_mac_path,omitempty"`
	// tarball_linux_path_tmpl is a template for the GCS path of the Linux SDK,
	// with the version ID to be inserted later.
	TarballLinuxPathTmpl string `protobuf:"bytes,5,opt,name=tarball_linux_path_tmpl,json=tarballLinuxPathTmpl,proto3" json:"tarball_linux_path_tmpl,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *FuchsiaSDKChildConfig) Reset() {
	*x = FuchsiaSDKChildConfig{}
	mi := &file_config_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FuchsiaSDKChildConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FuchsiaSDKChildConfig) ProtoMessage() {}

func (x *FuchsiaSDKChildConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FuchsiaSDKChildConfig.ProtoReflect.Descriptor instead.
func (*FuchsiaSDKChildConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{25}
}

func (x *FuchsiaSDKChildConfig) GetIncludeMacSdk() bool {
	if x != nil {
		return x.IncludeMacSdk
	}
	return false
}

func (x *FuchsiaSDKChildConfig) GetGcsBucket() string {
	if x != nil {
		return x.GcsBucket
	}
	return ""
}

func (x *FuchsiaSDKChildConfig) GetLatestLinuxPath() string {
	if x != nil {
		return x.LatestLinuxPath
	}
	return ""
}

func (x *FuchsiaSDKChildConfig) GetLatestMacPath() string {
	if x != nil {
		return x.LatestMacPath
	}
	return ""
}

func (x *FuchsiaSDKChildConfig) GetTarballLinuxPathTmpl() string {
	if x != nil {
		return x.TarballLinuxPathTmpl
	}
	return ""
}

// SemVerGCSChildConfig provides configuration for a Child in GCS which uses
// semantic versioning.
type SemVerGCSChildConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Gcs   *GCSChildConfig        `protobuf:"bytes,1,opt,name=gcs,proto3" json:"gcs,omitempty"`
	// short_rev_regex is a regular expression string which indicates what part
	// of the revision ID string should be used as the shortened ID for display.
	// If not specified, the full ID string is used.
	ShortRevRegex string `protobuf:"bytes,2,opt,name=short_rev_regex,json=shortRevRegex,proto3" json:"short_rev_regex,omitempty"`
	// version_regex is a regular expression string containing one or more
	// integer capture groups. The integers matched by the capture groups are
	// compared, in order, when comparing two revisions.
	VersionRegex  string `protobuf:"bytes,3,opt,name=version_regex,json=versionRegex,proto3" json:"version_regex,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SemVerGCSChildConfig) Reset() {
	*x = SemVerGCSChildConfig{}
	mi := &file_config_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SemVerGCSChildConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SemVerGCSChildConfig) ProtoMessage() {}

func (x *SemVerGCSChildConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SemVerGCSChildConfig.ProtoReflect.Descriptor instead.
func (*SemVerGCSChildConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{26}
}

func (x *SemVerGCSChildConfig) GetGcs() *GCSChildConfig {
	if x != nil {
		return x.Gcs
	}
	return nil
}

func (x *SemVerGCSChildConfig) GetShortRevRegex() string {
	if x != nil {
		return x.ShortRevRegex
	}
	return ""
}

func (x *SemVerGCSChildConfig) GetVersionRegex() string {
	if x != nil {
		return x.VersionRegex
	}
	return ""
}

// GCSChildConfig provides configuration for a Child in GCS.
type GCSChildConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// gcs_bucket used for finding Child revisions.
	GcsBucket string `protobuf:"bytes,1,opt,name=gcs_bucket,json=gcsBucket,proto3" json:"gcs_bucket,omitempty"`
	// gcs_path within the bucket which contains child revisions.
	GcsPath string `protobuf:"bytes,2,opt,name=gcs_path,json=gcsPath,proto3" json:"gcs_path,omitempty"`
	// revision_id_regex is used to extract the revision ID from a full GCS file
	// path. If not provided, the base name of the file is used.
	RevisionIdRegex string `protobuf:"bytes,3,opt,name=revision_id_regex,json=revisionIdRegex,proto3" json:"revision_id_regex,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GCSChildConfig) Reset() {
	*x = GCSChildConfig{}
	mi := &file_config_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GCSChildConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GCSChildConfig) ProtoMessage() {}

func (x *GCSChildConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GCSChildConfig.ProtoReflect.Descriptor instead.
func (*GCSChildConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{27}
}

func (x *GCSChildConfig) GetGcsBucket() string {
	if x != nil {
		return x.GcsBucket
	}
	return ""
}

func (x *GCSChildConfig) GetGcsPath() string {
	if x != nil {
		return x.GcsPath
	}
	return ""
}

func (x *GCSChildConfig) GetRevisionIdRegex() string {
	if x != nil {
		return x.RevisionIdRegex
	}
	return ""
}

// GitCheckoutChildConfig provides configuration for a Child which uses a local
// Git checkout.
type GitCheckoutChildConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GitCheckout   *GitCheckoutConfig     `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GitCheckoutChildConfig) Reset() {
	*x = GitCheckoutChildConfig{}
	mi := &file_config_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitCheckoutChildConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitCheckoutChildConfig) ProtoMessage() {}

func (x *GitCheckoutChildConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitCheckoutChildConfig.ProtoReflect.Descriptor instead.
func (*GitCheckoutChildConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{28}
}

func (x *GitCheckoutChildConfig) GetGitCheckout() *GitCheckoutConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

// GitCheckoutGitHubChildConfig provides configuration for a Child which uses a
// local checkout of a GitHub repo.
type GitCheckoutGitHubChildConfig struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	GitCheckout   *GitCheckoutChildConfig `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout,proto3" json:"git_checkout,omitempty"`
	RepoOwner     string                  `protobuf:"bytes,2,opt,name=repo_owner,json=repoOwner,proto3" json:"repo_owner,omitempty"`
	RepoName      string                  `protobuf:"bytes,3,opt,name=repo_name,json=repoName,proto3" json:"repo_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GitCheckoutGitHubChildConfig) Reset() {
	*x = GitCheckoutGitHubChildConfig{}
	mi := &file_config_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitCheckoutGitHubChildConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitCheckoutGitHubChildConfig) ProtoMessage() {}

func (x *GitCheckoutGitHubChildConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitCheckoutGitHubChildConfig.ProtoReflect.Descriptor instead.
func (*GitCheckoutGitHubChildConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{29}
}

func (x *GitCheckoutGitHubChildConfig) GetGitCheckout() *GitCheckoutChildConfig {
	if x != nil {
		return x.GitCheckout
	}
	return nil
}

func (x *GitCheckoutGitHubChildConfig) GetRepoOwner() string {
	if x != nil {
		return x.RepoOwner
	}
	return ""
}

func (x *GitCheckoutGitHubChildConfig) GetRepoName() string {
	if x != nil {
		return x.RepoName
	}
	return ""
}

// GitilesChildConfig provides configuration for a Child which uses Gitiles.
type GitilesChildConfig struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Gitiles *GitilesConfig         `protobuf:"bytes,1,opt,name=gitiles,proto3" json:"gitiles,omitempty"`
	// path indicates an optional single path of the repo to watch for changes;
	// all commits which do not change this path are ignored.  Note that this
	// may produce strange results if the Git history for the path is not
	// linear.
	Path          string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GitilesChildConfig) Reset() {
	*x = GitilesChildConfig{}
	mi := &file_config_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitilesChildConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitilesChildConfig) ProtoMessage() {}

func (x *GitilesChildConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitilesChildConfig.ProtoReflect.Descriptor instead.
func (*GitilesChildConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{30}
}

func (x *GitilesChildConfig) GetGitiles() *GitilesConfig {
	if x != nil {
		return x.Gitiles
	}
	return nil
}

func (x *GitilesChildConfig) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

// DockerChildConfig provides configuration for a Child which uses Docker.
type DockerChildConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// registry which stores the Docker image, eg. "gcr.io".
	Registry string `protobuf:"bytes,1,opt,name=registry,proto3" json:"registry,omitempty"`
	// repository of the image, eg. "skia-public/autoroll-be".
	Repository string `protobuf:"bytes,2,opt,name=repository,proto3" json:"repository,omitempty"`
	// tag of the image to track, eg. "latest".
	Tag           string `protobuf:"bytes,3,opt,name=tag,proto3" json:"tag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DockerChildConfig) Reset() {
	*x = DockerChildConfig{}
	mi := &file_config_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DockerChildConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DockerChildConfig) ProtoMessage() {}

func (x *DockerChildConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DockerChildConfig.ProtoReflect.Descriptor instead.
func (*DockerChildConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{31}
}

func (x *DockerChildConfig) GetRegistry() string {
	if x != nil {
		return x.Registry
	}
	return ""
}

func (x *DockerChildConfig) GetRepository() string {
	if x != nil {
		return x.Repository
	}
	return ""
}

func (x *DockerChildConfig) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

// NotifierConfig provides configuration for a notification system.
type NotifierConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// log_level allows all messages at and above the given severity to be
	// sent. Mutually exclusive with msg_type.
	LogLevel NotifierConfig_LogLevel `protobuf:"varint,1,opt,name=log_level,json=logLevel,proto3,enum=autoroll.config.NotifierConfig_LogLevel" json:"log_level,omitempty"`
	// msg_type limits the notifier to only send messages of the given
	// types. Mutually exclusive with log_level.
	MsgType []NotifierConfig_MsgType `protobuf:"varint,2,rep,packed,name=msg_type,json=msgType,proto3,enum=autoroll.config.NotifierConfig_MsgType" json:"msg_type,omitempty"`
	// config provides configuration for the specific type of notifier.
	//
	// Types that are valid to be assigned to Config:
	//
	//	*NotifierConfig_Email
	//	*NotifierConfig_Chat
	//	*NotifierConfig_Monorail
	//	*NotifierConfig_Pubsub
	Config isNotifierConfig_Config `protobuf_oneof:"config"`
	// subject indicates a subject line which overrides the default subject line
	// for every notification message, if provided.
	Subject       string `protobuf:"bytes,7,opt,name=subject,proto3" json:"subject,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NotifierConfig) Reset() {
	*x = NotifierConfig{}
	mi := &file_config_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NotifierConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NotifierConfig) ProtoMessage() {}

func (x *NotifierConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NotifierConfig.ProtoReflect.Descriptor instead.
func (*NotifierConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{32}
}

func (x *NotifierConfig) GetLogLevel() NotifierConfig_LogLevel {
	if x != nil {
		return x.LogLevel
	}
	return NotifierConfig_SILENT
}

func (x *NotifierConfig) GetMsgType() []NotifierConfig_MsgType {
	if x != nil {
		return x.MsgType
	}
	return nil
}

func (x *NotifierConfig) GetConfig() isNotifierConfig_Config {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *NotifierConfig) GetEmail() *EmailNotifierConfig {
	if x != nil {
		if x, ok := x.Config.(*NotifierConfig_Email); ok {
			return x.Email
		}
	}
	return nil
}

func (x *NotifierConfig) GetChat() *ChatNotifierConfig {
	if x != nil {
		if x, ok := x.Config.(*NotifierConfig_Chat); ok {
			return x.Chat
		}
	}
	return nil
}

func (x *NotifierConfig) GetMonorail() *MonorailNotifierConfig {
	if x != nil {
		if x, ok := x.Config.(*NotifierConfig_Monorail); ok {
			return x.Monorail
		}
	}
	return nil
}

func (x *NotifierConfig) GetPubsub() *PubSubNotifierConfig {
	if x != nil {
		if x, ok := x.Config.(*NotifierConfig_Pubsub); ok {
			return x.Pubsub
		}
	}
	return nil
}

func (x *NotifierConfig) GetSubject() string {
	if x != nil {
		return x.Subject
	}
	return ""
}

type isNotifierConfig_Config interface {
	isNotifierConfig_Config()
}

type NotifierConfig_Email struct {
	Email *EmailNotifierConfig `protobuf:"bytes,3,opt,name=email,proto3,oneof"`
}

type NotifierConfig_Chat struct {
	Chat *ChatNotifierConfig `protobuf:"bytes,4,opt,name=chat,proto3,oneof"`
}

type NotifierConfig_Monorail struct {
	Monorail *MonorailNotifierConfig `protobuf:"bytes,5,opt,name=monorail,proto3,oneof"`
}

type NotifierConfig_Pubsub struct {
	Pubsub *PubSubNotifierConfig `protobuf:"bytes,6,opt,name=pubsub,proto3,oneof"`
}

func (*NotifierConfig_Email) isNotifierConfig_Config() {}

func (*NotifierConfig_Chat) isNotifierConfig_Config() {}

func (*NotifierConfig_Monorail) isNotifierConfig_Config() {}

func (*NotifierConfig_Pubsub) isNotifierConfig_Config() {}

// EmailNotifierConfig provides configuration for email notifications.
type EmailNotifierConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// emails are the email addresses which should receive notifications.
	Emails        []string `protobuf:"bytes,1,rep,name=emails,proto3" json:"emails,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmailNotifierConfig) Reset() {
	*x = EmailNotifierConfig{}
	mi := &file_config_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmailNotifierConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmailNotifierConfig) ProtoMessage() {}

func (x *EmailNotifierConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmailNotifierConfig.ProtoReflect.Descriptor instead.
func (*EmailNotifierConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{33}
}

func (x *EmailNotifierConfig) GetEmails() []string {
	if x != nil {
		return x.Emails
	}
	return nil
}

// ChatNotifierConfig provides configuration for Google Chat notifications.
type ChatNotifierConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// room_id in which to post messages.
	RoomId        string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatNotifierConfig) Reset() {
	*x = ChatNotifierConfig{}
	mi := &file_config_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatNotifierConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatNotifierConfig) ProtoMessage() {}

func (x *ChatNotifierConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatNotifierConfig.ProtoReflect.Descriptor instead.
func (*ChatNotifierConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{34}
}

func (x *ChatNotifierConfig) GetRoomId() string {
	if x != nil {
		return x.RoomId
	}
	return ""
}

// MonorailNotifierConfig provides configuration for bug-filing "notifications"
// using Monorail.
type MonorailNotifierConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// project name under which to file bugs. Required.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// owner of bugs filed in Monorail. Required.
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// cc these email addresses on bugs filed in Monorail.
	Cc []string `protobuf:"bytes,3,rep,name=cc,proto3" json:"cc,omitempty"`
	// components to apply to bugs filed in Monorail.
	Components []string `protobuf:"bytes,4,rep,name=components,proto3" json:"components,omitempty"`
	// labels to apply to bugs filed in Monorail.
	Labels        []string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MonorailNotifierConfig) Reset() {
	*x = MonorailNotifierConfig{}
	mi := &file_config_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MonorailNotifierConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MonorailNotifierConfig) ProtoMessage() {}

func (x *MonorailNotifierConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MonorailNotifierConfig.ProtoReflect.Descriptor instead.
func (*MonorailNotifierConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{35}
}

func (x *MonorailNotifierConfig) GetProject() string {
	if x != nil {
		return x.Project
	}
	return ""
}

func (x *MonorailNotifierConfig) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MonorailNotifierConfig) GetCc() []string {
	if x != nil {
		return x.Cc
	}
	return nil
}

func (x *MonorailNotifierConfig) GetComponents() []string {
	if x != nil {
		return x.Components
	}
	return nil
}

func (x *MonorailNotifierConfig) GetLabels() []string {
	if x != nil {
		return x.Labels
	}
	return nil
}

// PubSubNotifierConfig provides configuration for PubSub notifications.
type PubSubNotifierConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// topic under which to publish PubSub messages.
	Topic         string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubSubNotifierConfig) Reset() {
	*x = PubSubNotifierConfig{}
	mi := &file_config_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubNotifierConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubNotifierConfig) ProtoMessage() {}

func (x *PubSubNotifierConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubNotifierConfig.ProtoReflect.Descriptor instead.
func (*PubSubNotifierConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{36}
}

func (x *PubSubNotifierConfig) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

// ThrottleConfig provides configuration for throttling.
type ThrottleConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// attempt_count indicates the number of failed attempts after which to
	// begin throttling.
	AttemptCount int32 `protobuf:"varint,1,opt,name=attempt_count,json=attemptCount,proto3" json:"attempt_count,omitempty"`
	// time_window during which, if the number of failed attempts exceeds the
	// specified attempt_count, throttling is enabled.
	TimeWindow    string `protobuf:"bytes,2,opt,name=time_window,json=timeWindow,proto3" json:"time_window,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ThrottleConfig) Reset() {
	*x = ThrottleConfig{}
	mi := &file_config_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ThrottleConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThrottleConfig) ProtoMessage() {}

func (x *ThrottleConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThrottleConfig.ProtoReflect.Descriptor instead.
func (*ThrottleConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{37}
}

func (x *ThrottleConfig) GetAttemptCount() int32 {
	if x != nil {
		return x.AttemptCount
	}
	return 0
}

func (x *ThrottleConfig) GetTimeWindow() string {
	if x != nil {
		return x.TimeWindow
	}
	return ""
}

// TransitiveDepConfig provides configuration for a dependency referenced by
// both the parent and child, to be updated in the parent to match the revision
// depended on by the child at the revision being rolled.
type TransitiveDepConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// child dependency information.
	Child *VersionFileConfig `protobuf:"bytes,1,opt,name=child,proto3" json:"child,omitempty"`
	// parent dependency information.
	Parent *VersionFileConfig `protobuf:"bytes,2,opt,name=parent,proto3" json:"parent,omitempty"`
	// log_url_tmpl is a template for constructing a URL which displays the log
	// between two revisions.
	LogUrlTmpl    string `protobuf:"bytes,3,opt,name=log_url_tmpl,json=logUrlTmpl,proto3" json:"log_url_tmpl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransitiveDepConfig) Reset() {
	*x = TransitiveDepConfig{}
	mi := &file_config_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransitiveDepConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransitiveDepConfig) ProtoMessage() {}

func (x *TransitiveDepConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransitiveDepConfig.ProtoReflect.Descriptor instead.
func (*TransitiveDepConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{38}
}

func (x *TransitiveDepConfig) GetChild() *VersionFileConfig {
	if x != nil {
		return x.Child
	}
	return nil
}

func (x *TransitiveDepConfig) GetParent() *VersionFileConfig {
	if x != nil {
		return x.Parent
	}
	return nil
}

func (x *TransitiveDepConfig) GetLogUrlTmpl() string {
	if x != nil {
		return x.LogUrlTmpl
	}
	return ""
}

// VersionFileConfig provides configuration for a dependency whose version is
// pinned within a particular file or files.
type VersionFileConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id of the dependency to be rolled, eg. a repo URL.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// file in which the dependency is pinned. May be specified more than once,
	// in which case the first file is considered to be the source of truth,
	// but the others are updated when a roll is created.
	File          []*VersionFileConfig_File `protobuf:"bytes,2,rep,name=file,proto3" json:"file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersionFileConfig) Reset() {
	*x = VersionFileConfig{}
	mi := &file_config_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersionFileConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionFileConfig) ProtoMessage() {}

func (x *VersionFileConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionFileConfig.ProtoReflect.Descriptor instead.
func (*VersionFileConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{39}
}

func (x *VersionFileConfig) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *VersionFileConfig) GetFile() []*VersionFileConfig_File {
	if x != nil {
		return x.File
	}
	return nil
}

// VersionFileConfig_File specifies details about the file which pins a
// dependency.
type VersionFileConfig_File struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// path within the repo of the file which pins the dependency. The name of
	// the file dictates how we read and write the revision pin:
	//
	//   - If `regex` is set, the name of this file is ignored.
	//
	//   - `DEPS`: we parse the file as a DEPS file using a Python parser.
	//
	//   - `*.pyl`: we assume the file contains a Python literal composed of
	//     dictionaries and lists. In this case, the `id` field must be a dot-
	//     separated path from the root of the object to the field which
	//     specifies the revision, where each element is either a dictionary key
	//     or a selector which matches a key+value of a given list element. For
	//     example, the id `key1.key2.id=my-dependency-id.revision` would
	//     traverse the following literal to find the revision ID:
	//
	//     {
	//     "key1": {
	//     "key2": [
	//     {
	//     "id": "my-dependency-id",
	//     "revision": "12345",
	//     },
	//     ],
	//     },
	//     }
	//
	//   - Otherwise, we assume that the file's sole contents are the revision
	//     ID and we read or write the entirety of the file.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// regex which is used to extract the existing revision of the dependency
	// and to update the pin to the new revision. Optional.
	Regex string `protobuf:"bytes,2,opt,name=regex,proto3" json:"regex,omitempty"`
	// regex_replace_all indicates that, when regex is non-empty, we should
	// replace all matching occurrences of the regex in the file when updating
	// it, as opposed to only the first.
	RegexReplaceAll bool `protobuf:"varint,3,opt,name=regex_replace_all,json=regexReplaceAll,proto3" json:"regex_replace_all,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *VersionFileConfig_File) Reset() {
	*x = VersionFileConfig_File{}
	mi := &file_config_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersionFileConfig_File) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionFileConfig_File) ProtoMessage() {}

func (x *VersionFileConfig_File) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionFileConfig_File.ProtoReflect.Descriptor instead.
func (*VersionFileConfig_File) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{40}
}

func (x *VersionFileConfig_File) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *VersionFileConfig_File) GetRegex() string {
	if x != nil {
		return x.Regex
	}
	return ""
}

func (x *VersionFileConfig_File) GetRegexReplaceAll() bool {
	if x != nil {
		return x.RegexReplaceAll
	}
	return false
}

// DependencyConfig provides configuration for a dependency whose version is
// pinned in a file and which may have transitive dependencies.
type DependencyConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// primary dependency.
	Primary *VersionFileConfig `protobuf:"bytes,1,opt,name=primary,proto3" json:"primary,omitempty"`
	// transitive dependencies.
	Transitive []*TransitiveDepConfig `protobuf:"bytes,2,rep,name=transitive,proto3" json:"transitive,omitempty"`
	// find_and_replace lists additional files in which all instances of the
	// previous primary revision ID should be replaced with the new primary
	// revision ID.
	FindAndReplace []string `protobuf:"bytes,3,rep,name=find_and_replace,json=findAndReplace,proto3" json:"find_and_replace,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DependencyConfig) Reset() {
	*x = DependencyConfig{}
	mi := &file_config_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DependencyConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DependencyConfig) ProtoMessage() {}

func (x *DependencyConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DependencyConfig.ProtoReflect.Descriptor instead.
func (*DependencyConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{41}
}

func (x *DependencyConfig) GetPrimary() *VersionFileConfig {
	if x != nil {
		return x.Primary
	}
	return nil
}

func (x *DependencyConfig) GetTransitive() []*TransitiveDepConfig {
	if x != nil {
		return x.Transitive
	}
	return nil
}

func (x *DependencyConfig) GetFindAndReplace() []string {
	if x != nil {
		return x.FindAndReplace
	}
	return nil
}

// GitCheckoutConfig provides configuration for a Git checkout.
type GitCheckoutConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// branch to track.
	Branch string `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	// repo_url to check out.
	RepoUrl string `protobuf:"bytes,2,opt,name=repo_url,json=repoUrl,proto3" json:"repo_url,omitempty"`
	// rev_link_tmpl is an optional template used for generating links to
	// revisions. If not specified, revisions generated by the checkout will not
	// have an associated URL.
	RevLinkTmpl string `protobuf:"bytes,3,opt,name=rev_link_tmpl,json=revLinkTmpl,proto3" json:"rev_link_tmpl,omitempty"`
	// dependencies is an optional specification of dependencies to track.
	// Revisions generated by the checkout will contain the pinned versions of
	// these dependencies.
	Dependencies []*VersionFileConfig `protobuf:"bytes,4,rep,name=dependencies,proto3" json:"dependencies,omitempty"`
	// default_bug_project indicates the Monorail project used when no project
	// is specified in "Bug: 123" lines in commit messages.
	DefaultBugProject string `protobuf:"bytes,5,opt,name=default_bug_project,json=defaultBugProject,proto3" json:"default_bug_project,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GitCheckoutConfig) Reset() {
	*x = GitCheckoutConfig{}
	mi := &file_config_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitCheckoutConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitCheckoutConfig) ProtoMessage() {}

func (x *GitCheckoutConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitCheckoutConfig.ProtoReflect.Descriptor instead.
func (*GitCheckoutConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{42}
}

func (x *GitCheckoutConfig) GetBranch() string {
	if x != nil {
		return x.Branch
	}
	return ""
}

func (x *GitCheckoutConfig) GetRepoUrl() string {
	if x != nil {
		return x.RepoUrl
	}
	return ""
}

func (x *GitCheckoutConfig) GetRevLinkTmpl() string {
	if x != nil {
		return x.RevLinkTmpl
	}
	return ""
}

func (x *GitCheckoutConfig) GetDependencies() []*VersionFileConfig {
	if x != nil {
		return x.Dependencies
	}
	return nil
}

func (x *GitCheckoutConfig) GetDefaultBugProject() string {
	if x != nil {
		return x.DefaultBugProject
	}
	return ""
}

// BuildbucketRevisionFilterConfig provides configuration for a revision filter
// which uses Buildbucket.
type BuildbucketRevisionFilterConfig struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Project            string                 `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	Bucket             string                 `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	BuildsetCommitTmpl string                 `protobuf:"bytes,3,opt,name=buildset_commit_tmpl,json=buildsetCommitTmpl,proto3" json:"buildset_commit_tmpl,omitempty"`
	Builder            []string               `protobuf:"bytes,4,rep,name=builder,proto3" json:"builder,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *BuildbucketRevisionFilterConfig) Reset() {
	*x = BuildbucketRevisionFilterConfig{}
	mi := &file_config_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildbucketRevisionFilterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildbucketRevisionFilterConfig) ProtoMessage() {}

func (x *BuildbucketRevisionFilterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildbucketRevisionFilterConfig.ProtoReflect.Descriptor instead.
func (*BuildbucketRevisionFilterConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{43}
}

func (x *BuildbucketRevisionFilterConfig) GetProject() string {
	if x != nil {
		return x.Project
	}
	return ""
}

func (x *BuildbucketRevisionFilterConfig) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *BuildbucketRevisionFilterConfig) GetBuildsetCommitTmpl() string {
	if x != nil {
		return x.BuildsetCommitTmpl
	}
	return ""
}

func (x *BuildbucketRevisionFilterConfig) GetBuilder() []string {
	if x != nil {
		return x.Builder
	}
	return nil
}

// CIPDRevisionFilterConfig provides configuration for a revision filter
// which filters out revisions which don't exist on all of the configured
// packages and platforms.
type CIPDRevisionFilterConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Package       []string               `protobuf:"bytes,1,rep,name=package,proto3" json:"package,omitempty"`
	Platform      []string               `protobuf:"bytes,2,rep,name=platform,proto3" json:"platform,omitempty"`
	TagKey        string                 `protobuf:"bytes,3,opt,name=tag_key,json=tagKey,proto3" json:"tag_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CIPDRevisionFilterConfig) Reset() {
	*x = CIPDRevisionFilterConfig{}
	mi := &file_config_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CIPDRevisionFilterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CIPDRevisionFilterConfig) ProtoMessage() {}

func (x *CIPDRevisionFilterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CIPDRevisionFilterConfig.ProtoReflect.Descriptor instead.
func (*CIPDRevisionFilterConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{44}
}

func (x *CIPDRevisionFilterConfig) GetPackage() []string {
	if x != nil {
		return x.Package
	}
	return nil
}

func (x *CIPDRevisionFilterConfig) GetPlatform() []string {
	if x != nil {
		return x.Platform
	}
	return nil
}

func (x *CIPDRevisionFilterConfig) GetTagKey() string {
	if x != nil {
		return x.TagKey
	}
	return ""
}

// ValidHttpRevisionFilterConfig provides configuration for a
// revision filter which obtains a single valid revision from a file which is
// retrieved via HTTP.
type ValidHttpRevisionFilterConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// URL of the file containing the valid revision.
	FileUrl string `protobuf:"bytes,1,opt,name=file_url,json=fileUrl,proto3" json:"file_url,omitempty"`
	// Optional regular expression used to extract the valid revision from the
	// file after retrieval. If not provided, we assume that the entire contents
	// of the file comprise the revision ID.
	Regex         string `protobuf:"bytes,2,opt,name=regex,proto3" json:"regex,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidHttpRevisionFilterConfig) Reset() {
	*x = ValidHttpRevisionFilterConfig{}
	mi := &file_config_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidHttpRevisionFilterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidHttpRevisionFilterConfig) ProtoMessage() {}

func (x *ValidHttpRevisionFilterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidHttpRevisionFilterConfig.ProtoReflect.Descriptor instead.
func (*ValidHttpRevisionFilterConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{45}
}

func (x *ValidHttpRevisionFilterConfig) GetFileUrl() string {
	if x != nil {
		return x.FileUrl
	}
	return ""
}

func (x *ValidHttpRevisionFilterConfig) GetRegex() string {
	if x != nil {
		return x.Regex
	}
	return ""
}

// PreUploadConfig describes additional steps to run after updating the
// dependency but before uploading the CL, on rollers which use a local
// checkout.
type PreUploadConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CIPD packages needed by the command(s).
	CipdPackage []*PreUploadCIPDPackageConfig `protobuf:"bytes,1,rep,name=cipd_package,json=cipdPackage,proto3" json:"cipd_package,omitempty"`
	// Command(s) to run.
	Command       []*PreUploadCommandConfig `protobuf:"bytes,2,rep,name=command,proto3" json:"command,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreUploadConfig) Reset() {
	*x = PreUploadConfig{}
	mi := &file_config_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreUploadConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreUploadConfig) ProtoMessage() {}

func (x *PreUploadConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreUploadConfig.ProtoReflect.Descriptor instead.
func (*PreUploadConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{46}
}

func (x *PreUploadConfig) GetCipdPackage() []*PreUploadCIPDPackageConfig {
	if x != nil {
		return x.CipdPackage
	}
	return nil
}

func (x *PreUploadConfig) GetCommand() []*PreUploadCommandConfig {
	if x != nil {
		return x.Command
	}
	return nil
}

// PreUploadCommandConfig describes a command to run.
type PreUploadCommandConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Command to run.
	Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	// Working directory in which to run the command.
	Cwd string `protobuf:"bytes,2,opt,name=cwd,proto3" json:"cwd,omitempty"`
	// Environment variables needed by the command, in "KEY=VALUE" format.
	Env []string `protobuf:"bytes,3,rep,name=env,proto3" json:"env,omitempty"`
	// If true, log the error returned by the command but don't error out.
	IgnoreFailure bool `protobuf:"varint,4,opt,name=ignore_failure,json=ignoreFailure,proto3" json:"ignore_failure,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreUploadCommandConfig) Reset() {
	*x = PreUploadCommandConfig{}
	mi := &file_config_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreUploadCommandConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreUploadCommandConfig) ProtoMessage() {}

func (x *PreUploadCommandConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreUploadCommandConfig.ProtoReflect.Descriptor instead.
func (*PreUploadCommandConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{47}
}

func (x *PreUploadCommandConfig) GetCommand() string {
	if x != nil {
		return x.Command
	}
	return ""
}

func (x *PreUploadCommandConfig) GetCwd() string {
	if x != nil {
		return x.Cwd
	}
	return ""
}

func (x *PreUploadCommandConfig) GetEnv() []string {
	if x != nil {
		return x.Env
	}
	return nil
}

func (x *PreUploadCommandConfig) GetIgnoreFailure() bool {
	if x != nil {
		return x.IgnoreFailure
	}
	return false
}

// CIPDPackageConfig describes a CIPD package.
type PreUploadCIPDPackageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Full CIPD package name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Relative path within the root dir to install the package.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Version of the package.
	Version       string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreUploadCIPDPackageConfig) Reset() {
	*x = PreUploadCIPDPackageConfig{}
	mi := &file_config_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreUploadCIPDPackageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreUploadCIPDPackageConfig) ProtoMessage() {}

func (x *PreUploadCIPDPackageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreUploadCIPDPackageConfig.ProtoReflect.Descriptor instead.
func (*PreUploadCIPDPackageConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{48}
}

func (x *PreUploadCIPDPackageConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PreUploadCIPDPackageConfig) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *PreUploadCIPDPackageConfig) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

// Configs provides configuration for multiple autorollers.
type Configs struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        []*Config              `protobuf:"bytes,1,rep,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Configs) Reset() {
	*x = Configs{}
	mi := &file_config_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Configs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Configs) ProtoMessage() {}

func (x *Configs) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Configs.ProtoReflect.Descriptor instead.
func (*Configs) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{49}
}

func (x *Configs) GetConfig() []*Config {
	if x != nil {
		return x.Config
	}
	return nil
}

// ProjectMetadataFileConfig provides configuration for METADATA files in
// the Android repo.
type AndroidRepoManagerConfig_ProjectMetadataFileConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// file_path of the project metadata file within the repo.
	FilePath string `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// name of the project.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// description of the project.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// home_page of the project.
	HomePage string `protobuf:"bytes,4,opt,name=home_page,json=homePage,proto3" json:"home_page,omitempty"`
	// git_url of the project.
	GitUrl string `protobuf:"bytes,5,opt,name=git_url,json=gitUrl,proto3" json:"git_url,omitempty"`
	// license_type of the project.
	LicenseType   string `protobuf:"bytes,6,opt,name=license_type,json=licenseType,proto3" json:"license_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) Reset() {
	*x = AndroidRepoManagerConfig_ProjectMetadataFileConfig{}
	mi := &file_config_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AndroidRepoManagerConfig_ProjectMetadataFileConfig) ProtoMessage() {}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AndroidRepoManagerConfig_ProjectMetadataFileConfig.ProtoReflect.Descriptor instead.
func (*AndroidRepoManagerConfig_ProjectMetadataFileConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{6, 0}
}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) GetHomePage() string {
	if x != nil {
		return x.HomePage
	}
	return ""
}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) GetGitUrl() string {
	if x != nil {
		return x.GitUrl
	}
	return ""
}

func (x *AndroidRepoManagerConfig_ProjectMetadataFileConfig) GetLicenseType() string {
	if x != nil {
		return x.LicenseType
	}
	return ""
}

type CommandRepoManagerConfig_CommandConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// command to run. If this is the command used to update the revision of
	// the Child, this should be a text template which uses SetPinnedRevVars
	// to get the from- and to-revisions.
	Command []string `protobuf:"bytes,1,rep,name=command,proto3" json:"command,omitempty"`
	// dir is the relative path within the Git checkout to run the command.
	Dir string `protobuf:"bytes,2,opt,name=dir,proto3" json:"dir,omitempty"`
	// env are environment variables to supply to the command, in KEY=VALUE
	// format.
	Env           []string `protobuf:"bytes,3,rep,name=env,proto3" json:"env,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommandRepoManagerConfig_CommandConfig) Reset() {
	*x = CommandRepoManagerConfig_CommandConfig{}
	mi := &file_config_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommandRepoManagerConfig_CommandConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommandRepoManagerConfig_CommandConfig) ProtoMessage() {}

func (x *CommandRepoManagerConfig_CommandConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommandRepoManagerConfig_CommandConfig.ProtoReflect.Descriptor instead.
func (*CommandRepoManagerConfig_CommandConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{7, 0}
}

func (x *CommandRepoManagerConfig_CommandConfig) GetCommand() []string {
	if x != nil {
		return x.Command
	}
	return nil
}

func (x *CommandRepoManagerConfig_CommandConfig) GetDir() string {
	if x != nil {
		return x.Dir
	}
	return ""
}

func (x *CommandRepoManagerConfig_CommandConfig) GetEnv() []string {
	if x != nil {
		return x.Env
	}
	return nil
}

type CopyParentConfig_CopyEntry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// src_rel_path is the relative path within the Child.
	SrcRelPath string `protobuf:"bytes,1,opt,name=src_rel_path,json=srcRelPath,proto3" json:"src_rel_path,omitempty"`
	// dst_rel_path is the relative path within the Parent.
	DstRelPath    string `protobuf:"bytes,2,opt,name=dst_rel_path,json=dstRelPath,proto3" json:"dst_rel_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CopyParentConfig_CopyEntry) Reset() {
	*x = CopyParentConfig_CopyEntry{}
	mi := &file_config_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CopyParentConfig_CopyEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyParentConfig_CopyEntry) ProtoMessage() {}

func (x *CopyParentConfig_CopyEntry) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyParentConfig_CopyEntry.ProtoReflect.Descriptor instead.
func (*CopyParentConfig_CopyEntry) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{11, 0}
}

func (x *CopyParentConfig_CopyEntry) GetSrcRelPath() string {
	if x != nil {
		return x.SrcRelPath
	}
	return ""
}

func (x *CopyParentConfig_CopyEntry) GetDstRelPath() string {
	if x != nil {
		return x.DstRelPath
	}
	return ""
}

var File_config_proto protoreflect.FileDescriptor

const file_config_proto_rawDesc = "" +
	"\n" +
	"\fconfig.proto\x12\x0fautoroll.config\"\x8f\x0f\n" +
	"\x06Config\x12\x1f\n" +
	"\vroller_name\x18\x01 \x01(\tR\n" +
	"rollerName\x12$\n" +
	"\x0echild_bug_link\x18\x1d \x01(\tR\fchildBugLink\x12,\n" +
	"\x12child_display_name\x18\x02 \x01(\tR\x10childDisplayName\x12&\n" +
	"\x0fparent_bug_link\x18\x1e \x01(\tR\rparentBugLink\x12.\n" +
	"\x13parent_display_name\x18\x03 \x01(\tR\x11parentDisplayName\x12)\n" +
	"\x10parent_waterfall\x18\x04 \x01(\tR\x0fparentWaterfall\x12#\n" +
	"\rowner_primary\x18\x05 \x01(\tR\fownerPrimary\x12'\n" +
	"\x0fowner_secondary\x18\x06 \x01(\tR\x0eownerSecondary\x12\x1a\n" +
	"\bcontacts\x18\a \x03(\tR\bcontacts\x12'\n" +
	"\x0fservice_account\x18\b \x01(\tR\x0eserviceAccount\x12\x1f\n" +
	"\vis_internal\x18\t \x01(\bR\n" +
	"isInternal\x12\x1a\n" +
	"\breviewer\x18\n" +
	" \x03(\tR\breviewer\x12'\n" +
	"\x0freviewer_backup\x18\v \x03(\tR\x0ereviewerBackup\x12#\n" +
	"\rroll_cooldown\x18\f \x01(\tR\frollCooldown\x12(\n" +
	"\x10dry_run_cooldown\x18# \x01(\tR\x0edryRunCooldown\x12\x1f\n" +
	"\vtime_window\x18\r \x01(\tR\n" +
	"timeWindow\x122\n" +
	"\x15supports_manual_rolls\x18\x0e \x01(\bR\x13supportsManualRolls\x12?\n" +
	"\n" +
	"commit_msg\x18\x0f \x01(\v2 .autoroll.config.CommitMsgConfigR\tcommitMsg\x127\n" +
	"\x06gerrit\x18\x10 \x01(\v2\x1d.autoroll.config.GerritConfigH\x00R\x06gerrit\x127\n" +
	"\x06github\x18\x11 \x01(\v2\x1d.autoroll.config.GitHubConfigH\x00R\x06github\x12:\n" +
	"\agoogle3\x18\x12 \x01(\v2\x1e.autoroll.config.Google3ConfigH\x00R\agoogle3\x12A\n" +
	"\n" +
	"kubernetes\x18\x13 \x01(\v2!.autoroll.config.KubernetesConfigR\n" +
	"kubernetes\x12j\n" +
	"\x19parent_child_repo_manager\x18\x14 \x01(\v2-.autoroll.config.ParentChildRepoManagerConfigH\x01R\x16parentChildRepoManager\x12]\n" +
	"\x14android_repo_manager\x18\x15 \x01(\v2).autoroll.config.AndroidRepoManagerConfigH\x01R\x12androidRepoManager\x12]\n" +
	"\x14command_repo_manager\x18\x16 \x01(\v2).autoroll.config.CommandRepoManagerConfigH\x01R\x12commandRepoManager\x12`\n" +
	"\x15freetype_repo_manager\x18\x17 \x01(\v2*.autoroll.config.FreeTypeRepoManagerConfigH\x01R\x13freetypeRepoManager\x12]\n" +
	"\x14google3_repo_manager\x18\x19 \x01(\v2).autoroll.config.Google3RepoManagerConfigH\x01R\x12google3RepoManager\x12=\n" +
	"\tnotifiers\x18\x1a \x03(\v2\x1f.autoroll.config.NotifierConfigR\tnotifiers\x12H\n" +
	"\x0fsafety_throttle\x18\x1b \x01(\v2\x1f.autoroll.config.ThrottleConfigR\x0esafetyThrottle\x12M\n" +
	"\x0ftransitive_deps\x18\x1c \x03(\v2$.autoroll.config.TransitiveDepConfigR\x0etransitiveDeps\x122\n" +
	"\x15use_workload_identity\x18\x1f \x01(\bR\x13useWorkloadIdentity\x126\n" +
	"\vvalid_modes\x18  \x03(\x0e2\x15.autoroll.config.ModeR\n" +
	"validModes\x12/\n" +
	"\x14max_roll_cq_attempts\x18! \x01(\x05R\x11maxRollCqAttempts\x12?\n" +
	"\x1dmax_roll_cls_to_same_revision\x18\" \x01(\x05R\x18maxRollClsToSameRevisionB\r\n" +
	"\vcode_reviewB\x0e\n" +
	"\frepo_manager\"\xca\x04\n" +
	"\x0fCommitMsgConfig\x12\x1f\n" +
	"\vbug_project\x18\x01 \x01(\tR\n" +
	"bugProject\x12+\n" +
	"\x12child_log_url_tmpl\x18\x02 \x01(\tR\x0fchildLogUrlTmpl\x12(\n" +
	"\x10cq_extra_trybots\x18\x03 \x03(\tR\x0ecqExtraTrybots\x126\n" +
	"\x18cq_do_not_cancel_trybots\x18\x04 \x01(\bR\x14cqDoNotCancelTrybots\x12\x1f\n" +
	"\vinclude_log\x18\x05 \x01(\bR\n" +
	"includeLog\x124\n" +
	"\x16include_revision_count\x18\x06 \x01(\bR\x14includeRevisionCount\x12(\n" +
	"\x10include_tbr_line\x18\a \x01(\bR\x0eincludeTbrLine\x12#\n" +
	"\rinclude_tests\x18\b \x01(\bR\fincludeTests\x12#\n" +
	"\rextra_footers\x18\v \x03(\tR\fextraFooters\x12\x1b\n" +
	"\tword_wrap\x18\f \x01(\x05R\bwordWrap\x12C\n" +
	"\bbuilt_in\x18\t \x01(\x0e2(.autoroll.config.CommitMsgConfig.BuiltInR\abuiltIn\x12\x16\n" +
	"\x06custom\x18\n" +
	" \x01(\tR\x06custom\"B\n" +
	"\aBuiltIn\x12\v\n" +
	"\aDEFAULT\x10\x00\x12\v\n" +
	"\aANDROID\x10\x01\x12\x11\n" +
	"\rANDROID_NO_CR\x10\x02\x12\n" +
	"\n" +
	"\x06CANARY\x10\x03\"\xc7\x02\n" +
	"\fGerritConfig\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x18\n" +
	"\aproject\x18\x02 \x01(\tR\aproject\x12<\n" +
	"\x06config\x18\x03 \x01(\x0e2$.autoroll.config.GerritConfig.ConfigR\x06config\"\xcc\x01\n" +
	"\x06Config\x12\v\n" +
	"\aANDROID\x10\x00\x12\t\n" +
	"\x05ANGLE\x10\x01\x12\f\n" +
	"\bCHROMIUM\x10\x02\x12\x12\n" +
	"\x0eCHROMIUM_NO_CQ\x10\x03\x12\x10\n" +
	"\fLIBASSISTANT\x10\x04\x12\x17\n" +
	"\x13CHROMIUM_BOT_COMMIT\x10\x05\x12\x1d\n" +
	"\x19CHROMIUM_BOT_COMMIT_NO_CQ\x10\x06\x12\x11\n" +
	"\rANDROID_NO_CR\x10\a\x12\x17\n" +
	"\x13ANDROID_NO_CR_NO_PR\x10\b\x12\x12\n" +
	"\x0eCHROMIUM_NO_CR\x10\t\"\xbb\x01\n" +
	"\fGitHubConfig\x12\x1d\n" +
	"\n" +
	"repo_owner\x18\x01 \x01(\tR\trepoOwner\x12\x1b\n" +
	"\trepo_name\x18\x02 \x01(\tR\brepoName\x12&\n" +
	"\x0fchecks_wait_for\x18\x03 \x03(\tR\rchecksWaitFor\x12!\n" +
	"\ftoken_secret\x18\x04 \x01(\tR\vtokenSecret\x12$\n" +
	"\x0essh_key_secret\x18\x05 \x01(\tR\fsshKeySecret\"\x0f\n" +
	"\rGoogle3Config\"\xc8\x02\n" +
	"\x10KubernetesConfig\x12\x10\n" +
	"\x03cpu\x18\x01 \x01(\tR\x03cpu\x12\x16\n" +
	"\x06memory\x18\x02 \x01(\tR\x06memory\x12>\n" +
	"\x1breadiness_failure_threshold\x18\x03 \x01(\x05R\x19readinessFailureThreshold\x12E\n" +
	"\x1freadiness_initial_delay_seconds\x18\x04 \x01(\x05R\x1creadinessInitialDelaySeconds\x128\n" +
	"\x18readiness_period_seconds\x18\x05 \x01(\x05R\x16readinessPeriodSeconds\x12\x12\n" +
	"\x04disk\x18\x06 \x01(\tR\x04disk\x12\x14\n" +
	"\x05image\x18\b \x01(\tR\x05image\x12\x1f\n" +
	"\vextra_flags\x18\t \x03(\tR\n" +
	"extraFlags\"\xc1\x06\n" +
	"\x18AndroidRepoManagerConfig\x12$\n" +
	"\x0echild_repo_url\x18\x01 \x01(\tR\fchildRepoUrl\x12!\n" +
	"\fchild_branch\x18\x02 \x01(\tR\vchildBranch\x12\x1d\n" +
	"\n" +
	"child_path\x18\x03 \x01(\tR\tchildPath\x12&\n" +
	"\x0fparent_repo_url\x18\x04 \x01(\tR\rparentRepoUrl\x12#\n" +
	"\rparent_branch\x18\x05 \x01(\tR\fparentBranch\x12-\n" +
	"\x13child_rev_link_tmpl\x18\x06 \x01(\tR\x10childRevLinkTmpl\x12!\n" +
	"\fchild_subdir\x18\a \x01(\tR\vchildSubdir\x12_\n" +
	"\bmetadata\x18\t \x01(\v2C.autoroll.config.AndroidRepoManagerConfig.ProjectMetadataFileConfigR\bmetadata\x12?\n" +
	"\x1cinclude_authors_as_reviewers\x18\n" +
	" \x01(\bR\x19includeAuthorsAsReviewers\x12P\n" +
	"\x13pre_upload_commands\x18\v \x01(\v2 .autoroll.config.PreUploadConfigR\x11preUploadCommands\x120\n" +
	"\x14auto_approver_secret\x18\f \x01(\tR\x12autoApproverSecret\x12.\n" +
	"\x13default_bug_project\x18\r \x01(\tR\x11defaultBugProject\x1a\xc7\x01\n" +
	"\x19ProjectMetadataFileConfig\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x1b\n" +
	"\thome_page\x18\x04 \x01(\tR\bhomePage\x12\x17\n" +
	"\agit_url\x18\x05 \x01(\tR\x06gitUrl\x12!\n" +
	"\flicense_type\x18\x06 \x01(\tR\vlicenseType\"\xef\x03\n" +
	"\x18CommandRepoManagerConfig\x12E\n" +
	"\fgit_checkout\x18\x01 \x01(\v2\".autoroll.config.GitCheckoutConfigR\vgitCheckout\x12&\n" +
	"\x0fshort_rev_regex\x18\x02 \x01(\tR\rshortRevRegex\x12W\n" +
	"\vget_tip_rev\x18\x03 \x01(\v27.autoroll.config.CommandRepoManagerConfig.CommandConfigR\tgetTipRev\x12]\n" +
	"\x0eget_pinned_rev\x18\x04 \x01(\v27.autoroll.config.CommandRepoManagerConfig.CommandConfigR\fgetPinnedRev\x12]\n" +
	"\x0eset_pinned_rev\x18\x05 \x01(\v27.autoroll.config.CommandRepoManagerConfig.CommandConfigR\fsetPinnedRev\x1aM\n" +
	"\rCommandConfig\x12\x18\n" +
	"\acommand\x18\x01 \x03(\tR\acommand\x12\x10\n" +
	"\x03dir\x18\x02 \x01(\tR\x03dir\x12\x10\n" +
	"\x03env\x18\x03 \x03(\tR\x03env\"\x95\x01\n" +
	"\x19FreeTypeRepoManagerConfig\x12=\n" +
	"\x06parent\x18\x01 \x01(\v2%.autoroll.config.FreeTypeParentConfigR\x06parent\x129\n" +
	"\x05child\x18\x02 \x01(\v2#.autoroll.config.GitilesChildConfigR\x05child\"\\\n" +
	"\x18Google3RepoManagerConfig\x12!\n" +
	"\fchild_branch\x18\x01 \x01(\tR\vchildBranch\x12\x1d\n" +
	"\n" +
	"child_repo\x18\x02 \x01(\tR\tchildRepo\"\xe2\f\n" +
	"\x1cParentChildRepoManagerConfig\x12D\n" +
	"\vcopy_parent\x18\x01 \x01(\v2!.autoroll.config.CopyParentConfigH\x00R\n" +
	"copyParent\x12g\n" +
	"\x18deps_local_github_parent\x18\x02 \x01(\v2,.autoroll.config.DEPSLocalGitHubParentConfigH\x00R\x15depsLocalGithubParent\x12g\n" +
	"\x18deps_local_gerrit_parent\x18\x03 \x01(\v2,.autoroll.config.DEPSLocalGerritParentConfigH\x00R\x15depsLocalGerritParent\x12z\n" +
	"\x1fgit_checkout_github_file_parent\x18\x04 \x01(\v22.autoroll.config.GitCheckoutGitHubFileParentConfigH\x00R\x1bgitCheckoutGithubFileParent\x12M\n" +
	"\x0egitiles_parent\x18\x05 \x01(\v2$.autoroll.config.GitilesParentConfigH\x00R\rgitilesParent\x12[\n" +
	"\x14go_mod_gerrit_parent\x18\x0e \x01(\v2(.autoroll.config.GoModGerritParentConfigH\x00R\x11goModGerritParent\x12m\n" +
	"\x1agit_checkout_gerrit_parent\x18\x11 \x01(\v2..autoroll.config.GitCheckoutGerritParentConfigH\x00R\x17gitCheckoutGerritParent\x12A\n" +
	"\n" +
	"cipd_child\x18\x06 \x01(\v2 .autoroll.config.CIPDChildConfigH\x01R\tcipdChild\x12T\n" +
	"\x11fuchsia_sdk_child\x18\a \x01(\v2&.autoroll.config.FuchsiaSDKChildConfigH\x01R\x0ffuchsiaSdkChild\x12W\n" +
	"\x12git_checkout_child\x18\b \x01(\v2'.autoroll.config.GitCheckoutChildConfigH\x01R\x10gitCheckoutChild\x12j\n" +
	"\x19git_checkout_github_child\x18\t \x01(\v2-.autoroll.config.GitCheckoutGitHubChildConfigH\x01R\x16gitCheckoutGithubChild\x12J\n" +
	"\rgitiles_child\x18\n" +
	" \x01(\v2#.autoroll.config.GitilesChildConfigH\x01R\fgitilesChild\x12Q\n" +
	"\x10semver_gcs_child\x18\v \x01(\v2%.autoroll.config.SemVerGCSChildConfigH\x01R\x0esemverGcsChild\x12G\n" +
	"\fdocker_child\x18\x10 \x01(\v2\".autoroll.config.DockerChildConfigH\x01R\vdockerChild\x12p\n" +
	"\x1bbuildbucket_revision_filter\x18\f \x03(\v20.autoroll.config.BuildbucketRevisionFilterConfigR\x19buildbucketRevisionFilter\x12[\n" +
	"\x14cipd_revision_filter\x18\r \x03(\v2).autoroll.config.CIPDRevisionFilterConfigR\x12cipdRevisionFilter\x12k\n" +
	"\x1avalid_http_revision_filter\x18\x0f \x03(\v2..autoroll.config.ValidHttpRevisionFilterConfigR\x17validHttpRevisionFilterB\b\n" +
	"\x06parentB\a\n" +
	"\x05child\"\xe8\x01\n" +
	"\x10CopyParentConfig\x12>\n" +
	"\agitiles\x18\x01 \x01(\v2$.autoroll.config.GitilesParentConfigR\agitiles\x12C\n" +
	"\x06copies\x18\x02 \x03(\v2+.autoroll.config.CopyParentConfig.CopyEntryR\x06copies\x1aO\n" +
	"\tCopyEntry\x12 \n" +
	"\fsrc_rel_path\x18\x01 \x01(\tR\n" +
	"srcRelPath\x12 \n" +
	"\fdst_rel_path\x18\x02 \x01(\tR\n" +
	"dstRelPath\"\xbf\x01\n" +
	"\x1bDEPSLocalGitHubParentConfig\x12E\n" +
	"\n" +
	"deps_local\x18\x01 \x01(\v2&.autoroll.config.DEPSLocalParentConfigR\tdepsLocal\x125\n" +
	"\x06github\x18\x02 \x01(\v2\x1d.autoroll.config.GitHubConfigR\x06github\x12\"\n" +
	"\rfork_repo_url\x18\x03 \x01(\tR\vforkRepoUrl\"\x9b\x01\n" +
	"\x1bDEPSLocalGerritParentConfig\x12E\n" +
	"\n" +
	"deps_local\x18\x01 \x01(\v2&.autoroll.config.DEPSLocalParentConfigR\tdepsLocal\x125\n" +
	"\x06gerrit\x18\x02 \x01(\v2\x1d.autoroll.config.GerritConfigR\x06gerrit\"\x90\x01\n" +
	"\x1dGitCheckoutGitHubParentConfig\x12K\n" +
	"\fgit_checkout\x18\x01 \x01(\v2(.autoroll.config.GitCheckoutParentConfigR\vgitCheckout\x12\"\n" +
	"\rfork_repo_url\x18\x02 \x01(\tR\vforkRepoUrl\"\xbe\x01\n" +
	"\x1dGitCheckoutGerritParentConfig\x12K\n" +
	"\fgit_checkout\x18\x01 \x01(\v2(.autoroll.config.GitCheckoutParentConfigR\vgitCheckout\x12P\n" +
	"\x13pre_upload_commands\x18\x02 \x01(\v2 .autoroll.config.PreUploadConfigR\x11preUploadCommands\"\xc8\x01\n" +
	"!GitCheckoutGitHubFileParentConfig\x12Q\n" +
	"\fgit_checkout\x18\x01 \x01(\v2..autoroll.config.GitCheckoutGitHubParentConfigR\vgitCheckout\x12P\n" +
	"\x13pre_upload_commands\x18\x03 \x01(\v2 .autoroll.config.PreUploadConfigR\x11preUploadCommands\"\xbb\x01\n" +
	"\x13GitilesParentConfig\x128\n" +
	"\agitiles\x18\x01 \x01(\v2\x1e.autoroll.config.GitilesConfigR\agitiles\x123\n" +
	"\x03dep\x18\x02 \x01(\v2!.autoroll.config.DependencyConfigR\x03dep\x125\n" +
	"\x06gerrit\x18\x03 \x01(\v2\x1d.autoroll.config.GerritConfigR\x06gerrit\"\xba\x01\n" +
	"\rGitilesConfig\x12\x16\n" +
	"\x06branch\x18\x01 \x01(\tR\x06branch\x12\x19\n" +
	"\brepo_url\x18\x02 \x01(\tR\arepoUrl\x12F\n" +
	"\fdependencies\x18\x03 \x03(\v2\".autoroll.config.VersionFileConfigR\fdependencies\x12.\n" +
	"\x13default_bug_project\x18\x04 \x01(\tR\x11defaultBugProject\"\x8b\x01\n" +
	"\x17GoModGerritParentConfig\x129\n" +
	"\x06go_mod\x18\x01 \x01(\v2\".autoroll.config.GoModParentConfigR\x05goMod\x125\n" +
	"\x06gerrit\x18\x02 \x01(\v2\x1d.autoroll.config.GerritConfigR\x06gerrit\"\x8e\x02\n" +
	"\x11GoModParentConfig\x12E\n" +
	"\fgit_checkout\x18\x01 \x01(\v2\".autoroll.config.GitCheckoutConfigR\vgitCheckout\x12\x1f\n" +
	"\vmodule_path\x18\x02 \x01(\tR\n" +
	"modulePath\x12(\n" +
	"\x10find_and_replace\x18\x03 \x03(\tR\x0efindAndReplace\x12P\n" +
	"\x13pre_upload_commands\x18\x05 \x01(\v2 .autoroll.config.PreUploadConfigR\x11preUploadCommands\x12\x15\n" +
	"\x06go_cmd\x18\x06 \x01(\tR\x05goCmd\"\x82\x03\n" +
	"\x15DEPSLocalParentConfig\x12K\n" +
	"\fgit_checkout\x18\x01 \x01(\v2(.autoroll.config.GitCheckoutParentConfigR\vgitCheckout\x12\x1d\n" +
	"\n" +
	"child_path\x18\x02 \x01(\tR\tchildPath\x12!\n" +
	"\fchild_subdir\x18\x03 \x01(\tR\vchildSubdir\x12#\n" +
	"\rcheckout_path\x18\x04 \x01(\tR\fcheckoutPath\x12!\n" +
	"\fgclient_spec\x18\x05 \x01(\tR\vgclientSpec\x12\x1b\n" +
	"\trun_hooks\x18\a \x01(\bR\brunHooks\x12P\n" +
	"\x13pre_upload_commands\x18\b \x01(\v2 .autoroll.config.PreUploadConfigR\x11preUploadCommands\x12#\n" +
	"\rparent_subdir\x18\t \x01(\tR\fparentSubdir\"\x95\x01\n" +
	"\x17GitCheckoutParentConfig\x12E\n" +
	"\fgit_checkout\x18\x01 \x01(\v2\".autoroll.config.GitCheckoutConfigR\vgitCheckout\x123\n" +
	"\x03dep\x18\x02 \x01(\v2!.autoroll.config.DependencyConfigR\x03dep\"V\n" +
	"\x14FreeTypeParentConfig\x12>\n" +
	"\agitiles\x18\x01 \x01(\v2$.autoroll.config.GitilesParentConfigR\agitiles\"\xfd\x01\n" +
	"\x0fCIPDChildConfig\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x10\n" +
	"\x03tag\x18\x02 \x01(\tR\x03tag\x12!\n" +
	"\fgitiles_repo\x18\x04 \x01(\tR\vgitilesRepo\x12&\n" +
	"\x0frevision_id_tag\x18\x05 \x01(\tR\rrevisionIdTag\x128\n" +
	"\x19revision_id_tag_strip_key\x18\x06 \x01(\bR\x15revisionIdTagStripKey\x12?\n" +
	"\vsource_repo\x18\a \x01(\v2\x1e.autoroll.config.GitilesConfigR\n" +
	"sourceRepo\"\xe9\x01\n" +
	"\x15FuchsiaSDKChildConfig\x12&\n" +
	"\x0finclude_mac_sdk\x18\x01 \x01(\bR\rincludeMacSdk\x12\x1d\n" +
	"\n" +
	"gcs_bucket\x18\x02 \x01(\tR\tgcsBucket\x12*\n" +
	"\x11latest_linux_path\x18\x03 \x01(\tR\x0flatestLinuxPath\x12&\n" +
	"\x0flatest_mac_path\x18\x04 \x01(\tR\rlatestMacPath\x125\n" +
	"\x17tarball_linux_path_tmpl\x18\x05 \x01(\tR\x14tarballLinuxPathTmpl\"\x96\x01\n" +
	"\x14SemVerGCSChildConfig\x121\n" +
	"\x03gcs\x18\x01 \x01(\v2\x1f.autoroll.config.GCSChildConfigR\x03gcs\x12&\n" +
	"\x0fshort_rev_regex\x18\x02 \x01(\tR\rshortRevRegex\x12#\n" +
	"\rversion_regex\x18\x03 \x01(\tR\fversionRegex\"v\n" +
	"\x0eGCSChildConfig\x12\x1d\n" +
	"\n" +
	"gcs_bucket\x18\x01 \x01(\tR\tgcsBucket\x12\x19\n" +
	"\bgcs_path\x18\x02 \x01(\tR\agcsPath\x12*\n" +
	"\x11revision_id_regex\x18\x03 \x01(\tR\x0frevisionIdRegex\"_\n" +
	"\x16GitCheckoutChildConfig\x12E\n" +
	"\fgit_checkout\x18\x01 \x01(\v2\".autoroll.config.GitCheckoutConfigR\vgitCheckout\"\xa6\x01\n" +
	"\x1cGitCheckoutGitHubChildConfig\x12J\n" +
	"\fgit_checkout\x18\x01 \x01(\v2'.autoroll.config.GitCheckoutChildConfigR\vgitCheckout\x12\x1d\n" +
	"\n" +
	"repo_owner\x18\x02 \x01(\tR\trepoOwner\x12\x1b\n" +
	"\trepo_name\x18\x03 \x01(\tR\brepoName\"b\n" +
	"\x12GitilesChildConfig\x128\n" +
	"\agitiles\x18\x01 \x01(\v2\x1e.autoroll.config.GitilesConfigR\agitiles\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\"a\n" +
	"\x11DockerChildConfig\x12\x1a\n" +
	"\bregistry\x18\x01 \x01(\tR\bregistry\x12\x1e\n" +
	"\n" +
	"repository\x18\x02 \x01(\tR\n" +
	"repository\x12\x10\n" +
	"\x03tag\x18\x03 \x01(\tR\x03tag\"\xe4\x05\n" +
	"\x0eNotifierConfig\x12E\n" +
	"\tlog_level\x18\x01 \x01(\x0e2(.autoroll.config.NotifierConfig.LogLevelR\blogLevel\x12B\n" +
	"\bmsg_type\x18\x02 \x03(\x0e2'.autoroll.config.NotifierConfig.MsgTypeR\amsgType\x12<\n" +
	"\x05email\x18\x03 \x01(\v2$.autoroll.config.EmailNotifierConfigH\x00R\x05email\x129\n" +
	"\x04chat\x18\x04 \x01(\v2#.autoroll.config.ChatNotifierConfigH\x00R\x04chat\x12E\n" +
	"\bmonorail\x18\x05 \x01(\v2'.autoroll.config.MonorailNotifierConfigH\x00R\bmonorail\x12?\n" +
	"\x06pubsub\x18\x06 \x01(\v2%.autoroll.config.PubSubNotifierConfigH\x00R\x06pubsub\x12\x18\n" +
	"\asubject\x18\a \x01(\tR\asubject\"C\n" +
	"\bLogLevel\x12\n" +
	"\n" +
	"\x06SILENT\x10\x00\x12\t\n" +
	"\x05ERROR\x10\x01\x12\v\n" +
	"\aWARNING\x10\x02\x12\b\n" +
	"\x04INFO\x10\x03\x12\t\n" +
	"\x05DEBUG\x10\x04\"\xdc\x01\n" +
	"\aMsgType\x12\x10\n" +
	"\fISSUE_UPDATE\x10\x00\x12\x11\n" +
	"\rLAST_N_FAILED\x10\x01\x12\x0f\n" +
	"\vMODE_CHANGE\x10\x02\x12\x0f\n" +
	"\vNEW_FAILURE\x10\x03\x12\x0f\n" +
	"\vNEW_SUCCESS\x10\x04\x12\x18\n" +
	"\x14ROLL_CREATION_FAILED\x10\x05\x12\x13\n" +
	"\x0fSAFETY_THROTTLE\x10\x06\x12\x13\n" +
	"\x0fSTRATEGY_CHANGE\x10\a\x12\x14\n" +
	"\x10SUCCESS_THROTTLE\x10\b\x12\x1f\n" +
	"\x1bMANUAL_ROLL_CREATION_FAILED\x10\tB\b\n" +
	"\x06config\"-\n" +
	"\x13EmailNotifierConfig\x12\x16\n" +
	"\x06emails\x18\x01 \x03(\tR\x06emails\"-\n" +
	"\x12ChatNotifierConfig\x12\x17\n" +
	"\aroom_id\x18\x01 \x01(\tR\x06roomId\"\x90\x01\n" +
	"\x16MonorailNotifierConfig\x12\x18\n" +
	"\aproject\x18\x01 \x01(\tR\aproject\x12\x14\n" +
	"\x05owner\x18\x02 \x01(\tR\x05owner\x12\x0e\n" +
	"\x02cc\x18\x03 \x03(\tR\x02cc\x12\x1e\n" +
	"\n" +
	"components\x18\x04 \x03(\tR\n" +
	"components\x12\x16\n" +
	"\x06labels\x18\x05 \x03(\tR\x06labels\",\n" +
	"\x14PubSubNotifierConfig\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\"V\n" +
	"\x0eThrottleConfig\x12#\n" +
	"\rattempt_count\x18\x01 \x01(\x05R\fattemptCount\x12\x1f\n" +
	"\vtime_window\x18\x02 \x01(\tR\n" +
	"timeWindow\"\xad\x01\n" +
	"\x13TransitiveDepConfig\x128\n" +
	"\x05child\x18\x01 \x01(\v2\".autoroll.config.VersionFileConfigR\x05child\x12:\n" +
	"\x06parent\x18\x02 \x01(\v2\".autoroll.config.VersionFileConfigR\x06parent\x12 \n" +
	"\flog_url_tmpl\x18\x03 \x01(\tR\n" +
	"logUrlTmpl\"`\n" +
	"\x11VersionFileConfig\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12;\n" +
	"\x04file\x18\x02 \x03(\v2'.autoroll.config.VersionFileConfig_FileR\x04file\"n\n" +
	"\x16VersionFileConfig_File\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\x14\n" +
	"\x05regex\x18\x02 \x01(\tR\x05regex\x12*\n" +
	"\x11regex_replace_all\x18\x03 \x01(\bR\x0fregexReplaceAll\"\xc0\x01\n" +
	"\x10DependencyConfig\x12<\n" +
	"\aprimary\x18\x01 \x01(\v2\".autoroll.config.VersionFileConfigR\aprimary\x12D\n" +
	"\n" +
	"transitive\x18\x02 \x03(\v2$.autoroll.config.TransitiveDepConfigR\n" +
	"transitive\x12(\n" +
	"\x10find_and_replace\x18\x03 \x03(\tR\x0efindAndReplace\"\xe2\x01\n" +
	"\x11GitCheckoutConfig\x12\x16\n" +
	"\x06branch\x18\x01 \x01(\tR\x06branch\x12\x19\n" +
	"\brepo_url\x18\x02 \x01(\tR\arepoUrl\x12\"\n" +
	"\rrev_link_tmpl\x18\x03 \x01(\tR\vrevLinkTmpl\x12F\n" +
	"\fdependencies\x18\x04 \x03(\v2\".autoroll.config.VersionFileConfigR\fdependencies\x12.\n" +
	"\x13default_bug_project\x18\x05 \x01(\tR\x11defaultBugProject\"\x9f\x01\n" +
	"\x1fBuildbucketRevisionFilterConfig\x12\x18\n" +
	"\aproject\x18\x01 \x01(\tR\aproject\x12\x16\n" +
	"\x06bucket\x18\x02 \x01(\tR\x06bucket\x120\n" +
	"\x14buildset_commit_tmpl\x18\x03 \x01(\tR\x12buildsetCommitTmpl\x12\x18\n" +
	"\abuilder\x18\x04 \x03(\tR\abuilder\"i\n" +
	"\x18CIPDRevisionFilterConfig\x12\x18\n" +
	"\apackage\x18\x01 \x03(\tR\apackage\x12\x1a\n" +
	"\bplatform\x18\x02 \x03(\tR\bplatform\x12\x17\n" +
	"\atag_key\x18\x03 \x01(\tR\x06tagKey\"P\n" +
	"\x1dValidHttpRevisionFilterConfig\x12\x19\n" +
	"\bfile_url\x18\x01 \x01(\tR\afileUrl\x12\x14\n" +
	"\x05regex\x18\x02 \x01(\tR\x05regex\"\xa4\x01\n" +
	"\x0fPreUploadConfig\x12N\n" +
	"\fcipd_package\x18\x01 \x03(\v2+.autoroll.config.PreUploadCIPDPackageConfigR\vcipdPackage\x12A\n" +
	"\acommand\x18\x02 \x03(\v2'.autoroll.config.PreUploadCommandConfigR\acommand\"}\n" +
	"\x16PreUploadCommandConfig\x12\x18\n" +
	"\acommand\x18\x01 \x01(\tR\acommand\x12\x10\n" +
	"\x03cwd\x18\x02 \x01(\tR\x03cwd\x12\x10\n" +
	"\x03env\x18\x03 \x03(\tR\x03env\x12%\n" +
	"\x0eignore_failure\x18\x04 \x01(\bR\rignoreFailure\"^\n" +
	"\x1aPreUploadCIPDPackageConfig\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\":\n" +
	"\aConfigs\x12/\n" +
	"\x06config\x18\x01 \x03(\v2\x17.autoroll.config.ConfigR\x06config*:\n" +
	"\x04Mode\x12\v\n" +
	"\aRUNNING\x10\x00\x12\v\n" +
	"\aSTOPPED\x10\x01\x12\v\n" +
	"\aDRY_RUN\x10\x02\x12\v\n" +
	"\aOFFLINE\x10\x03B&Z$go.skia.org/infra/autoroll/go/configb\x06proto3"

var (
	file_config_proto_rawDescOnce sync.Once
	file_config_proto_rawDescData []byte
)

func file_config_proto_rawDescGZIP() []byte {
	file_config_proto_rawDescOnce.Do(func() {
		file_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_config_proto_rawDesc), len(file_config_proto_rawDesc)))
	})
	return file_config_proto_rawDescData
}

var file_config_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_config_proto_msgTypes = make([]protoimpl.MessageInfo, 53)
var file_config_proto_goTypes = []any{
	(Mode)(0),                                                  // 0: autoroll.config.Mode
	(CommitMsgConfig_BuiltIn)(0),                               // 1: autoroll.config.CommitMsgConfig.BuiltIn
	(GerritConfig_Config)(0),                                   // 2: autoroll.config.GerritConfig.Config
	(NotifierConfig_LogLevel)(0),                               // 3: autoroll.config.NotifierConfig.LogLevel
	(NotifierConfig_MsgType)(0),                                // 4: autoroll.config.NotifierConfig.MsgType
	(*Config)(nil),                                             // 5: autoroll.config.Config
	(*CommitMsgConfig)(nil),                                    // 6: autoroll.config.CommitMsgConfig
	(*GerritConfig)(nil),                                       // 7: autoroll.config.GerritConfig
	(*GitHubConfig)(nil),                                       // 8: autoroll.config.GitHubConfig
	(*Google3Config)(nil),                                      // 9: autoroll.config.Google3Config
	(*KubernetesConfig)(nil),                                   // 10: autoroll.config.KubernetesConfig
	(*AndroidRepoManagerConfig)(nil),                           // 11: autoroll.config.AndroidRepoManagerConfig
	(*CommandRepoManagerConfig)(nil),                           // 12: autoroll.config.CommandRepoManagerConfig
	(*FreeTypeRepoManagerConfig)(nil),                          // 13: autoroll.config.FreeTypeRepoManagerConfig
	(*Google3RepoManagerConfig)(nil),                           // 14: autoroll.config.Google3RepoManagerConfig
	(*ParentChildRepoManagerConfig)(nil),                       // 15: autoroll.config.ParentChildRepoManagerConfig
	(*CopyParentConfig)(nil),                                   // 16: autoroll.config.CopyParentConfig
	(*DEPSLocalGitHubParentConfig)(nil),                        // 17: autoroll.config.DEPSLocalGitHubParentConfig
	(*DEPSLocalGerritParentConfig)(nil),                        // 18: autoroll.config.DEPSLocalGerritParentConfig
	(*GitCheckoutGitHubParentConfig)(nil),                      // 19: autoroll.config.GitCheckoutGitHubParentConfig
	(*GitCheckoutGerritParentConfig)(nil),                      // 20: autoroll.config.GitCheckoutGerritParentConfig
	(*GitCheckoutGitHubFileParentConfig)(nil),                  // 21: autoroll.config.GitCheckoutGitHubFileParentConfig
	(*GitilesParentConfig)(nil),                                // 22: autoroll.config.GitilesParentConfig
	(*GitilesConfig)(nil),                                      // 23: autoroll.config.GitilesConfig
	(*GoModGerritParentConfig)(nil),                            // 24: autoroll.config.GoModGerritParentConfig
	(*GoModParentConfig)(nil),                                  // 25: autoroll.config.GoModParentConfig
	(*DEPSLocalParentConfig)(nil),                              // 26: autoroll.config.DEPSLocalParentConfig
	(*GitCheckoutParentConfig)(nil),                            // 27: autoroll.config.GitCheckoutParentConfig
	(*FreeTypeParentConfig)(nil),                               // 28: autoroll.config.FreeTypeParentConfig
	(*CIPDChildConfig)(nil),                                    // 29: autoroll.config.CIPDChildConfig
	(*FuchsiaSDKChildConfig)(nil),                              // 30: autoroll.config.FuchsiaSDKChildConfig
	(*SemVerGCSChildConfig)(nil),                               // 31: autoroll.config.SemVerGCSChildConfig
	(*GCSChildConfig)(nil),                                     // 32: autoroll.config.GCSChildConfig
	(*GitCheckoutChildConfig)(nil),                             // 33: autoroll.config.GitCheckoutChildConfig
	(*GitCheckoutGitHubChildConfig)(nil),                       // 34: autoroll.config.GitCheckoutGitHubChildConfig
	(*GitilesChildConfig)(nil),                                 // 35: autoroll.config.GitilesChildConfig
	(*DockerChildConfig)(nil),                                  // 36: autoroll.config.DockerChildConfig
	(*NotifierConfig)(nil),                                     // 37: autoroll.config.NotifierConfig
	(*EmailNotifierConfig)(nil),                                // 38: autoroll.config.EmailNotifierConfig
	(*ChatNotifierConfig)(nil),                                 // 39: autoroll.config.ChatNotifierConfig
	(*MonorailNotifierConfig)(nil),                             // 40: autoroll.config.MonorailNotifierConfig
	(*PubSubNotifierConfig)(nil),                               // 41: autoroll.config.PubSubNotifierConfig
	(*ThrottleConfig)(nil),                                     // 42: autoroll.config.ThrottleConfig
	(*TransitiveDepConfig)(nil),                                // 43: autoroll.config.TransitiveDepConfig
	(*VersionFileConfig)(nil),                                  // 44: autoroll.config.VersionFileConfig
	(*VersionFileConfig_File)(nil),                             // 45: autoroll.config.VersionFileConfig_File
	(*DependencyConfig)(nil),                                   // 46: autoroll.config.DependencyConfig
	(*GitCheckoutConfig)(nil),                                  // 47: autoroll.config.GitCheckoutConfig
	(*BuildbucketRevisionFilterConfig)(nil),                    // 48: autoroll.config.BuildbucketRevisionFilterConfig
	(*CIPDRevisionFilterConfig)(nil),                           // 49: autoroll.config.CIPDRevisionFilterConfig
	(*ValidHttpRevisionFilterConfig)(nil),                      // 50: autoroll.config.ValidHttpRevisionFilterConfig
	(*PreUploadConfig)(nil),                                    // 51: autoroll.config.PreUploadConfig
	(*PreUploadCommandConfig)(nil),                             // 52: autoroll.config.PreUploadCommandConfig
	(*PreUploadCIPDPackageConfig)(nil),                         // 53: autoroll.config.PreUploadCIPDPackageConfig
	(*Configs)(nil),                                            // 54: autoroll.config.Configs
	(*AndroidRepoManagerConfig_ProjectMetadataFileConfig)(nil), // 55: autoroll.config.AndroidRepoManagerConfig.ProjectMetadataFileConfig
	(*CommandRepoManagerConfig_CommandConfig)(nil),             // 56: autoroll.config.CommandRepoManagerConfig.CommandConfig
	(*CopyParentConfig_CopyEntry)(nil),                         // 57: autoroll.config.CopyParentConfig.CopyEntry
}
var file_config_proto_depIdxs = []int32{
	6,  // 0: autoroll.config.Config.commit_msg:type_name -> autoroll.config.CommitMsgConfig
	7,  // 1: autoroll.config.Config.gerrit:type_name -> autoroll.config.GerritConfig
	8,  // 2: autoroll.config.Config.github:type_name -> autoroll.config.GitHubConfig
	9,  // 3: autoroll.config.Config.google3:type_name -> autoroll.config.Google3Config
	10, // 4: autoroll.config.Config.kubernetes:type_name -> autoroll.config.KubernetesConfig
	15, // 5: autoroll.config.Config.parent_child_repo_manager:type_name -> autoroll.config.ParentChildRepoManagerConfig
	11, // 6: autoroll.config.Config.android_repo_manager:type_name -> autoroll.config.AndroidRepoManagerConfig
	12, // 7: autoroll.config.Config.command_repo_manager:type_name -> autoroll.config.CommandRepoManagerConfig
	13, // 8: autoroll.config.Config.freetype_repo_manager:type_name -> autoroll.config.FreeTypeRepoManagerConfig
	14, // 9: autoroll.config.Config.google3_repo_manager:type_name -> autoroll.config.Google3RepoManagerConfig
	37, // 10: autoroll.config.Config.notifiers:type_name -> autoroll.config.NotifierConfig
	42, // 11: autoroll.config.Config.safety_throttle:type_name -> autoroll.config.ThrottleConfig
	43, // 12: autoroll.config.Config.transitive_deps:type_name -> autoroll.config.TransitiveDepConfig
	0,  // 13: autoroll.config.Config.valid_modes:type_name -> autoroll.config.Mode
	1,  // 14: autoroll.config.CommitMsgConfig.built_in:type_name -> autoroll.config.CommitMsgConfig.BuiltIn
	2,  // 15: autoroll.config.GerritConfig.config:type_name -> autoroll.config.GerritConfig.Config
	55, // 16: autoroll.config.AndroidRepoManagerConfig.metadata:type_name -> autoroll.config.AndroidRepoManagerConfig.ProjectMetadataFileConfig
	51, // 17: autoroll.config.AndroidRepoManagerConfig.pre_upload_commands:type_name -> autoroll.config.PreUploadConfig
	47, // 18: autoroll.config.CommandRepoManagerConfig.git_checkout:type_name -> autoroll.config.GitCheckoutConfig
	56, // 19: autoroll.config.CommandRepoManagerConfig.get_tip_rev:type_name -> autoroll.config.CommandRepoManagerConfig.CommandConfig
	56, // 20: autoroll.config.CommandRepoManagerConfig.get_pinned_rev:type_name -> autoroll.config.CommandRepoManagerConfig.CommandConfig
	56, // 21: autoroll.config.CommandRepoManagerConfig.set_pinned_rev:type_name -> autoroll.config.CommandRepoManagerConfig.CommandConfig
	28, // 22: autoroll.config.FreeTypeRepoManagerConfig.parent:type_name -> autoroll.config.FreeTypeParentConfig
	35, // 23: autoroll.config.FreeTypeRepoManagerConfig.child:type_name -> autoroll.config.GitilesChildConfig
	16, // 24: autoroll.config.ParentChildRepoManagerConfig.copy_parent:type_name -> autoroll.config.CopyParentConfig
	17, // 25: autoroll.config.ParentChildRepoManagerConfig.deps_local_github_parent:type_name -> autoroll.config.DEPSLocalGitHubParentConfig
	18, // 26: autoroll.config.ParentChildRepoManagerConfig.deps_local_gerrit_parent:type_name -> autoroll.config.DEPSLocalGerritParentConfig
	21, // 27: autoroll.config.ParentChildRepoManagerConfig.git_checkout_github_file_parent:type_name -> autoroll.config.GitCheckoutGitHubFileParentConfig
	22, // 28: autoroll.config.ParentChildRepoManagerConfig.gitiles_parent:type_name -> autoroll.config.GitilesParentConfig
	24, // 29: autoroll.config.ParentChildRepoManagerConfig.go_mod_gerrit_parent:type_name -> autoroll.config.GoModGerritParentConfig
	20, // 30: autoroll.config.ParentChildRepoManagerConfig.git_checkout_gerrit_parent:type_name -> autoroll.config.GitCheckoutGerritParentConfig
	29, // 31: autoroll.config.ParentChildRepoManagerConfig.cipd_child:type_name -> autoroll.config.CIPDChildConfig
	30, // 32: autoroll.config.ParentChildRepoManagerConfig.fuchsia_sdk_child:type_name -> autoroll.config.FuchsiaSDKChildConfig
	33, // 33: autoroll.config.ParentChildRepoManagerConfig.git_checkout_child:type_name -> autoroll.config.GitCheckoutChildConfig
	34, // 34: autoroll.config.ParentChildRepoManagerConfig.git_checkout_github_child:type_name -> autoroll.config.GitCheckoutGitHubChildConfig
	35, // 35: autoroll.config.ParentChildRepoManagerConfig.gitiles_child:type_name -> autoroll.config.GitilesChildConfig
	31, // 36: autoroll.config.ParentChildRepoManagerConfig.semver_gcs_child:type_name -> autoroll.config.SemVerGCSChildConfig
	36, // 37: autoroll.config.ParentChildRepoManagerConfig.docker_child:type_name -> autoroll.config.DockerChildConfig
	48, // 38: autoroll.config.ParentChildRepoManagerConfig.buildbucket_revision_filter:type_name -> autoroll.config.BuildbucketRevisionFilterConfig
	49, // 39: autoroll.config.ParentChildRepoManagerConfig.cipd_revision_filter:type_name -> autoroll.config.CIPDRevisionFilterConfig
	50, // 40: autoroll.config.ParentChildRepoManagerConfig.valid_http_revision_filter:type_name -> autoroll.config.ValidHttpRevisionFilterConfig
	22, // 41: autoroll.config.CopyParentConfig.gitiles:type_name -> autoroll.config.GitilesParentConfig
	57, // 42: autoroll.config.CopyParentConfig.copies:type_name -> autoroll.config.CopyParentConfig.CopyEntry
	26, // 43: autoroll.config.DEPSLocalGitHubParentConfig.deps_local:type_name -> autoroll.config.DEPSLocalParentConfig
	8,  // 44: autoroll.config.DEPSLocalGitHubParentConfig.github:type_name -> autoroll.config.GitHubConfig
	26, // 45: autoroll.config.DEPSLocalGerritParentConfig.deps_local:type_name -> autoroll.config.DEPSLocalParentConfig
	7,  // 46: autoroll.config.DEPSLocalGerritParentConfig.gerrit:type_name -> autoroll.config.GerritConfig
	27, // 47: autoroll.config.GitCheckoutGitHubParentConfig.git_checkout:type_name -> autoroll.config.GitCheckoutParentConfig
	27, // 48: autoroll.config.GitCheckoutGerritParentConfig.git_checkout:type_name -> autoroll.config.GitCheckoutParentConfig
	51, // 49: autoroll.config.GitCheckoutGerritParentConfig.pre_upload_commands:type_name -> autoroll.config.PreUploadConfig
	19, // 50: autoroll.config.GitCheckoutGitHubFileParentConfig.git_checkout:type_name -> autoroll.config.GitCheckoutGitHubParentConfig
	51, // 51: autoroll.config.GitCheckoutGitHubFileParentConfig.pre_upload_commands:type_name -> autoroll.config.PreUploadConfig
	23, // 52: autoroll.config.GitilesParentConfig.gitiles:type_name -> autoroll.config.GitilesConfig
	46, // 53: autoroll.config.GitilesParentConfig.dep:type_name -> autoroll.config.DependencyConfig
	7,  // 54: autoroll.config.GitilesParentConfig.gerrit:type_name -> autoroll.config.GerritConfig
	44, // 55: autoroll.config.GitilesConfig.dependencies:type_name -> autoroll.config.VersionFileConfig
	25, // 56: autoroll.config.GoModGerritParentConfig.go_mod:type_name -> autoroll.config.GoModParentConfig
	7,  // 57: autoroll.config.GoModGerritParentConfig.gerrit:type_name -> autoroll.config.GerritConfig
	47, // 58: autoroll.config.GoModParentConfig.git_checkout:type_name -> autoroll.config.GitCheckoutConfig
	51, // 59: autoroll.config.GoModParentConfig.pre_upload_commands:type_name -> autoroll.config.PreUploadConfig
	27, // 60: autoroll.config.DEPSLocalParentConfig.git_checkout:type_name -> autoroll.config.GitCheckoutParentConfig
	51, // 61: autoroll.config.DEPSLocalParentConfig.pre_upload_commands:type_name -> autoroll.config.PreUploadConfig
	47, // 62: autoroll.config.GitCheckoutParentConfig.git_checkout:type_name -> autoroll.config.GitCheckoutConfig
	46, // 63: autoroll.config.GitCheckoutParentConfig.dep:type_name -> autoroll.config.DependencyConfig
	22, // 64: autoroll.config.FreeTypeParentConfig.gitiles:type_name -> autoroll.config.GitilesParentConfig
	23, // 65: autoroll.config.CIPDChildConfig.source_repo:type_name -> autoroll.config.GitilesConfig
	32, // 66: autoroll.config.SemVerGCSChildConfig.gcs:type_name -> autoroll.config.GCSChildConfig
	47, // 67: autoroll.config.GitCheckoutChildConfig.git_checkout:type_name -> autoroll.config.GitCheckoutConfig
	33, // 68: autoroll.config.GitCheckoutGitHubChildConfig.git_checkout:type_name -> autoroll.config.GitCheckoutChildConfig
	23, // 69: autoroll.config.GitilesChildConfig.gitiles:type_name -> autoroll.config.GitilesConfig
	3,  // 70: autoroll.config.NotifierConfig.log_level:type_name -> autoroll.config.NotifierConfig.LogLevel
	4,  // 71: autoroll.config.NotifierConfig.msg_type:type_name -> autoroll.config.NotifierConfig.MsgType
	38, // 72: autoroll.config.NotifierConfig.email:type_name -> autoroll.config.EmailNotifierConfig
	39, // 73: autoroll.config.NotifierConfig.chat:type_name -> autoroll.config.ChatNotifierConfig
	40, // 74: autoroll.config.NotifierConfig.monorail:type_name -> autoroll.config.MonorailNotifierConfig
	41, // 75: autoroll.config.NotifierConfig.pubsub:type_name -> autoroll.config.PubSubNotifierConfig
	44, // 76: autoroll.config.TransitiveDepConfig.child:type_name -> autoroll.config.VersionFileConfig
	44, // 77: autoroll.config.TransitiveDepConfig.parent:type_name -> autoroll.config.VersionFileConfig
	45, // 78: autoroll.config.VersionFileConfig.file:type_name -> autoroll.config.VersionFileConfig_File
	44, // 79: autoroll.config.DependencyConfig.primary:type_name -> autoroll.config.VersionFileConfig
	43, // 80: autoroll.config.DependencyConfig.transitive:type_name -> autoroll.config.TransitiveDepConfig
	44, // 81: autoroll.config.GitCheckoutConfig.dependencies:type_name -> autoroll.config.VersionFileConfig
	53, // 82: autoroll.config.PreUploadConfig.cipd_package:type_name -> autoroll.config.PreUploadCIPDPackageConfig
	52, // 83: autoroll.config.PreUploadConfig.command:type_name -> autoroll.config.PreUploadCommandConfig
	5,  // 84: autoroll.config.Configs.config:type_name -> autoroll.config.Config
	85, // [85:85] is the sub-list for method output_type
	85, // [85:85] is the sub-list for method input_type
	85, // [85:85] is the sub-list for extension type_name
	85, // [85:85] is the sub-list for extension extendee
	0,  // [0:85] is the sub-list for field type_name
}

func init() { file_config_proto_init() }
func file_config_proto_init() {
	if File_config_proto != nil {
		return
	}
	file_config_proto_msgTypes[0].OneofWrappers = []any{
		(*Config_Gerrit)(nil),
		(*Config_Github)(nil),
		(*Config_Google3)(nil),
		(*Config_ParentChildRepoManager)(nil),
		(*Config_AndroidRepoManager)(nil),
		(*Config_CommandRepoManager)(nil),
		(*Config_FreetypeRepoManager)(nil),
		(*Config_Google3RepoManager)(nil),
	}
	file_config_proto_msgTypes[10].OneofWrappers = []any{
		(*ParentChildRepoManagerConfig_CopyParent)(nil),
		(*ParentChildRepoManagerConfig_DepsLocalGithubParent)(nil),
		(*ParentChildRepoManagerConfig_DepsLocalGerritParent)(nil),
		(*ParentChildRepoManagerConfig_GitCheckoutGithubFileParent)(nil),
		(*ParentChildRepoManagerConfig_GitilesParent)(nil),
		(*ParentChildRepoManagerConfig_GoModGerritParent)(nil),
		(*ParentChildRepoManagerConfig_GitCheckoutGerritParent)(nil),
		(*ParentChildRepoManagerConfig_CipdChild)(nil),
		(*ParentChildRepoManagerConfig_FuchsiaSdkChild)(nil),
		(*ParentChildRepoManagerConfig_GitCheckoutChild)(nil),
		(*ParentChildRepoManagerConfig_GitCheckoutGithubChild)(nil),
		(*ParentChildRepoManagerConfig_GitilesChild)(nil),
		(*ParentChildRepoManagerConfig_SemverGcsChild)(nil),
		(*ParentChildRepoManagerConfig_DockerChild)(nil),
	}
	file_config_proto_msgTypes[32].OneofWrappers = []any{
		(*NotifierConfig_Email)(nil),
		(*NotifierConfig_Chat)(nil),
		(*NotifierConfig_Monorail)(nil),
		(*NotifierConfig_Pubsub)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_config_proto_rawDesc), len(file_config_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   53,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_config_proto_goTypes,
		DependencyIndexes: file_config_proto_depIdxs,
		EnumInfos:         file_config_proto_enumTypes,
		MessageInfos:      file_config_proto_msgTypes,
	}.Build()
	File_config_proto = out.File
	file_config_proto_goTypes = nil
	file_config_proto_depIdxs = nil
}
