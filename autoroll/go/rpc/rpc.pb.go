// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.32.0
// 	protoc        v3.21.12
// source: rpc.proto

package rpc

import (
	reflect "reflect"
	sync "sync"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Mode describes the valid operating modes of an autoroller.
// These must be kept in sync with autoroll/go/modes/modes.go.
type Mode int32

const (
	// RUNNING is the typical operating mode of the autoroller. It will upload and
	// land CLs as new revisions appear in the Child.
	Mode_RUNNING Mode = 0
	// STOPPED prevents the autoroller from uploading any CLs. The roller will
	// continue to update any local checkouts to prevent them from getting too far
	// out of date, and any requested manual rolls will be fulfilled.
	Mode_STOPPED Mode = 1
	// DRY_RUN is similar to RUNNING but does not land the roll CLs after the
	// commit queue finishes. Instead, the active roll is left open until new
	// revisions appear in the child, at which point the roll is closed and a new
	// one is uploaded.
	Mode_DRY_RUN Mode = 2
	// OFFLINE is similar to STOPPED, but the roller does not update its checkouts
	// and requests for manual rolls are ignored.
	Mode_OFFLINE Mode = 3
)

// Enum value maps for Mode.
var (
	Mode_name = map[int32]string{
		0: "RUNNING",
		1: "STOPPED",
		2: "DRY_RUN",
		3: "OFFLINE",
	}
	Mode_value = map[string]int32{
		"RUNNING": 0,
		"STOPPED": 1,
		"DRY_RUN": 2,
		"OFFLINE": 3,
	}
)

func (x Mode) Enum() *Mode {
	p := new(Mode)
	*p = x
	return p
}

func (x Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[0].Descriptor()
}

func (Mode) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[0]
}

func (x Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Mode.Descriptor instead.
func (Mode) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{0}
}

// Strategy describes the valid strategies for choosing the next revision to
// roll. These must be kept in sync with autoroll/go/strategy/strategies.go.
type Strategy int32

const (
	// BATCH indicates that all not-yet-rolled revisions should be rolled in a
	// single CL.
	Strategy_BATCH Strategy = 0
	// N_BATCH is similar to BATCH but puts a limit on the number of revisions in
	// a single CL.
	Strategy_N_BATCH Strategy = 1
	// SINGLE indicates that a single revision is rolled in each CL.
	Strategy_SINGLE Strategy = 2
)

// Enum value maps for Strategy.
var (
	Strategy_name = map[int32]string{
		0: "BATCH",
		1: "N_BATCH",
		2: "SINGLE",
	}
	Strategy_value = map[string]int32{
		"BATCH":   0,
		"N_BATCH": 1,
		"SINGLE":  2,
	}
)

func (x Strategy) Enum() *Strategy {
	p := new(Strategy)
	*p = x
	return p
}

func (x Strategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Strategy) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[1].Descriptor()
}

func (Strategy) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[1]
}

func (x Strategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Strategy.Descriptor instead.
func (Strategy) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1}
}

// Result describes the possible results for a TryJob.
// These must be kept in sync with go/autoroll/autoroll.go.
type TryJob_Result int32

const (
	// UNKNOWN indicates that the result of the TryJob is unknown, ie. it has
	// not yet finished.
	TryJob_UNKNOWN TryJob_Result = 0
	// SUCCESS indicates that that TryJob completed successfully.
	TryJob_SUCCESS TryJob_Result = 1
	// FAILURE indicates that that TryJob failed.
	TryJob_FAILURE TryJob_Result = 2
	// CANCELED indicates that that TryJob was canceled.
	TryJob_CANCELED TryJob_Result = 3
)

// Enum value maps for TryJob_Result.
var (
	TryJob_Result_name = map[int32]string{
		0: "UNKNOWN",
		1: "SUCCESS",
		2: "FAILURE",
		3: "CANCELED",
	}
	TryJob_Result_value = map[string]int32{
		"UNKNOWN":  0,
		"SUCCESS":  1,
		"FAILURE":  2,
		"CANCELED": 3,
	}
)

func (x TryJob_Result) Enum() *TryJob_Result {
	p := new(TryJob_Result)
	*p = x
	return p
}

func (x TryJob_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TryJob_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[2].Descriptor()
}

func (TryJob_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[2]
}

func (x TryJob_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TryJob_Result.Descriptor instead.
func (TryJob_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1, 0}
}

// Status describes the lifecycle states of a TryJob.
// These must be kept in sync with go/autoroll/autoroll.go.
type TryJob_Status int32

const (
	// SCHEDULED indicates that the TryJob has been scheduled but has not yet
	// started.
	TryJob_SCHEDULED TryJob_Status = 0
	// STARTED indicates that the TryJob is currently running.
	TryJob_STARTED TryJob_Status = 1
	// COMPLETED indicates that the TryJob is finishes.
	TryJob_COMPLETED TryJob_Status = 2
)

// Enum value maps for TryJob_Status.
var (
	TryJob_Status_name = map[int32]string{
		0: "SCHEDULED",
		1: "STARTED",
		2: "COMPLETED",
	}
	TryJob_Status_value = map[string]int32{
		"SCHEDULED": 0,
		"STARTED":   1,
		"COMPLETED": 2,
	}
)

func (x TryJob_Status) Enum() *TryJob_Status {
	p := new(TryJob_Status)
	*p = x
	return p
}

func (x TryJob_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TryJob_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[3].Descriptor()
}

func (TryJob_Status) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[3]
}

func (x TryJob_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TryJob_Status.Descriptor instead.
func (TryJob_Status) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1, 1}
}

// Result describes the possible results for an AutoRollCL.
type AutoRollCL_Result int32

const (
	// IN_PROGRESS indicates that the commit queue is still running for this
	// AutoRollCL.
	AutoRollCL_IN_PROGRESS AutoRollCL_Result = 0
	// SUCCESS indicates that this AutoRollCL landed successfully.
	AutoRollCL_SUCCESS AutoRollCL_Result = 1
	// FAILURE indicates that the commit queue failed for  this AutoRollCL.
	AutoRollCL_FAILURE AutoRollCL_Result = 2
	// DRY_RUN_IN_PROGRESS indicates that the commit queue dry run is still
	// running for this AutoRollCL.
	AutoRollCL_DRY_RUN_IN_PROGRESS AutoRollCL_Result = 3
	// DRY_RUN_SUCCESS indicates that the commit queue dry run succeeded for
	// this AutoRollCL.
	AutoRollCL_DRY_RUN_SUCCESS AutoRollCL_Result = 4
	// DRY_RUN_FAILURE indicates that the commit queue dry run failed for this
	// AutoRollCL.
	AutoRollCL_DRY_RUN_FAILURE AutoRollCL_Result = 5
	// HUMAN_INTERVENED indicates that a human has modified the AutoRollCL and
	// the roller is no longer able to take action on it.
	AutoRollCL_HUMAN_INTERVENED AutoRollCL_Result = 6
)

// Enum value maps for AutoRollCL_Result.
var (
	AutoRollCL_Result_name = map[int32]string{
		0: "IN_PROGRESS",
		1: "SUCCESS",
		2: "FAILURE",
		3: "DRY_RUN_IN_PROGRESS",
		4: "DRY_RUN_SUCCESS",
		5: "DRY_RUN_FAILURE",
		6: "HUMAN_INTERVENED",
	}
	AutoRollCL_Result_value = map[string]int32{
		"IN_PROGRESS":         0,
		"SUCCESS":             1,
		"FAILURE":             2,
		"DRY_RUN_IN_PROGRESS": 3,
		"DRY_RUN_SUCCESS":     4,
		"DRY_RUN_FAILURE":     5,
		"HUMAN_INTERVENED":    6,
	}
)

func (x AutoRollCL_Result) Enum() *AutoRollCL_Result {
	p := new(AutoRollCL_Result)
	*p = x
	return p
}

func (x AutoRollCL_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AutoRollCL_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[4].Descriptor()
}

func (AutoRollCL_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[4]
}

func (x AutoRollCL_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AutoRollCL_Result.Descriptor instead.
func (AutoRollCL_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{2, 0}
}

// Result describes the possible results for a manual roll.
// These must be kept in sync with autoroll/go/manual/db.go.
type ManualRoll_Result int32

const (
	// UNKNOWN indicates that the result of the ManualRoll is unknown, ie. it
	// has not yet finished.
	ManualRoll_UNKNOWN ManualRoll_Result = 0
	// FAILURE indicates that the ManualRoll has failed.
	ManualRoll_FAILURE ManualRoll_Result = 1
	// SUCCESS indicates that the ManualRoll landed successfully.
	ManualRoll_SUCCESS ManualRoll_Result = 2
)

// Enum value maps for ManualRoll_Result.
var (
	ManualRoll_Result_name = map[int32]string{
		0: "UNKNOWN",
		1: "FAILURE",
		2: "SUCCESS",
	}
	ManualRoll_Result_value = map[string]int32{
		"UNKNOWN": 0,
		"FAILURE": 1,
		"SUCCESS": 2,
	}
)

func (x ManualRoll_Result) Enum() *ManualRoll_Result {
	p := new(ManualRoll_Result)
	*p = x
	return p
}

func (x ManualRoll_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ManualRoll_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[5].Descriptor()
}

func (ManualRoll_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[5]
}

func (x ManualRoll_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ManualRoll_Result.Descriptor instead.
func (ManualRoll_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7, 0}
}

// Status describes the lifecycle states of a manual roll.
// These must be kept in sync with autoroll/go/manual/db.go.
type ManualRoll_Status int32

const (
	// PENDING indicates that the ManualRoll has been requested but no CL has
	// been uploaded.
	ManualRoll_PENDING ManualRoll_Status = 0
	// STARTED indicates that a CL has been uploaded for this ManualRoll.
	ManualRoll_STARTED ManualRoll_Status = 1
	// COMPLETED indicates that the ManualRoll has finished and either landed
	// successfully or failed.
	ManualRoll_COMPLETED ManualRoll_Status = 2
)

// Enum value maps for ManualRoll_Status.
var (
	ManualRoll_Status_name = map[int32]string{
		0: "PENDING",
		1: "STARTED",
		2: "COMPLETED",
	}
	ManualRoll_Status_value = map[string]int32{
		"PENDING":   0,
		"STARTED":   1,
		"COMPLETED": 2,
	}
)

func (x ManualRoll_Status) Enum() *ManualRoll_Status {
	p := new(ManualRoll_Status)
	*p = x
	return p
}

func (x ManualRoll_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ManualRoll_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[6].Descriptor()
}

func (ManualRoll_Status) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[6]
}

func (x ManualRoll_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ManualRoll_Status.Descriptor instead.
func (ManualRoll_Status) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7, 1}
}

// AutoRollMiniStatus contains a subset of the information of AutoRollStatus.
type AutoRollMiniStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique ID for this roller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// child_name is the display name of the child.
	ChildName string `protobuf:"bytes,2,opt,name=child_name,json=childName,proto3" json:"child_name,omitempty"`
	// parent_name is the display name of the parent.
	ParentName string `protobuf:"bytes,3,opt,name=parent_name,json=parentName,proto3" json:"parent_name,omitempty"`
	// mode is the currently-set operating mode of the roller.
	Mode Mode `protobuf:"varint,4,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// current_roll_rev is the ID of the child revision which is being rolled in
	// the active roll CL.
	CurrentRollRev string `protobuf:"bytes,5,opt,name=current_roll_rev,json=currentRollRev,proto3" json:"current_roll_rev,omitempty"`
	// last_roll_rev is the ID of the child revision which is currently pinned by
	// the parent.
	LastRollRev string `protobuf:"bytes,6,opt,name=last_roll_rev,json=lastRollRev,proto3" json:"last_roll_rev,omitempty"`
	// num_failed is the number of consecutive roll failures.
	NumFailed int32 `protobuf:"varint,7,opt,name=num_failed,json=numFailed,proto3" json:"num_failed,omitempty"`
	// num_behind is the number of not-yet-rolled revisions.
	NumBehind int32 `protobuf:"varint,8,opt,name=num_behind,json=numBehind,proto3" json:"num_behind,omitempty"`
	// timestamp is the time at which the roller last reported its status.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// last_successful_roll_timestamp is the time at which the roller last rolled
	// successfully.
	LastSuccessfulRollTimestamp *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=last_successful_roll_timestamp,json=lastSuccessfulRollTimestamp,proto3" json:"last_successful_roll_timestamp,omitempty"`
}

func (x *AutoRollMiniStatus) Reset() {
	*x = AutoRollMiniStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutoRollMiniStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollMiniStatus) ProtoMessage() {}

func (x *AutoRollMiniStatus) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollMiniStatus.ProtoReflect.Descriptor instead.
func (*AutoRollMiniStatus) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{0}
}

func (x *AutoRollMiniStatus) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *AutoRollMiniStatus) GetChildName() string {
	if x != nil {
		return x.ChildName
	}
	return ""
}

func (x *AutoRollMiniStatus) GetParentName() string {
	if x != nil {
		return x.ParentName
	}
	return ""
}

func (x *AutoRollMiniStatus) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *AutoRollMiniStatus) GetCurrentRollRev() string {
	if x != nil {
		return x.CurrentRollRev
	}
	return ""
}

func (x *AutoRollMiniStatus) GetLastRollRev() string {
	if x != nil {
		return x.LastRollRev
	}
	return ""
}

func (x *AutoRollMiniStatus) GetNumFailed() int32 {
	if x != nil {
		return x.NumFailed
	}
	return 0
}

func (x *AutoRollMiniStatus) GetNumBehind() int32 {
	if x != nil {
		return x.NumBehind
	}
	return 0
}

func (x *AutoRollMiniStatus) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *AutoRollMiniStatus) GetLastSuccessfulRollTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSuccessfulRollTimestamp
	}
	return nil
}

type TryJob struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// name of the TryJob.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// status of the TryJob.
	Status TryJob_Status `protobuf:"varint,2,opt,name=status,proto3,enum=autoroll.rpc.TryJob_Status" json:"status,omitempty"`
	// result of the TryJob.
	Result TryJob_Result `protobuf:"varint,3,opt,name=result,proto3,enum=autoroll.rpc.TryJob_Result" json:"result,omitempty"`
	// url where more details can be found about the TryJob.
	Url string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	// category of the TryJob, eg. "cq".
	Category string `protobuf:"bytes,5,opt,name=category,proto3" json:"category,omitempty"`
}

func (x *TryJob) Reset() {
	*x = TryJob{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TryJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TryJob) ProtoMessage() {}

func (x *TryJob) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TryJob.ProtoReflect.Descriptor instead.
func (*TryJob) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1}
}

func (x *TryJob) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TryJob) GetStatus() TryJob_Status {
	if x != nil {
		return x.Status
	}
	return TryJob_SCHEDULED
}

func (x *TryJob) GetResult() TryJob_Result {
	if x != nil {
		return x.Result
	}
	return TryJob_UNKNOWN
}

func (x *TryJob) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *TryJob) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

// AutoRoll CL describes a CL uploaded by the autoroller.
type AutoRollCL struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier for the CL.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// result of the AutoRollCL.
	Result AutoRollCL_Result `protobuf:"varint,2,opt,name=result,proto3,enum=autoroll.rpc.AutoRollCL_Result" json:"result,omitempty"`
	// subject line of the commit message of the AutoRollCL.
	Subject string `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
	// rolling_to is the ID of the revision being rolled.
	RollingTo string `protobuf:"bytes,4,opt,name=rolling_to,json=rollingTo,proto3" json:"rolling_to,omitempty"`
	// rolling_from is the ID of the currently-pinned revision.
	RollingFrom string `protobuf:"bytes,5,opt,name=rolling_from,json=rollingFrom,proto3" json:"rolling_from,omitempty"`
	// created is the timestamp at which the AutoRollCL was created.
	Created *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	// created is the timestamp at which the AutoRollCL was last modified.
	Modified *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=modified,proto3" json:"modified,omitempty"`
	// try_jobs contains results of any try jobs for the AutoRollCL.
	TryJobs []*TryJob `protobuf:"bytes,8,rep,name=try_jobs,json=tryJobs,proto3" json:"try_jobs,omitempty"`
}

func (x *AutoRollCL) Reset() {
	*x = AutoRollCL{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutoRollCL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollCL) ProtoMessage() {}

func (x *AutoRollCL) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollCL.ProtoReflect.Descriptor instead.
func (*AutoRollCL) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{2}
}

func (x *AutoRollCL) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AutoRollCL) GetResult() AutoRollCL_Result {
	if x != nil {
		return x.Result
	}
	return AutoRollCL_IN_PROGRESS
}

func (x *AutoRollCL) GetSubject() string {
	if x != nil {
		return x.Subject
	}
	return ""
}

func (x *AutoRollCL) GetRollingTo() string {
	if x != nil {
		return x.RollingTo
	}
	return ""
}

func (x *AutoRollCL) GetRollingFrom() string {
	if x != nil {
		return x.RollingFrom
	}
	return ""
}

func (x *AutoRollCL) GetCreated() *timestamppb.Timestamp {
	if x != nil {
		return x.Created
	}
	return nil
}

func (x *AutoRollCL) GetModified() *timestamppb.Timestamp {
	if x != nil {
		return x.Modified
	}
	return nil
}

func (x *AutoRollCL) GetTryJobs() []*TryJob {
	if x != nil {
		return x.TryJobs
	}
	return nil
}

// Revision describes a single revision in a given Child. This may be a Git
// commit, CIPD package instance, a file uploaded to GCS, etc.
type Revision struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier for the Revision.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// display is a human-friendly display name for the Revision.
	Display string `protobuf:"bytes,2,opt,name=display,proto3" json:"display,omitempty"`
	// description is a longer description of the Revision.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// time is the timestamp at which the Revision was created.
	Time *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// url where more details can be found about the Revision.
	Url string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
	// invalid_reason, if set, indicates why this Revision is not valid.
	InvalidReason string `protobuf:"bytes,6,opt,name=invalid_reason,json=invalidReason,proto3" json:"invalid_reason,omitempty"`
}

func (x *Revision) Reset() {
	*x = Revision{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Revision) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Revision) ProtoMessage() {}

func (x *Revision) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Revision.ProtoReflect.Descriptor instead.
func (*Revision) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{3}
}

func (x *Revision) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Revision) GetDisplay() string {
	if x != nil {
		return x.Display
	}
	return ""
}

func (x *Revision) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Revision) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *Revision) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *Revision) GetInvalidReason() string {
	if x != nil {
		return x.InvalidReason
	}
	return ""
}

// AutoRollConfig describes the configuration for a roller.
type AutoRollConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// child_bug_link is a link to file a bug for the child project.
	ChildBugLink string `protobuf:"bytes,5,opt,name=child_bug_link,json=childBugLink,proto3" json:"child_bug_link,omitempty"`
	// parent_bug_link is a link to file a bug for the parent project.
	ParentBugLink string `protobuf:"bytes,6,opt,name=parent_bug_link,json=parentBugLink,proto3" json:"parent_bug_link,omitempty"`
	// parent_waterfall is the URL of the CI display for the parent repo.
	ParentWaterfall string `protobuf:"bytes,1,opt,name=parent_waterfall,json=parentWaterfall,proto3" json:"parent_waterfall,omitempty"`
	// roller_id is the unique identifier for the roller.
	RollerId string `protobuf:"bytes,2,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// supports_manual_rolls indicates whether this autoroller supports manually-
	// triggered rolls.
	SupportsManualRolls bool `protobuf:"varint,3,opt,name=supports_manual_rolls,json=supportsManualRolls,proto3" json:"supports_manual_rolls,omitempty"`
	// time_window describes the limitations, if any, on when the autoroller is
	// allowed to upload roll CLs.
	TimeWindow string `protobuf:"bytes,4,opt,name=time_window,json=timeWindow,proto3" json:"time_window,omitempty"`
	// valid_modes lists the valid modes for the roller. If not specified, all
	// modes are allowed.
	ValidModes []Mode `protobuf:"varint,7,rep,packed,name=valid_modes,json=validModes,proto3,enum=autoroll.rpc.Mode" json:"valid_modes,omitempty"`
}

func (x *AutoRollConfig) Reset() {
	*x = AutoRollConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutoRollConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollConfig) ProtoMessage() {}

func (x *AutoRollConfig) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollConfig.ProtoReflect.Descriptor instead.
func (*AutoRollConfig) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{4}
}

func (x *AutoRollConfig) GetChildBugLink() string {
	if x != nil {
		return x.ChildBugLink
	}
	return ""
}

func (x *AutoRollConfig) GetParentBugLink() string {
	if x != nil {
		return x.ParentBugLink
	}
	return ""
}

func (x *AutoRollConfig) GetParentWaterfall() string {
	if x != nil {
		return x.ParentWaterfall
	}
	return ""
}

func (x *AutoRollConfig) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *AutoRollConfig) GetSupportsManualRolls() bool {
	if x != nil {
		return x.SupportsManualRolls
	}
	return false
}

func (x *AutoRollConfig) GetTimeWindow() string {
	if x != nil {
		return x.TimeWindow
	}
	return ""
}

func (x *AutoRollConfig) GetValidModes() []Mode {
	if x != nil {
		return x.ValidModes
	}
	return nil
}

// ModeChange describes one instance of an autoroller's mode being changed.
type ModeChange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier for the autoroller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// mode is the operating mode of the autoroller which was set in this
	// ModeChange.
	Mode Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// user is the email address of the user who created this ModeChange.
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// time is the timestamp at which the ModeChange was created.
	Time *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// message is a user-created message which describes the reason for changing
	// the mode.
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *ModeChange) Reset() {
	*x = ModeChange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ModeChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModeChange) ProtoMessage() {}

func (x *ModeChange) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModeChange.ProtoReflect.Descriptor instead.
func (*ModeChange) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{5}
}

func (x *ModeChange) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *ModeChange) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *ModeChange) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *ModeChange) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *ModeChange) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// StrategyChange describes one instance of an autoroller's mode being changed.
type StrategyChange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier for the autoroller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// strategy is the strategy for choosing the next revision to roll which was
	// set in this StrategyChange.
	Strategy Strategy `protobuf:"varint,2,opt,name=strategy,proto3,enum=autoroll.rpc.Strategy" json:"strategy,omitempty"`
	// user is the email address of the user who created this StrategyChange.
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// time is the timestamp at which the StrategyChange was created.
	Time *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// message is a user-created message which describes the reason for changing
	// the strategy.
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *StrategyChange) Reset() {
	*x = StrategyChange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StrategyChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StrategyChange) ProtoMessage() {}

func (x *StrategyChange) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StrategyChange.ProtoReflect.Descriptor instead.
func (*StrategyChange) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{6}
}

func (x *StrategyChange) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *StrategyChange) GetStrategy() Strategy {
	if x != nil {
		return x.Strategy
	}
	return Strategy_BATCH
}

func (x *StrategyChange) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *StrategyChange) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *StrategyChange) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ManualRoll describes a manually-triggered roll and its results.
type ManualRoll struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier for this ManualRoll.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// roller_id is the unique identifier for the autoroller on which this
	// ManualRoll was requested.
	RollerId string `protobuf:"bytes,2,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// revision is the ID of the revision to which this ManualRoll will roll.
	Revision string `protobuf:"bytes,3,opt,name=revision,proto3" json:"revision,omitempty"`
	// requester is the email address of the person who requested the ManualRoll.
	Requester string `protobuf:"bytes,4,opt,name=requester,proto3" json:"requester,omitempty"`
	// result of the ManualRoll.
	Result ManualRoll_Result `protobuf:"varint,5,opt,name=result,proto3,enum=autoroll.rpc.ManualRoll_Result" json:"result,omitempty"`
	// status of the ManualRoll.
	Status ManualRoll_Status `protobuf:"varint,6,opt,name=status,proto3,enum=autoroll.rpc.ManualRoll_Status" json:"status,omitempty"`
	// timestamp at which the ManualRoll was created.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// url of the ManualRoll, if a roll has been uploaded.
	Url string `protobuf:"bytes,8,opt,name=url,proto3" json:"url,omitempty"`
	// dry_run indicates whether the ManualRoll should be performed as a dry run,
	// so that the commit queue runs but the CL is not landed.
	DryRun bool `protobuf:"varint,9,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// no_email specifies that the requester and reviewers should not receive
	// email related to this ManualRoll.
	NoEmail bool `protobuf:"varint,10,opt,name=no_email,json=noEmail,proto3" json:"no_email,omitempty"`
	// no_resolve_revision specifies that the autoroller should not attempt to
	// find the requested revision ID in the Child but should simply use it as
	// provided.
	NoResolveRevision bool `protobuf:"varint,11,opt,name=no_resolve_revision,json=noResolveRevision,proto3" json:"no_resolve_revision,omitempty"`
	// canary indicates that this manual roll was a canary request.
	Canary bool `protobuf:"varint,12,opt,name=canary,proto3" json:"canary,omitempty"`
}

func (x *ManualRoll) Reset() {
	*x = ManualRoll{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ManualRoll) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManualRoll) ProtoMessage() {}

func (x *ManualRoll) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ManualRoll.ProtoReflect.Descriptor instead.
func (*ManualRoll) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7}
}

func (x *ManualRoll) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ManualRoll) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *ManualRoll) GetRevision() string {
	if x != nil {
		return x.Revision
	}
	return ""
}

func (x *ManualRoll) GetRequester() string {
	if x != nil {
		return x.Requester
	}
	return ""
}

func (x *ManualRoll) GetResult() ManualRoll_Result {
	if x != nil {
		return x.Result
	}
	return ManualRoll_UNKNOWN
}

func (x *ManualRoll) GetStatus() ManualRoll_Status {
	if x != nil {
		return x.Status
	}
	return ManualRoll_PENDING
}

func (x *ManualRoll) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *ManualRoll) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *ManualRoll) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *ManualRoll) GetNoEmail() bool {
	if x != nil {
		return x.NoEmail
	}
	return false
}

func (x *ManualRoll) GetNoResolveRevision() bool {
	if x != nil {
		return x.NoResolveRevision
	}
	return false
}

func (x *ManualRoll) GetCanary() bool {
	if x != nil {
		return x.Canary
	}
	return false
}

// AutoRollStatus describes the overall status of an autoroller.
type AutoRollStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// mini_status contains a subset of status information for the autoroller.
	MiniStatus *AutoRollMiniStatus `protobuf:"bytes,1,opt,name=mini_status,json=miniStatus,proto3" json:"mini_status,omitempty"`
	// status is the current status of the autoroller, as provided by the state
	// machine.
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// config provides configuration information for the autoroller.
	Config *AutoRollConfig `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	// full_history_url is the URL where the autoroller's history may be viewed.
	FullHistoryUrl string `protobuf:"bytes,4,opt,name=full_history_url,json=fullHistoryUrl,proto3" json:"full_history_url,omitempty"`
	// issue_url_base provides a base URL which can be used to construct URLs for
	// individual AutoRollCLs.
	IssueUrlBase string `protobuf:"bytes,5,opt,name=issue_url_base,json=issueUrlBase,proto3" json:"issue_url_base,omitempty"`
	// mode is the current operating mode of the autoroller.
	Mode *ModeChange `protobuf:"bytes,6,opt,name=mode,proto3" json:"mode,omitempty"`
	// strategy for choosing the next revision to roll.
	Strategy *StrategyChange `protobuf:"bytes,7,opt,name=strategy,proto3" json:"strategy,omitempty"`
	// not_rolled_revisions are the revisions of the Child which have not yet been
	// rolled.
	NotRolledRevisions []*Revision `protobuf:"bytes,8,rep,name=not_rolled_revisions,json=notRolledRevisions,proto3" json:"not_rolled_revisions,omitempty"`
	// current_roll is the active roll CL, if any.
	CurrentRoll *AutoRollCL `protobuf:"bytes,9,opt,name=current_roll,json=currentRoll,proto3" json:"current_roll,omitempty"`
	// last_roll is the previous roll CL.
	LastRoll *AutoRollCL `protobuf:"bytes,10,opt,name=last_roll,json=lastRoll,proto3" json:"last_roll,omitempty"`
	// recent_rolls contains a list of recent roll CLs.
	RecentRolls []*AutoRollCL `protobuf:"bytes,11,rep,name=recent_rolls,json=recentRolls,proto3" json:"recent_rolls,omitempty"`
	// manual_rolls contains a list of recent ManualRolls.
	ManualRolls []*ManualRoll `protobuf:"bytes,12,rep,name=manual_rolls,json=manualRolls,proto3" json:"manual_rolls,omitempty"`
	// error contains a detailed message if the autoroller is in an error state.
	Error string `protobuf:"bytes,13,opt,name=error,proto3" json:"error,omitempty"`
	// throttled_until is the timestamp at which the autoroller will no longer be
	// throttled, if the autoroller is currently throttled.
	ThrottledUntil *timestamppb.Timestamp `protobuf:"bytes,14,opt,name=throttled_until,json=throttledUntil,proto3" json:"throttled_until,omitempty"`
	// cleanup_requested is the most recent request for cleanup of this roller, if
	// any.
	CleanupRequested *CleanupRequest `protobuf:"bytes,15,opt,name=cleanup_requested,json=cleanupRequested,proto3" json:"cleanup_requested,omitempty"`
}

func (x *AutoRollStatus) Reset() {
	*x = AutoRollStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutoRollStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollStatus) ProtoMessage() {}

func (x *AutoRollStatus) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollStatus.ProtoReflect.Descriptor instead.
func (*AutoRollStatus) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{8}
}

func (x *AutoRollStatus) GetMiniStatus() *AutoRollMiniStatus {
	if x != nil {
		return x.MiniStatus
	}
	return nil
}

func (x *AutoRollStatus) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *AutoRollStatus) GetConfig() *AutoRollConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *AutoRollStatus) GetFullHistoryUrl() string {
	if x != nil {
		return x.FullHistoryUrl
	}
	return ""
}

func (x *AutoRollStatus) GetIssueUrlBase() string {
	if x != nil {
		return x.IssueUrlBase
	}
	return ""
}

func (x *AutoRollStatus) GetMode() *ModeChange {
	if x != nil {
		return x.Mode
	}
	return nil
}

func (x *AutoRollStatus) GetStrategy() *StrategyChange {
	if x != nil {
		return x.Strategy
	}
	return nil
}

func (x *AutoRollStatus) GetNotRolledRevisions() []*Revision {
	if x != nil {
		return x.NotRolledRevisions
	}
	return nil
}

func (x *AutoRollStatus) GetCurrentRoll() *AutoRollCL {
	if x != nil {
		return x.CurrentRoll
	}
	return nil
}

func (x *AutoRollStatus) GetLastRoll() *AutoRollCL {
	if x != nil {
		return x.LastRoll
	}
	return nil
}

func (x *AutoRollStatus) GetRecentRolls() []*AutoRollCL {
	if x != nil {
		return x.RecentRolls
	}
	return nil
}

func (x *AutoRollStatus) GetManualRolls() []*ManualRoll {
	if x != nil {
		return x.ManualRolls
	}
	return nil
}

func (x *AutoRollStatus) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *AutoRollStatus) GetThrottledUntil() *timestamppb.Timestamp {
	if x != nil {
		return x.ThrottledUntil
	}
	return nil
}

func (x *AutoRollStatus) GetCleanupRequested() *CleanupRequest {
	if x != nil {
		return x.CleanupRequested
	}
	return nil
}

// GetRollersRequest is a request to GetRollers.
type GetRollersRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *GetRollersRequest) Reset() {
	*x = GetRollersRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetRollersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollersRequest) ProtoMessage() {}

func (x *GetRollersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollersRequest.ProtoReflect.Descriptor instead.
func (*GetRollersRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{9}
}

// GetRollersResponse is a response returned by GetRollers.
type GetRollersResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// rollers contains status information for all known autorollers.
	Rollers []*AutoRollMiniStatus `protobuf:"bytes,1,rep,name=rollers,proto3" json:"rollers,omitempty"`
}

func (x *GetRollersResponse) Reset() {
	*x = GetRollersResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetRollersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollersResponse) ProtoMessage() {}

func (x *GetRollersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollersResponse.ProtoReflect.Descriptor instead.
func (*GetRollersResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{10}
}

func (x *GetRollersResponse) GetRollers() []*AutoRollMiniStatus {
	if x != nil {
		return x.Rollers
	}
	return nil
}

// GetRollsRequest is a request to GetRolls.
type GetRollsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose rolls are to be
	// retrieved.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// cursor is a database-provided cursor used for pagination.
	Cursor string `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
}

func (x *GetRollsRequest) Reset() {
	*x = GetRollsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetRollsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollsRequest) ProtoMessage() {}

func (x *GetRollsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollsRequest.ProtoReflect.Descriptor instead.
func (*GetRollsRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{11}
}

func (x *GetRollsRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *GetRollsRequest) GetCursor() string {
	if x != nil {
		return x.Cursor
	}
	return ""
}

// GetRollsResponse is a response returned by GetRolls.
type GetRollsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// rolls are the rolls retrieved from the database.
	Rolls []*AutoRollCL `protobuf:"bytes,1,rep,name=rolls,proto3" json:"rolls,omitempty"`
	// cursor is a database-provided cursor which can be provided to the next call
	// to GetRolls to load more rolls.
	Cursor string `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
}

func (x *GetRollsResponse) Reset() {
	*x = GetRollsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetRollsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollsResponse) ProtoMessage() {}

func (x *GetRollsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollsResponse.ProtoReflect.Descriptor instead.
func (*GetRollsResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{12}
}

func (x *GetRollsResponse) GetRolls() []*AutoRollCL {
	if x != nil {
		return x.Rolls
	}
	return nil
}

func (x *GetRollsResponse) GetCursor() string {
	if x != nil {
		return x.Cursor
	}
	return ""
}

// GetMiniStatusRequest is a request to GetMiniStatus.
type GetMiniStatusRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose MiniStatus is to
	// be retrieved.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
}

func (x *GetMiniStatusRequest) Reset() {
	*x = GetMiniStatusRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetMiniStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMiniStatusRequest) ProtoMessage() {}

func (x *GetMiniStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMiniStatusRequest.ProtoReflect.Descriptor instead.
func (*GetMiniStatusRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{13}
}

func (x *GetMiniStatusRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// GetMiniStatusResponse is a response returned by GetMiniStatus.
type GetMiniStatusResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status is a subset of status information for the autoroller in question.
	Status *AutoRollMiniStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *GetMiniStatusResponse) Reset() {
	*x = GetMiniStatusResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetMiniStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMiniStatusResponse) ProtoMessage() {}

func (x *GetMiniStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMiniStatusResponse.ProtoReflect.Descriptor instead.
func (*GetMiniStatusResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{14}
}

func (x *GetMiniStatusResponse) GetStatus() *AutoRollMiniStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetStatusRequest is a request to GetStatus.
type GetStatusRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose Status is to be
	// retrieved.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
}

func (x *GetStatusRequest) Reset() {
	*x = GetStatusRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatusRequest) ProtoMessage() {}

func (x *GetStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatusRequest.ProtoReflect.Descriptor instead.
func (*GetStatusRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{15}
}

func (x *GetStatusRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// GetStatusResponse is a response returned by GetStatus.
type GetStatusResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status information about the autoroller in question.
	Status *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *GetStatusResponse) Reset() {
	*x = GetStatusResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatusResponse) ProtoMessage() {}

func (x *GetStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatusResponse.ProtoReflect.Descriptor instead.
func (*GetStatusResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{16}
}

func (x *GetStatusResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// SetModeRequest is a request to SetMode.
type SetModeRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose mode is to be
	// changed.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// mode is the desired mode to set for the given autoroller.
	Mode Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// message describes the reason for changing the mode.
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *SetModeRequest) Reset() {
	*x = SetModeRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetModeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetModeRequest) ProtoMessage() {}

func (x *SetModeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetModeRequest.ProtoReflect.Descriptor instead.
func (*SetModeRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{17}
}

func (x *SetModeRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *SetModeRequest) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *SetModeRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// SetModeResponse is a response returned by SetMode.
type SetModeResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status is the updated status of the autoroller after changing its mode.
	Status *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SetModeResponse) Reset() {
	*x = SetModeResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetModeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetModeResponse) ProtoMessage() {}

func (x *SetModeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetModeResponse.ProtoReflect.Descriptor instead.
func (*SetModeResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{18}
}

func (x *SetModeResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetModeHistoryRequest is a request to GetModeHistory.
type GetModeHistoryRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	Offset   int32  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetModeHistoryRequest) Reset() {
	*x = GetModeHistoryRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetModeHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetModeHistoryRequest) ProtoMessage() {}

func (x *GetModeHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetModeHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetModeHistoryRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{19}
}

func (x *GetModeHistoryRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *GetModeHistoryRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// GetModeHistoryResponse is a response returned by GetModeHistory.
type GetModeHistoryResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	History    []*ModeChange `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
	NextOffset int32         `protobuf:"varint,2,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
}

func (x *GetModeHistoryResponse) Reset() {
	*x = GetModeHistoryResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetModeHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetModeHistoryResponse) ProtoMessage() {}

func (x *GetModeHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetModeHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetModeHistoryResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{20}
}

func (x *GetModeHistoryResponse) GetHistory() []*ModeChange {
	if x != nil {
		return x.History
	}
	return nil
}

func (x *GetModeHistoryResponse) GetNextOffset() int32 {
	if x != nil {
		return x.NextOffset
	}
	return 0
}

// SetStrategyRequest is a request to SetStrategy.
type SetStrategyRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose strategy is to
	// be changed.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// strategy is the desired strategy to set for the given autoroller.
	Strategy Strategy `protobuf:"varint,2,opt,name=strategy,proto3,enum=autoroll.rpc.Strategy" json:"strategy,omitempty"`
	// message describes the reason for changing the strategy.
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *SetStrategyRequest) Reset() {
	*x = SetStrategyRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetStrategyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStrategyRequest) ProtoMessage() {}

func (x *SetStrategyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStrategyRequest.ProtoReflect.Descriptor instead.
func (*SetStrategyRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{21}
}

func (x *SetStrategyRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *SetStrategyRequest) GetStrategy() Strategy {
	if x != nil {
		return x.Strategy
	}
	return Strategy_BATCH
}

func (x *SetStrategyRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// SetStrategyResponse is a response returned by SetStrategy.
type SetStrategyResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status is the updated status of the autoroller after changing its strategy.
	Status *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SetStrategyResponse) Reset() {
	*x = SetStrategyResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetStrategyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStrategyResponse) ProtoMessage() {}

func (x *SetStrategyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStrategyResponse.ProtoReflect.Descriptor instead.
func (*SetStrategyResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{22}
}

func (x *SetStrategyResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetStrategyHistoryRequest is a request to GetStrategyHistory.
type GetStrategyHistoryRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	Offset   int32  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *GetStrategyHistoryRequest) Reset() {
	*x = GetStrategyHistoryRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetStrategyHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStrategyHistoryRequest) ProtoMessage() {}

func (x *GetStrategyHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStrategyHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetStrategyHistoryRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{23}
}

func (x *GetStrategyHistoryRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *GetStrategyHistoryRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// GetStrategyHistoryResponse is a response returned by GetStrategyHistory.
type GetStrategyHistoryResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	History    []*StrategyChange `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
	NextOffset int32             `protobuf:"varint,2,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
}

func (x *GetStrategyHistoryResponse) Reset() {
	*x = GetStrategyHistoryResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetStrategyHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStrategyHistoryResponse) ProtoMessage() {}

func (x *GetStrategyHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStrategyHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetStrategyHistoryResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{24}
}

func (x *GetStrategyHistoryResponse) GetHistory() []*StrategyChange {
	if x != nil {
		return x.History
	}
	return nil
}

func (x *GetStrategyHistoryResponse) GetNextOffset() int32 {
	if x != nil {
		return x.NextOffset
	}
	return 0
}

// CreateManualRollRequest is a request to CreateManualRoll.
type CreateManualRollRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller which should create
	// the manual roll.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// revision is the ID of the revision to be rolled.
	Revision string `protobuf:"bytes,2,opt,name=revision,proto3" json:"revision,omitempty"`
	// dry_run flag controls whether the roll is a dry-run.
	DryRun bool `protobuf:"varint,3,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (x *CreateManualRollRequest) Reset() {
	*x = CreateManualRollRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateManualRollRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateManualRollRequest) ProtoMessage() {}

func (x *CreateManualRollRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateManualRollRequest.ProtoReflect.Descriptor instead.
func (*CreateManualRollRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{25}
}

func (x *CreateManualRollRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *CreateManualRollRequest) GetRevision() string {
	if x != nil {
		return x.Revision
	}
	return ""
}

func (x *CreateManualRollRequest) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

// CreateManualRollResponse is a response returned by CreateManualRoll.
type CreateManualRollResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roll is the manual roll which was created.
	Roll *ManualRoll `protobuf:"bytes,1,opt,name=roll,proto3" json:"roll,omitempty"`
}

func (x *CreateManualRollResponse) Reset() {
	*x = CreateManualRollResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateManualRollResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateManualRollResponse) ProtoMessage() {}

func (x *CreateManualRollResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateManualRollResponse.ProtoReflect.Descriptor instead.
func (*CreateManualRollResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{26}
}

func (x *CreateManualRollResponse) GetRoll() *ManualRoll {
	if x != nil {
		return x.Roll
	}
	return nil
}

// UnthrottleRequest is a request to Unthrottle.
type UnthrottleRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller which should be
	// unthrottled.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
}

func (x *UnthrottleRequest) Reset() {
	*x = UnthrottleRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UnthrottleRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnthrottleRequest) ProtoMessage() {}

func (x *UnthrottleRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnthrottleRequest.ProtoReflect.Descriptor instead.
func (*UnthrottleRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{27}
}

func (x *UnthrottleRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// UnthrottleResponse is a response returned by Unthrottle.
type UnthrottleResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *UnthrottleResponse) Reset() {
	*x = UnthrottleResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UnthrottleResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnthrottleResponse) ProtoMessage() {}

func (x *UnthrottleResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnthrottleResponse.ProtoReflect.Descriptor instead.
func (*UnthrottleResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{28}
}

// AddCleanupRequestRequest is a request to AddCleanupRequest.
type AddCleanupRequestRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller in question.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// justification is the reason that cleanup is being requested.
	Justification string `protobuf:"bytes,2,opt,name=justification,proto3" json:"justification,omitempty"`
}

func (x *AddCleanupRequestRequest) Reset() {
	*x = AddCleanupRequestRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddCleanupRequestRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddCleanupRequestRequest) ProtoMessage() {}

func (x *AddCleanupRequestRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddCleanupRequestRequest.ProtoReflect.Descriptor instead.
func (*AddCleanupRequestRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{29}
}

func (x *AddCleanupRequestRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *AddCleanupRequestRequest) GetJustification() string {
	if x != nil {
		return x.Justification
	}
	return ""
}

// AddCleanupRequestResponse is a response returned by AddCleanupRequest.
type AddCleanupRequestResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status is the updated status of the autoroller.
	Status *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *AddCleanupRequestResponse) Reset() {
	*x = AddCleanupRequestResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddCleanupRequestResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddCleanupRequestResponse) ProtoMessage() {}

func (x *AddCleanupRequestResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddCleanupRequestResponse.ProtoReflect.Descriptor instead.
func (*AddCleanupRequestResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{30}
}

func (x *AddCleanupRequestResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetCleanupHistoryRequest is a request to GetCleanupHistory.
type GetCleanupHistoryRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller in question.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// limit is the maximum number of results to return.
	Limit uint32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (x *GetCleanupHistoryRequest) Reset() {
	*x = GetCleanupHistoryRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetCleanupHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCleanupHistoryRequest) ProtoMessage() {}

func (x *GetCleanupHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCleanupHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetCleanupHistoryRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{31}
}

func (x *GetCleanupHistoryRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *GetCleanupHistoryRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type GetCleanupHistoryResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	History []*CleanupRequest `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
}

func (x *GetCleanupHistoryResponse) Reset() {
	*x = GetCleanupHistoryResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetCleanupHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCleanupHistoryResponse) ProtoMessage() {}

func (x *GetCleanupHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCleanupHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetCleanupHistoryResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{32}
}

func (x *GetCleanupHistoryResponse) GetHistory() []*CleanupRequest {
	if x != nil {
		return x.History
	}
	return nil
}

type CleanupRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// needs_cleanup indicates whether this request wants the roller to be cleaned up.
	NeedsCleanup bool `protobuf:"varint,1,opt,name=needs_cleanup,json=needsCleanup,proto3" json:"needs_cleanup,omitempty"`
	// user is the user who requests the cleanup.
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// timestamp is the time at which cleanup was requested.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// justification is the reason that cleanup was requested.
	Justification string `protobuf:"bytes,4,opt,name=justification,proto3" json:"justification,omitempty"`
}

func (x *CleanupRequest) Reset() {
	*x = CleanupRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CleanupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupRequest) ProtoMessage() {}

func (x *CleanupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupRequest.ProtoReflect.Descriptor instead.
func (*CleanupRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{33}
}

func (x *CleanupRequest) GetNeedsCleanup() bool {
	if x != nil {
		return x.NeedsCleanup
	}
	return false
}

func (x *CleanupRequest) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *CleanupRequest) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *CleanupRequest) GetJustification() string {
	if x != nil {
		return x.Justification
	}
	return ""
}

var File_rpc_proto protoreflect.FileDescriptor

var file_rpc_proto_rawDesc = []byte{
	0x0a, 0x09, 0x72, 0x70, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc0, 0x03, 0x0a, 0x12, 0x41,
	0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1d,
	0x0a, 0x0a, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x09, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1f, 0x0a,
	0x0b, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x26,
	0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x65,
	0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x12, 0x28, 0x0a, 0x10, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
	0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x5f, 0x72, 0x65, 0x76, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x65, 0x76,
	0x12, 0x22, 0x0a, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x5f, 0x72, 0x65,
	0x76, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6c, 0x61, 0x73, 0x74, 0x52, 0x6f, 0x6c,
	0x6c, 0x52, 0x65, 0x76, 0x12, 0x1d, 0x0a, 0x0a, 0x6e, 0x75, 0x6d, 0x5f, 0x66, 0x61, 0x69, 0x6c,
	0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x6e, 0x75, 0x6d, 0x46, 0x61, 0x69,
	0x6c, 0x65, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x65, 0x68, 0x69, 0x6e,
	0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x6e, 0x75, 0x6d, 0x42, 0x65, 0x68, 0x69,
	0x6e, 0x64, 0x12, 0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x5f, 0x0a, 0x1e,
	0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6c, 0x5f,
	0x72, 0x6f, 0x6c, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x0a,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x52, 0x1b, 0x6c, 0x61, 0x73, 0x74, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6c,
	0x52, 0x6f, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0xa8, 0x02,
	0x0a, 0x06, 0x54, 0x72, 0x79, 0x4a, 0x6f, 0x62, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x33, 0x0a, 0x06,
	0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x54, 0x72, 0x79, 0x4a,
	0x6f, 0x62, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x33, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x1b, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63,
	0x2e, 0x54, 0x72, 0x79, 0x4a, 0x6f, 0x62, 0x2e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x06,
	0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x61, 0x74, 0x65,
	0x67, 0x6f, 0x72, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x61, 0x74, 0x65,
	0x67, 0x6f, 0x72, 0x79, 0x22, 0x3d, 0x0a, 0x06, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x0b,
	0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53,
	0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x46, 0x41, 0x49, 0x4c,
	0x55, 0x52, 0x45, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x43, 0x41, 0x4e, 0x43, 0x45, 0x4c, 0x45,
	0x44, 0x10, 0x03, 0x22, 0x33, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x0d, 0x0a,
	0x09, 0x53, 0x43, 0x48, 0x45, 0x44, 0x55, 0x4c, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07,
	0x53, 0x54, 0x41, 0x52, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x4f, 0x4d,
	0x50, 0x4c, 0x45, 0x54, 0x45, 0x44, 0x10, 0x02, 0x22, 0xdf, 0x03, 0x0a, 0x0a, 0x41, 0x75, 0x74,
	0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x4c, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x37, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c,
	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f,
	0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43,
	0x4c, 0x2e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74,
	0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x07, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x6f,
	0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x54, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x6f, 0x6c,
	0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0b, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x46, 0x72, 0x6f, 0x6d, 0x12, 0x34, 0x0a, 0x07,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x65, 0x64, 0x12, 0x36, 0x0a, 0x08, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x52, 0x08, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x12, 0x2f, 0x0a, 0x08, 0x74, 0x72,
	0x79, 0x5f, 0x6a, 0x6f, 0x62, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x54, 0x72, 0x79, 0x4a,
	0x6f, 0x62, 0x52, 0x07, 0x74, 0x72, 0x79, 0x4a, 0x6f, 0x62, 0x73, 0x22, 0x8c, 0x01, 0x0a, 0x06,
	0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x0f, 0x0a, 0x0b, 0x49, 0x4e, 0x5f, 0x50, 0x52, 0x4f,
	0x47, 0x52, 0x45, 0x53, 0x53, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x55, 0x43, 0x43, 0x45,
	0x53, 0x53, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10,
	0x02, 0x12, 0x17, 0x0a, 0x13, 0x44, 0x52, 0x59, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x49, 0x4e, 0x5f,
	0x50, 0x52, 0x4f, 0x47, 0x52, 0x45, 0x53, 0x53, 0x10, 0x03, 0x12, 0x13, 0x0a, 0x0f, 0x44, 0x52,
	0x59, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x10, 0x04, 0x12,
	0x13, 0x0a, 0x0f, 0x44, 0x52, 0x59, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55,
	0x52, 0x45, 0x10, 0x05, 0x12, 0x14, 0x0a, 0x10, 0x48, 0x55, 0x4d, 0x41, 0x4e, 0x5f, 0x49, 0x4e,
	0x54, 0x45, 0x52, 0x56, 0x45, 0x4e, 0x45, 0x44, 0x10, 0x06, 0x22, 0xbf, 0x01, 0x0a, 0x08, 0x52,
	0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x69, 0x73, 0x70, 0x6c,
	0x61, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61,
	0x79, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x04, 0x74,
	0x69, 0x6d, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x25, 0x0a, 0x0e, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64,
	0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x69,
	0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x22, 0xb0, 0x02, 0x0a,
	0x0e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,
	0x24, 0x0a, 0x0e, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x5f, 0x62, 0x75, 0x67, 0x5f, 0x6c, 0x69, 0x6e,
	0x6b, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x42, 0x75,
	0x67, 0x4c, 0x69, 0x6e, 0x6b, 0x12, 0x26, 0x0a, 0x0f, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f,
	0x62, 0x75, 0x67, 0x5f, 0x6c, 0x69, 0x6e, 0x6b, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d,
	0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x42, 0x75, 0x67, 0x4c, 0x69, 0x6e, 0x6b, 0x12, 0x29, 0x0a,
	0x10, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x77, 0x61, 0x74, 0x65, 0x72, 0x66, 0x61, 0x6c,
	0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x57,
	0x61, 0x74, 0x65, 0x72, 0x66, 0x61, 0x6c, 0x6c, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c,
	0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c,
	0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x32, 0x0a, 0x15, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74,
	0x73, 0x5f, 0x6d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x4d, 0x61,
	0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x69, 0x6d,
	0x65, 0x5f, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
	0x74, 0x69, 0x6d, 0x65, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x12, 0x33, 0x0a, 0x0b, 0x76, 0x61,
	0x6c, 0x69, 0x64, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0e, 0x32,
	0x12, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d,
	0x6f, 0x64, 0x65, 0x52, 0x0a, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x73, 0x22,
	0xaf, 0x01, 0x0a, 0x0a, 0x4d, 0x6f, 0x64, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x1b,
	0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x26, 0x0a, 0x04, 0x6d,
	0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x61, 0x75, 0x74, 0x6f,
	0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x04, 0x6d,
	0x6f, 0x64, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x22, 0xbf, 0x01, 0x0a, 0x0e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x43, 0x68,
	0x61, 0x6e, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49,
	0x64, 0x12, 0x32, 0x0a, 0x08, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72,
	0x70, 0x63, 0x2e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x52, 0x08, 0x73, 0x74, 0x72,
	0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x69, 0x6d,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x22, 0x91, 0x04, 0x0a, 0x0a, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f,
	0x6c, 0x6c, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
	0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12,
	0x1a, 0x0a, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x72,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x72, 0x12, 0x37, 0x0a, 0x06, 0x72, 0x65, 0x73,
	0x75, 0x6c, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x61, 0x75, 0x74, 0x6f,
	0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52,
	0x6f, 0x6c, 0x6c, 0x2e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x06, 0x72, 0x65, 0x73, 0x75,
	0x6c, 0x74, 0x12, 0x37, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70,
	0x63, 0x2e, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x2e, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x38, 0x0a, 0x09, 0x74,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79, 0x5f, 0x72,
	0x75, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e,
	0x12, 0x19, 0x0a, 0x08, 0x6e, 0x6f, 0x5f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x0a, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x07, 0x6e, 0x6f, 0x45, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x2e, 0x0a, 0x13, 0x6e,
	0x6f, 0x5f, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x5f, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69,
	0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11, 0x6e, 0x6f, 0x52, 0x65, 0x73, 0x6f,
	0x6c, 0x76, 0x65, 0x52, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x63,
	0x61, 0x6e, 0x61, 0x72, 0x79, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x63, 0x61, 0x6e,
	0x61, 0x72, 0x79, 0x22, 0x2f, 0x0a, 0x06, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x0b, 0x0a,
	0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x46, 0x41,
	0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x55, 0x43, 0x43, 0x45,
	0x53, 0x53, 0x10, 0x02, 0x22, 0x31, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x0b,
	0x0a, 0x07, 0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53,
	0x54, 0x41, 0x52, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x4f, 0x4d, 0x50,
	0x4c, 0x45, 0x54, 0x45, 0x44, 0x10, 0x02, 0x22, 0xb7, 0x06, 0x0a, 0x0e, 0x41, 0x75, 0x74, 0x6f,
	0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x41, 0x0a, 0x0b, 0x6d, 0x69,
	0x6e, 0x69, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x20, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41,
	0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x0a, 0x6d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a,
	0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x34, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x28, 0x0a, 0x10, 0x66,
	0x75, 0x6c, 0x6c, 0x5f, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x75, 0x72, 0x6c, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x66, 0x75, 0x6c, 0x6c, 0x48, 0x69, 0x73, 0x74, 0x6f,
	0x72, 0x79, 0x55, 0x72, 0x6c, 0x12, 0x24, 0x0a, 0x0e, 0x69, 0x73, 0x73, 0x75, 0x65, 0x5f, 0x75,
	0x72, 0x6c, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x69,
	0x73, 0x73, 0x75, 0x65, 0x55, 0x72, 0x6c, 0x42, 0x61, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x04, 0x6d,
	0x6f, 0x64, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f,
	0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x43, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x12, 0x38, 0x0a, 0x08, 0x73, 0x74, 0x72,
	0x61, 0x74, 0x65, 0x67, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75,
	0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x74, 0x72, 0x61, 0x74,
	0x65, 0x67, 0x79, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x08, 0x73, 0x74, 0x72, 0x61, 0x74,
	0x65, 0x67, 0x79, 0x12, 0x48, 0x0a, 0x14, 0x6e, 0x6f, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x65,
	0x64, 0x5f, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x16, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63,
	0x2e, 0x52, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x12, 0x6e, 0x6f, 0x74, 0x52, 0x6f,
	0x6c, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x3b, 0x0a,
	0x0c, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x18, 0x09, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72,
	0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x4c, 0x52, 0x0b, 0x63,
	0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x12, 0x35, 0x0a, 0x09, 0x6c, 0x61,
	0x73, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e,
	0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74,
	0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x4c, 0x52, 0x08, 0x6c, 0x61, 0x73, 0x74, 0x52, 0x6f, 0x6c,
	0x6c, 0x12, 0x3b, 0x0a, 0x0c, 0x72, 0x65, 0x63, 0x65, 0x6e, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c,
	0x73, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f,
	0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43,
	0x4c, 0x52, 0x0b, 0x72, 0x65, 0x63, 0x65, 0x6e, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x73, 0x12, 0x3b,
	0x0a, 0x0c, 0x6d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x73, 0x18, 0x0c,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e,
	0x72, 0x70, 0x63, 0x2e, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x0b,
	0x6d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65,
	0x72, 0x72, 0x6f, 0x72, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f,
	0x72, 0x12, 0x43, 0x0a, 0x0f, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x5f, 0x75,
	0x6e, 0x74, 0x69, 0x6c, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0e, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65,
	0x64, 0x55, 0x6e, 0x74, 0x69, 0x6c, 0x12, 0x49, 0x0a, 0x11, 0x63, 0x6c, 0x65, 0x61, 0x6e, 0x75,
	0x70, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x0f, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63,
	0x2e, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x52,
	0x10, 0x63, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65,
	0x64, 0x22, 0x13, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x50, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c,
	0x6c, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3a, 0x0a, 0x07,
	0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e,
	0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74,
	0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
	0x07, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x22, 0x46, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x52,
	0x6f, 0x6c, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72,
	0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
	0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x75, 0x72, 0x73,
	0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72,
	0x22, 0x5a, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x73, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2e, 0x0a, 0x05, 0x72, 0x6f, 0x6c, 0x6c, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72,
	0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x4c, 0x52, 0x05, 0x72,
	0x6f, 0x6c, 0x6c, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x22, 0x33, 0x0a, 0x14,
	0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49,
	0x64, 0x22, 0x51, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x06, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f,
	0x6c, 0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x22, 0x2f, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c,
	0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c,
	0x6c, 0x65, 0x72, 0x49, 0x64, 0x22, 0x49, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x34, 0x0a, 0x06, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f,
	0x6c, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x22, 0x6f, 0x0a, 0x0e, 0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12,
	0x26, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e,
	0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64,
	0x65, 0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x22, 0x47, 0x0a, 0x0f, 0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x34, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e,
	0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x4c, 0x0a, 0x15, 0x47, 0x65,
	0x74, 0x4d, 0x6f, 0x64, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64,
	0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x6d, 0x0a, 0x16, 0x47, 0x65, 0x74, 0x4d,
	0x6f, 0x64, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x32, 0x0a, 0x07, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72,
	0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x07, 0x68,
	0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x1f, 0x0a, 0x0b, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x6f,
	0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x6e, 0x65, 0x78,
	0x74, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x7f, 0x0a, 0x12, 0x53, 0x65, 0x74, 0x53, 0x74,
	0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a,
	0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x32, 0x0a, 0x08, 0x73, 0x74,
	0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x74, 0x72, 0x61,
	0x74, 0x65, 0x67, 0x79, 0x52, 0x08, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x18,
	0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x4b, 0x0a, 0x13, 0x53, 0x65, 0x74, 0x53,
	0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x34, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41,
	0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x50, 0x0a, 0x19, 0x47, 0x65, 0x74, 0x53, 0x74, 0x72, 0x61,
	0x74, 0x65, 0x67, 0x79, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12,
	0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x75, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x53, 0x74,
	0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c,
	0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x43, 0x68,
	0x61, 0x6e, 0x67, 0x65, 0x52, 0x07, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x1f, 0x0a,
	0x0b, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x0a, 0x6e, 0x65, 0x78, 0x74, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0x6b,
	0x0a, 0x17, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f,
	0x6c, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c,
	0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f,
	0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69,
	0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69,
	0x6f, 0x6e, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79, 0x5f, 0x72, 0x75, 0x6e, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e, 0x22, 0x48, 0x0a, 0x18, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x6c, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52,
	0x04, 0x72, 0x6f, 0x6c, 0x6c, 0x22, 0x30, 0x0a, 0x11, 0x55, 0x6e, 0x74, 0x68, 0x72, 0x6f, 0x74,
	0x74, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f,
	0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72,
	0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x22, 0x14, 0x0a, 0x12, 0x55, 0x6e, 0x74, 0x68, 0x72,
	0x6f, 0x74, 0x74, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x5d, 0x0a,
	0x18, 0x41, 0x64, 0x64, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c,
	0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f,
	0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x24, 0x0a, 0x0d, 0x6a, 0x75, 0x73, 0x74, 0x69, 0x66,
	0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6a,
	0x75, 0x73, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x51, 0x0a, 0x19,
	0x41, 0x64, 0x64, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x34, 0x0a, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f,
	0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c,
	0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22,
	0x4d, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x48, 0x69, 0x73,
	0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72,
	0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
	0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69,
	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x53,
	0x0a, 0x19, 0x47, 0x65, 0x74, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x48, 0x69, 0x73, 0x74,
	0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36, 0x0a, 0x07, 0x68,
	0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x6c, 0x65, 0x61,
	0x6e, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x07, 0x68, 0x69, 0x73, 0x74,
	0x6f, 0x72, 0x79, 0x22, 0xa9, 0x01, 0x0a, 0x0e, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x6e, 0x65, 0x65, 0x64, 0x73, 0x5f,
	0x63, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x6e,
	0x65, 0x65, 0x64, 0x73, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x12, 0x12, 0x0a, 0x04, 0x75,
	0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12,
	0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09,
	0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x24, 0x0a, 0x0d, 0x6a, 0x75, 0x73,
	0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0d, 0x6a, 0x75, 0x73, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2a,
	0x3a, 0x0a, 0x04, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x55, 0x4e, 0x4e, 0x49,
	0x4e, 0x47, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x54, 0x4f, 0x50, 0x50, 0x45, 0x44, 0x10,
	0x01, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x52, 0x59, 0x5f, 0x52, 0x55, 0x4e, 0x10, 0x02, 0x12, 0x0b,
	0x0a, 0x07, 0x4f, 0x46, 0x46, 0x4c, 0x49, 0x4e, 0x45, 0x10, 0x03, 0x2a, 0x2e, 0x0a, 0x08, 0x53,
	0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x09, 0x0a, 0x05, 0x42, 0x41, 0x54, 0x43, 0x48,
	0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x5f, 0x42, 0x41, 0x54, 0x43, 0x48, 0x10, 0x01, 0x12,
	0x0a, 0x0a, 0x06, 0x53, 0x49, 0x4e, 0x47, 0x4c, 0x45, 0x10, 0x02, 0x32, 0xb7, 0x08, 0x0a, 0x0f,
	0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,
	0x64, 0x0a, 0x11, 0x41, 0x64, 0x64, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x26, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e,
	0x72, 0x70, 0x63, 0x2e, 0x41, 0x64, 0x64, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x27, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x64, 0x64, 0x43,
	0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x64, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x43, 0x6c, 0x65, 0x61,
	0x6e, 0x75, 0x70, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x26, 0x2e, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6c, 0x65,
	0x61, 0x6e, 0x75, 0x70, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x27, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70,
	0x63, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x48, 0x69, 0x73, 0x74,
	0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4f, 0x0a, 0x0a, 0x47,
	0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x12, 0x1f, 0x2e, 0x61, 0x75, 0x74, 0x6f,
	0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c,
	0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c,
	0x6c, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x49, 0x0a, 0x08,
	0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x73, 0x12, 0x1d, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72,
	0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x73,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f,
	0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x58, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x4d, 0x69,
	0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x22, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72,
	0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x69, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x4d,
	0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x4c, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1e,
	0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65,
	0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f,
	0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65,
	0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x46, 0x0a, 0x07, 0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x1c, 0x2e, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64,
	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72,
	0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x5b, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x4d, 0x6f,
	0x64, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x23, 0x2e, 0x61, 0x75, 0x74, 0x6f,
	0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65,
	0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24,
	0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65,
	0x74, 0x4d, 0x6f, 0x64, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x52, 0x0a, 0x0b, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72, 0x61, 0x74,
	0x65, 0x67, 0x79, 0x12, 0x20, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72,
	0x70, 0x63, 0x2e, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x67, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x53,
	0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x27,
	0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65,
	0x74, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f,
	0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65,
	0x67, 0x79, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x61, 0x0a, 0x10, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61,
	0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x12, 0x25, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61,
	0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x72, 0x65, 0x61,
	0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4f, 0x0a, 0x0a, 0x55, 0x6e, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74,
	0x6c, 0x65, 0x12, 0x1f, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70,
	0x63, 0x2e, 0x55, 0x6e, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72,
	0x70, 0x63, 0x2e, 0x55, 0x6e, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x23, 0x5a, 0x21, 0x67, 0x6f, 0x2e, 0x73, 0x6b, 0x69, 0x61,
	0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x2f, 0x61, 0x75, 0x74, 0x6f, 0x72,
	0x6f, 0x6c, 0x6c, 0x2f, 0x67, 0x6f, 0x2f, 0x72, 0x70, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x33,
}

var (
	file_rpc_proto_rawDescOnce sync.Once
	file_rpc_proto_rawDescData = file_rpc_proto_rawDesc
)

func file_rpc_proto_rawDescGZIP() []byte {
	file_rpc_proto_rawDescOnce.Do(func() {
		file_rpc_proto_rawDescData = protoimpl.X.CompressGZIP(file_rpc_proto_rawDescData)
	})
	return file_rpc_proto_rawDescData
}

var file_rpc_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_rpc_proto_msgTypes = make([]protoimpl.MessageInfo, 34)
var file_rpc_proto_goTypes = []interface{}{
	(Mode)(0),                          // 0: autoroll.rpc.Mode
	(Strategy)(0),                      // 1: autoroll.rpc.Strategy
	(TryJob_Result)(0),                 // 2: autoroll.rpc.TryJob.Result
	(TryJob_Status)(0),                 // 3: autoroll.rpc.TryJob.Status
	(AutoRollCL_Result)(0),             // 4: autoroll.rpc.AutoRollCL.Result
	(ManualRoll_Result)(0),             // 5: autoroll.rpc.ManualRoll.Result
	(ManualRoll_Status)(0),             // 6: autoroll.rpc.ManualRoll.Status
	(*AutoRollMiniStatus)(nil),         // 7: autoroll.rpc.AutoRollMiniStatus
	(*TryJob)(nil),                     // 8: autoroll.rpc.TryJob
	(*AutoRollCL)(nil),                 // 9: autoroll.rpc.AutoRollCL
	(*Revision)(nil),                   // 10: autoroll.rpc.Revision
	(*AutoRollConfig)(nil),             // 11: autoroll.rpc.AutoRollConfig
	(*ModeChange)(nil),                 // 12: autoroll.rpc.ModeChange
	(*StrategyChange)(nil),             // 13: autoroll.rpc.StrategyChange
	(*ManualRoll)(nil),                 // 14: autoroll.rpc.ManualRoll
	(*AutoRollStatus)(nil),             // 15: autoroll.rpc.AutoRollStatus
	(*GetRollersRequest)(nil),          // 16: autoroll.rpc.GetRollersRequest
	(*GetRollersResponse)(nil),         // 17: autoroll.rpc.GetRollersResponse
	(*GetRollsRequest)(nil),            // 18: autoroll.rpc.GetRollsRequest
	(*GetRollsResponse)(nil),           // 19: autoroll.rpc.GetRollsResponse
	(*GetMiniStatusRequest)(nil),       // 20: autoroll.rpc.GetMiniStatusRequest
	(*GetMiniStatusResponse)(nil),      // 21: autoroll.rpc.GetMiniStatusResponse
	(*GetStatusRequest)(nil),           // 22: autoroll.rpc.GetStatusRequest
	(*GetStatusResponse)(nil),          // 23: autoroll.rpc.GetStatusResponse
	(*SetModeRequest)(nil),             // 24: autoroll.rpc.SetModeRequest
	(*SetModeResponse)(nil),            // 25: autoroll.rpc.SetModeResponse
	(*GetModeHistoryRequest)(nil),      // 26: autoroll.rpc.GetModeHistoryRequest
	(*GetModeHistoryResponse)(nil),     // 27: autoroll.rpc.GetModeHistoryResponse
	(*SetStrategyRequest)(nil),         // 28: autoroll.rpc.SetStrategyRequest
	(*SetStrategyResponse)(nil),        // 29: autoroll.rpc.SetStrategyResponse
	(*GetStrategyHistoryRequest)(nil),  // 30: autoroll.rpc.GetStrategyHistoryRequest
	(*GetStrategyHistoryResponse)(nil), // 31: autoroll.rpc.GetStrategyHistoryResponse
	(*CreateManualRollRequest)(nil),    // 32: autoroll.rpc.CreateManualRollRequest
	(*CreateManualRollResponse)(nil),   // 33: autoroll.rpc.CreateManualRollResponse
	(*UnthrottleRequest)(nil),          // 34: autoroll.rpc.UnthrottleRequest
	(*UnthrottleResponse)(nil),         // 35: autoroll.rpc.UnthrottleResponse
	(*AddCleanupRequestRequest)(nil),   // 36: autoroll.rpc.AddCleanupRequestRequest
	(*AddCleanupRequestResponse)(nil),  // 37: autoroll.rpc.AddCleanupRequestResponse
	(*GetCleanupHistoryRequest)(nil),   // 38: autoroll.rpc.GetCleanupHistoryRequest
	(*GetCleanupHistoryResponse)(nil),  // 39: autoroll.rpc.GetCleanupHistoryResponse
	(*CleanupRequest)(nil),             // 40: autoroll.rpc.CleanupRequest
	(*timestamppb.Timestamp)(nil),      // 41: google.protobuf.Timestamp
}
var file_rpc_proto_depIdxs = []int32{
	0,  // 0: autoroll.rpc.AutoRollMiniStatus.mode:type_name -> autoroll.rpc.Mode
	41, // 1: autoroll.rpc.AutoRollMiniStatus.timestamp:type_name -> google.protobuf.Timestamp
	41, // 2: autoroll.rpc.AutoRollMiniStatus.last_successful_roll_timestamp:type_name -> google.protobuf.Timestamp
	3,  // 3: autoroll.rpc.TryJob.status:type_name -> autoroll.rpc.TryJob.Status
	2,  // 4: autoroll.rpc.TryJob.result:type_name -> autoroll.rpc.TryJob.Result
	4,  // 5: autoroll.rpc.AutoRollCL.result:type_name -> autoroll.rpc.AutoRollCL.Result
	41, // 6: autoroll.rpc.AutoRollCL.created:type_name -> google.protobuf.Timestamp
	41, // 7: autoroll.rpc.AutoRollCL.modified:type_name -> google.protobuf.Timestamp
	8,  // 8: autoroll.rpc.AutoRollCL.try_jobs:type_name -> autoroll.rpc.TryJob
	41, // 9: autoroll.rpc.Revision.time:type_name -> google.protobuf.Timestamp
	0,  // 10: autoroll.rpc.AutoRollConfig.valid_modes:type_name -> autoroll.rpc.Mode
	0,  // 11: autoroll.rpc.ModeChange.mode:type_name -> autoroll.rpc.Mode
	41, // 12: autoroll.rpc.ModeChange.time:type_name -> google.protobuf.Timestamp
	1,  // 13: autoroll.rpc.StrategyChange.strategy:type_name -> autoroll.rpc.Strategy
	41, // 14: autoroll.rpc.StrategyChange.time:type_name -> google.protobuf.Timestamp
	5,  // 15: autoroll.rpc.ManualRoll.result:type_name -> autoroll.rpc.ManualRoll.Result
	6,  // 16: autoroll.rpc.ManualRoll.status:type_name -> autoroll.rpc.ManualRoll.Status
	41, // 17: autoroll.rpc.ManualRoll.timestamp:type_name -> google.protobuf.Timestamp
	7,  // 18: autoroll.rpc.AutoRollStatus.mini_status:type_name -> autoroll.rpc.AutoRollMiniStatus
	11, // 19: autoroll.rpc.AutoRollStatus.config:type_name -> autoroll.rpc.AutoRollConfig
	12, // 20: autoroll.rpc.AutoRollStatus.mode:type_name -> autoroll.rpc.ModeChange
	13, // 21: autoroll.rpc.AutoRollStatus.strategy:type_name -> autoroll.rpc.StrategyChange
	10, // 22: autoroll.rpc.AutoRollStatus.not_rolled_revisions:type_name -> autoroll.rpc.Revision
	9,  // 23: autoroll.rpc.AutoRollStatus.current_roll:type_name -> autoroll.rpc.AutoRollCL
	9,  // 24: autoroll.rpc.AutoRollStatus.last_roll:type_name -> autoroll.rpc.AutoRollCL
	9,  // 25: autoroll.rpc.AutoRollStatus.recent_rolls:type_name -> autoroll.rpc.AutoRollCL
	14, // 26: autoroll.rpc.AutoRollStatus.manual_rolls:type_name -> autoroll.rpc.ManualRoll
	41, // 27: autoroll.rpc.AutoRollStatus.throttled_until:type_name -> google.protobuf.Timestamp
	40, // 28: autoroll.rpc.AutoRollStatus.cleanup_requested:type_name -> autoroll.rpc.CleanupRequest
	7,  // 29: autoroll.rpc.GetRollersResponse.rollers:type_name -> autoroll.rpc.AutoRollMiniStatus
	9,  // 30: autoroll.rpc.GetRollsResponse.rolls:type_name -> autoroll.rpc.AutoRollCL
	7,  // 31: autoroll.rpc.GetMiniStatusResponse.status:type_name -> autoroll.rpc.AutoRollMiniStatus
	15, // 32: autoroll.rpc.GetStatusResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	0,  // 33: autoroll.rpc.SetModeRequest.mode:type_name -> autoroll.rpc.Mode
	15, // 34: autoroll.rpc.SetModeResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	12, // 35: autoroll.rpc.GetModeHistoryResponse.history:type_name -> autoroll.rpc.ModeChange
	1,  // 36: autoroll.rpc.SetStrategyRequest.strategy:type_name -> autoroll.rpc.Strategy
	15, // 37: autoroll.rpc.SetStrategyResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	13, // 38: autoroll.rpc.GetStrategyHistoryResponse.history:type_name -> autoroll.rpc.StrategyChange
	14, // 39: autoroll.rpc.CreateManualRollResponse.roll:type_name -> autoroll.rpc.ManualRoll
	15, // 40: autoroll.rpc.AddCleanupRequestResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	40, // 41: autoroll.rpc.GetCleanupHistoryResponse.history:type_name -> autoroll.rpc.CleanupRequest
	41, // 42: autoroll.rpc.CleanupRequest.timestamp:type_name -> google.protobuf.Timestamp
	36, // 43: autoroll.rpc.AutoRollService.AddCleanupRequest:input_type -> autoroll.rpc.AddCleanupRequestRequest
	38, // 44: autoroll.rpc.AutoRollService.GetCleanupHistory:input_type -> autoroll.rpc.GetCleanupHistoryRequest
	16, // 45: autoroll.rpc.AutoRollService.GetRollers:input_type -> autoroll.rpc.GetRollersRequest
	18, // 46: autoroll.rpc.AutoRollService.GetRolls:input_type -> autoroll.rpc.GetRollsRequest
	20, // 47: autoroll.rpc.AutoRollService.GetMiniStatus:input_type -> autoroll.rpc.GetMiniStatusRequest
	22, // 48: autoroll.rpc.AutoRollService.GetStatus:input_type -> autoroll.rpc.GetStatusRequest
	24, // 49: autoroll.rpc.AutoRollService.SetMode:input_type -> autoroll.rpc.SetModeRequest
	26, // 50: autoroll.rpc.AutoRollService.GetModeHistory:input_type -> autoroll.rpc.GetModeHistoryRequest
	28, // 51: autoroll.rpc.AutoRollService.SetStrategy:input_type -> autoroll.rpc.SetStrategyRequest
	30, // 52: autoroll.rpc.AutoRollService.GetStrategyHistory:input_type -> autoroll.rpc.GetStrategyHistoryRequest
	32, // 53: autoroll.rpc.AutoRollService.CreateManualRoll:input_type -> autoroll.rpc.CreateManualRollRequest
	34, // 54: autoroll.rpc.AutoRollService.Unthrottle:input_type -> autoroll.rpc.UnthrottleRequest
	37, // 55: autoroll.rpc.AutoRollService.AddCleanupRequest:output_type -> autoroll.rpc.AddCleanupRequestResponse
	39, // 56: autoroll.rpc.AutoRollService.GetCleanupHistory:output_type -> autoroll.rpc.GetCleanupHistoryResponse
	17, // 57: autoroll.rpc.AutoRollService.GetRollers:output_type -> autoroll.rpc.GetRollersResponse
	19, // 58: autoroll.rpc.AutoRollService.GetRolls:output_type -> autoroll.rpc.GetRollsResponse
	21, // 59: autoroll.rpc.AutoRollService.GetMiniStatus:output_type -> autoroll.rpc.GetMiniStatusResponse
	23, // 60: autoroll.rpc.AutoRollService.GetStatus:output_type -> autoroll.rpc.GetStatusResponse
	25, // 61: autoroll.rpc.AutoRollService.SetMode:output_type -> autoroll.rpc.SetModeResponse
	27, // 62: autoroll.rpc.AutoRollService.GetModeHistory:output_type -> autoroll.rpc.GetModeHistoryResponse
	29, // 63: autoroll.rpc.AutoRollService.SetStrategy:output_type -> autoroll.rpc.SetStrategyResponse
	31, // 64: autoroll.rpc.AutoRollService.GetStrategyHistory:output_type -> autoroll.rpc.GetStrategyHistoryResponse
	33, // 65: autoroll.rpc.AutoRollService.CreateManualRoll:output_type -> autoroll.rpc.CreateManualRollResponse
	35, // 66: autoroll.rpc.AutoRollService.Unthrottle:output_type -> autoroll.rpc.UnthrottleResponse
	55, // [55:67] is the sub-list for method output_type
	43, // [43:55] is the sub-list for method input_type
	43, // [43:43] is the sub-list for extension type_name
	43, // [43:43] is the sub-list for extension extendee
	0,  // [0:43] is the sub-list for field type_name
}

func init() { file_rpc_proto_init() }
func file_rpc_proto_init() {
	if File_rpc_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_rpc_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutoRollMiniStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TryJob); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutoRollCL); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Revision); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutoRollConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ModeChange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StrategyChange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ManualRoll); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutoRollStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetRollersRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetRollersResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetRollsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetRollsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetMiniStatusRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetMiniStatusResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetStatusRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetStatusResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetModeRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetModeResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetModeHistoryRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetModeHistoryResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetStrategyRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetStrategyResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetStrategyHistoryRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetStrategyHistoryResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateManualRollRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateManualRollResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UnthrottleRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UnthrottleResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddCleanupRequestRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddCleanupRequestResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetCleanupHistoryRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetCleanupHistoryResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CleanupRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_rpc_proto_rawDesc,
			NumEnums:      7,
			NumMessages:   34,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_rpc_proto_goTypes,
		DependencyIndexes: file_rpc_proto_depIdxs,
		EnumInfos:         file_rpc_proto_enumTypes,
		MessageInfos:      file_rpc_proto_msgTypes,
	}.Build()
	File_rpc_proto = out.File
	file_rpc_proto_rawDesc = nil
	file_rpc_proto_goTypes = nil
	file_rpc_proto_depIdxs = nil
}
