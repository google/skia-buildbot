// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.3.0
// source: rpc.proto

package rpc

import (
	reflect "reflect"
	sync "sync"

	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// Mode describes the valid operating modes of an autoroller.
// These must be kept in sync with autoroll/go/modes/modes.go.
type Mode int32

const (
	// RUNNING is the typical operating mode of the autoroller. It will upload and
	// land CLs as new revisions appear in the Child.
	Mode_RUNNING Mode = 0
	// STOPPED prevents the autoroller from uploading any CLs.
	Mode_STOPPED Mode = 1
	// DRY_RUN is similar to RUNNING but does not land the roll CLs after the
	// commit queue finishes. Instead, the active roll is left open until new
	// revisions appear in the child, at which point the roll is closed and a new
	// one is uploaded.
	Mode_DRY_RUN Mode = 2
)

// Enum value maps for Mode.
var (
	Mode_name = map[int32]string{
		0: "RUNNING",
		1: "STOPPED",
		2: "DRY_RUN",
	}
	Mode_value = map[string]int32{
		"RUNNING": 0,
		"STOPPED": 1,
		"DRY_RUN": 2,
	}
)

func (x Mode) Enum() *Mode {
	p := new(Mode)
	*p = x
	return p
}

func (x Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[0].Descriptor()
}

func (Mode) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[0]
}

func (x Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Mode.Descriptor instead.
func (Mode) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{0}
}

// Strategy describes the valid strategies for choosing the next revision to
// roll. These must be kept in sync with autoroll/go/strategy/strategies.go.
type Strategy int32

const (
	// BATCH indicates that all not-yet-rolled revisions should be rolled in a
	// single CL.
	Strategy_BATCH Strategy = 0
	// N_BATCH is similar to BATCH but puts a limit on the number of revisions in
	// a single CL.
	Strategy_N_BATCH Strategy = 1
	// SINGLE indicates that a single revision is rolled in each CL.
	Strategy_SINGLE Strategy = 2
)

// Enum value maps for Strategy.
var (
	Strategy_name = map[int32]string{
		0: "BATCH",
		1: "N_BATCH",
		2: "SINGLE",
	}
	Strategy_value = map[string]int32{
		"BATCH":   0,
		"N_BATCH": 1,
		"SINGLE":  2,
	}
)

func (x Strategy) Enum() *Strategy {
	p := new(Strategy)
	*p = x
	return p
}

func (x Strategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Strategy) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[1].Descriptor()
}

func (Strategy) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[1]
}

func (x Strategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Strategy.Descriptor instead.
func (Strategy) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1}
}

// Result describes the possible results for a TryJob.
// These must be kept in sync with go/autoroll/autoroll.go.
type TryJob_Result int32

const (
	// UNKNOWN indicates that the result of the TryJob is unknown, ie. it has
	// not yet finished.
	TryJob_UNKNOWN TryJob_Result = 0
	// SUCCESS indicates that that TryJob completed successfully.
	TryJob_SUCCESS TryJob_Result = 1
	// FAILURE indicates that that TryJob failed.
	TryJob_FAILURE TryJob_Result = 2
	// CANCELED indicates that that TryJob was canceled.
	TryJob_CANCELED TryJob_Result = 3
)

// Enum value maps for TryJob_Result.
var (
	TryJob_Result_name = map[int32]string{
		0: "UNKNOWN",
		1: "SUCCESS",
		2: "FAILURE",
		3: "CANCELED",
	}
	TryJob_Result_value = map[string]int32{
		"UNKNOWN":  0,
		"SUCCESS":  1,
		"FAILURE":  2,
		"CANCELED": 3,
	}
)

func (x TryJob_Result) Enum() *TryJob_Result {
	p := new(TryJob_Result)
	*p = x
	return p
}

func (x TryJob_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TryJob_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[2].Descriptor()
}

func (TryJob_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[2]
}

func (x TryJob_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TryJob_Result.Descriptor instead.
func (TryJob_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1, 0}
}

// Status describes the lifecycle states of a TryJob.
// These must be kept in sync with go/autoroll/autoroll.go.
type TryJob_Status int32

const (
	// SCHEDULED indicates that the TryJob has been scheduled but has not yet
	// started.
	TryJob_SCHEDULED TryJob_Status = 0
	// STARTED indicates that the TryJob is currently running.
	TryJob_STARTED TryJob_Status = 1
	// COMPLETED indicates that the TryJob is finishes.
	TryJob_COMPLETED TryJob_Status = 2
)

// Enum value maps for TryJob_Status.
var (
	TryJob_Status_name = map[int32]string{
		0: "SCHEDULED",
		1: "STARTED",
		2: "COMPLETED",
	}
	TryJob_Status_value = map[string]int32{
		"SCHEDULED": 0,
		"STARTED":   1,
		"COMPLETED": 2,
	}
)

func (x TryJob_Status) Enum() *TryJob_Status {
	p := new(TryJob_Status)
	*p = x
	return p
}

func (x TryJob_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TryJob_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[3].Descriptor()
}

func (TryJob_Status) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[3]
}

func (x TryJob_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TryJob_Status.Descriptor instead.
func (TryJob_Status) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1, 1}
}

// Result describes the possible results for an AutoRollCL.
type AutoRollCL_Result int32

const (
	// IN_PROGRESS indicates that the commit queue is still running for this
	// AutoRollCL.
	AutoRollCL_IN_PROGRESS AutoRollCL_Result = 0
	// SUCCESS indicates that this AutoRollCL landed successfully.
	AutoRollCL_SUCCESS AutoRollCL_Result = 1
	// FAILURE indicates that the commit queue failed for  this AutoRollCL.
	AutoRollCL_FAILURE AutoRollCL_Result = 2
	// DRY_RUN_IN_PROGRESS indicates that the commit queue dry run is still
	// running for this AutoRollCL.
	AutoRollCL_DRY_RUN_IN_PROGRESS AutoRollCL_Result = 3
	// DRY_RUN_SUCCESS indicates that the commit queue dry run succeeded for
	// this AutoRollCL.
	AutoRollCL_DRY_RUN_SUCCESS AutoRollCL_Result = 4
	// DRY_RUN_FAILURE indicates that the commit queue dry run failed for this
	// AutoRollCL.
	AutoRollCL_DRY_RUN_FAILURE AutoRollCL_Result = 5
)

// Enum value maps for AutoRollCL_Result.
var (
	AutoRollCL_Result_name = map[int32]string{
		0: "IN_PROGRESS",
		1: "SUCCESS",
		2: "FAILURE",
		3: "DRY_RUN_IN_PROGRESS",
		4: "DRY_RUN_SUCCESS",
		5: "DRY_RUN_FAILURE",
	}
	AutoRollCL_Result_value = map[string]int32{
		"IN_PROGRESS":         0,
		"SUCCESS":             1,
		"FAILURE":             2,
		"DRY_RUN_IN_PROGRESS": 3,
		"DRY_RUN_SUCCESS":     4,
		"DRY_RUN_FAILURE":     5,
	}
)

func (x AutoRollCL_Result) Enum() *AutoRollCL_Result {
	p := new(AutoRollCL_Result)
	*p = x
	return p
}

func (x AutoRollCL_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AutoRollCL_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[4].Descriptor()
}

func (AutoRollCL_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[4]
}

func (x AutoRollCL_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AutoRollCL_Result.Descriptor instead.
func (AutoRollCL_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{2, 0}
}

// Result describes the possible results for a manual roll.
// These must be kept in sync with autoroll/go/manual/db.go.
type ManualRoll_Result int32

const (
	// UNKNOWN indicates that the result of the ManualRoll is unknown, ie. it
	// has not yet finished.
	ManualRoll_UNKNOWN ManualRoll_Result = 0
	// FAILURE indicates that the ManualRoll has failed.
	ManualRoll_FAILURE ManualRoll_Result = 1
	// SUCCESS indicates that the ManualRoll landed successfully.
	ManualRoll_SUCCESS ManualRoll_Result = 2
)

// Enum value maps for ManualRoll_Result.
var (
	ManualRoll_Result_name = map[int32]string{
		0: "UNKNOWN",
		1: "FAILURE",
		2: "SUCCESS",
	}
	ManualRoll_Result_value = map[string]int32{
		"UNKNOWN": 0,
		"FAILURE": 1,
		"SUCCESS": 2,
	}
)

func (x ManualRoll_Result) Enum() *ManualRoll_Result {
	p := new(ManualRoll_Result)
	*p = x
	return p
}

func (x ManualRoll_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ManualRoll_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[5].Descriptor()
}

func (ManualRoll_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[5]
}

func (x ManualRoll_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ManualRoll_Result.Descriptor instead.
func (ManualRoll_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7, 0}
}

// Status describes the lifecycle states of a manual roll.
// These must be kept in sync with autoroll/go/manual/db.go.
type ManualRoll_Status int32

const (
	// PENDING indicates that the ManualRoll has been requested but no CL has
	// been uploaded.
	ManualRoll_PENDING ManualRoll_Status = 0
	// STARTED indicates that a CL has been uploaded for this ManualRoll.
	ManualRoll_STARTED ManualRoll_Status = 1
	// COMPLETED indicates that the ManualRoll has finished and either landed
	// successfully or failed.
	ManualRoll_COMPLETED ManualRoll_Status = 2
)

// Enum value maps for ManualRoll_Status.
var (
	ManualRoll_Status_name = map[int32]string{
		0: "PENDING",
		1: "STARTED",
		2: "COMPLETED",
	}
	ManualRoll_Status_value = map[string]int32{
		"PENDING":   0,
		"STARTED":   1,
		"COMPLETED": 2,
	}
)

func (x ManualRoll_Status) Enum() *ManualRoll_Status {
	p := new(ManualRoll_Status)
	*p = x
	return p
}

func (x ManualRoll_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ManualRoll_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[6].Descriptor()
}

func (ManualRoll_Status) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[6]
}

func (x ManualRoll_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ManualRoll_Status.Descriptor instead.
func (ManualRoll_Status) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7, 1}
}

// AutoRollMiniStatus contains a subset of the information of AutoRollStatus.
type AutoRollMiniStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique ID for this roller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// child_name is the display name of the child.
	ChildName string `protobuf:"bytes,2,opt,name=child_name,json=childName,proto3" json:"child_name,omitempty"`
	// parent_name is the display name of the parent.
	ParentName string `protobuf:"bytes,3,opt,name=parent_name,json=parentName,proto3" json:"parent_name,omitempty"`
	// mode is the currently-set operating mode of the roller.
	Mode Mode `protobuf:"varint,4,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// current_roll_rev is the ID of the child revision which is being rolled in
	// the active roll CL.
	CurrentRollRev string `protobuf:"bytes,5,opt,name=current_roll_rev,json=currentRollRev,proto3" json:"current_roll_rev,omitempty"`
	// last_roll_rev is the ID of the child revision which is currently pinned by
	// the parent.
	LastRollRev string `protobuf:"bytes,6,opt,name=last_roll_rev,json=lastRollRev,proto3" json:"last_roll_rev,omitempty"`
	// num_failed is the number of consecutive roll failures.
	NumFailed int32 `protobuf:"varint,7,opt,name=num_failed,json=numFailed,proto3" json:"num_failed,omitempty"`
	// num_behind is the number of not-yet-rolled revisions.
	NumBehind int32 `protobuf:"varint,8,opt,name=num_behind,json=numBehind,proto3" json:"num_behind,omitempty"`
}

func (x *AutoRollMiniStatus) Reset() {
	*x = AutoRollMiniStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutoRollMiniStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollMiniStatus) ProtoMessage() {}

func (x *AutoRollMiniStatus) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollMiniStatus.ProtoReflect.Descriptor instead.
func (*AutoRollMiniStatus) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{0}
}

func (x *AutoRollMiniStatus) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *AutoRollMiniStatus) GetChildName() string {
	if x != nil {
		return x.ChildName
	}
	return ""
}

func (x *AutoRollMiniStatus) GetParentName() string {
	if x != nil {
		return x.ParentName
	}
	return ""
}

func (x *AutoRollMiniStatus) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *AutoRollMiniStatus) GetCurrentRollRev() string {
	if x != nil {
		return x.CurrentRollRev
	}
	return ""
}

func (x *AutoRollMiniStatus) GetLastRollRev() string {
	if x != nil {
		return x.LastRollRev
	}
	return ""
}

func (x *AutoRollMiniStatus) GetNumFailed() int32 {
	if x != nil {
		return x.NumFailed
	}
	return 0
}

func (x *AutoRollMiniStatus) GetNumBehind() int32 {
	if x != nil {
		return x.NumBehind
	}
	return 0
}

type TryJob struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// name of the TryJob.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// status of the TryJob.
	Status TryJob_Status `protobuf:"varint,2,opt,name=status,proto3,enum=autoroll.rpc.TryJob_Status" json:"status,omitempty"`
	// result of the TryJob.
	Result TryJob_Result `protobuf:"varint,3,opt,name=result,proto3,enum=autoroll.rpc.TryJob_Result" json:"result,omitempty"`
	// url where more details can be found about the TryJob.
	Url string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	// category of the TryJob, eg. "cq".
	Category string `protobuf:"bytes,5,opt,name=category,proto3" json:"category,omitempty"`
}

func (x *TryJob) Reset() {
	*x = TryJob{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TryJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TryJob) ProtoMessage() {}

func (x *TryJob) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TryJob.ProtoReflect.Descriptor instead.
func (*TryJob) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1}
}

func (x *TryJob) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TryJob) GetStatus() TryJob_Status {
	if x != nil {
		return x.Status
	}
	return TryJob_SCHEDULED
}

func (x *TryJob) GetResult() TryJob_Result {
	if x != nil {
		return x.Result
	}
	return TryJob_UNKNOWN
}

func (x *TryJob) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *TryJob) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

// AutoRoll CL describes a CL uploaded by the autoroller.
type AutoRollCL struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier for the CL.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// result of the AutoRollCL.
	Result AutoRollCL_Result `protobuf:"varint,2,opt,name=result,proto3,enum=autoroll.rpc.AutoRollCL_Result" json:"result,omitempty"`
	// subject line of the commit message of the AutoRollCL.
	Subject string `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
	// rolling_to is the ID of the revision being rolled.
	RollingTo string `protobuf:"bytes,4,opt,name=rolling_to,json=rollingTo,proto3" json:"rolling_to,omitempty"`
	// rolling_from is the ID of the currently-pinned revision.
	RollingFrom string `protobuf:"bytes,5,opt,name=rolling_from,json=rollingFrom,proto3" json:"rolling_from,omitempty"`
	// created is the timestamp at which the AutoRollCL was created.
	Created *timestamp.Timestamp `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	// created is the timestamp at which the AutoRollCL was last modified.
	Modified *timestamp.Timestamp `protobuf:"bytes,7,opt,name=modified,proto3" json:"modified,omitempty"`
	// try_jobs contains results of any try jobs for the AutoRollCL.
	TryJobs []*TryJob `protobuf:"bytes,8,rep,name=try_jobs,json=tryJobs,proto3" json:"try_jobs,omitempty"`
}

func (x *AutoRollCL) Reset() {
	*x = AutoRollCL{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutoRollCL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollCL) ProtoMessage() {}

func (x *AutoRollCL) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollCL.ProtoReflect.Descriptor instead.
func (*AutoRollCL) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{2}
}

func (x *AutoRollCL) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AutoRollCL) GetResult() AutoRollCL_Result {
	if x != nil {
		return x.Result
	}
	return AutoRollCL_IN_PROGRESS
}

func (x *AutoRollCL) GetSubject() string {
	if x != nil {
		return x.Subject
	}
	return ""
}

func (x *AutoRollCL) GetRollingTo() string {
	if x != nil {
		return x.RollingTo
	}
	return ""
}

func (x *AutoRollCL) GetRollingFrom() string {
	if x != nil {
		return x.RollingFrom
	}
	return ""
}

func (x *AutoRollCL) GetCreated() *timestamp.Timestamp {
	if x != nil {
		return x.Created
	}
	return nil
}

func (x *AutoRollCL) GetModified() *timestamp.Timestamp {
	if x != nil {
		return x.Modified
	}
	return nil
}

func (x *AutoRollCL) GetTryJobs() []*TryJob {
	if x != nil {
		return x.TryJobs
	}
	return nil
}

// Revision describes a single revision in a given Child. This may be a Git
// commit, CIPD package instance, a file uploaded to GCS, etc.
type Revision struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier for the Revision.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// display is a human-friendly display name for the Revision.
	Display string `protobuf:"bytes,2,opt,name=display,proto3" json:"display,omitempty"`
	// description is a longer description of the Revision.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// time is the timestamp at which the Revision was created.
	Time *timestamp.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// url where more details can be found about the Revision.
	Url string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
}

func (x *Revision) Reset() {
	*x = Revision{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Revision) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Revision) ProtoMessage() {}

func (x *Revision) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Revision.ProtoReflect.Descriptor instead.
func (*Revision) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{3}
}

func (x *Revision) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Revision) GetDisplay() string {
	if x != nil {
		return x.Display
	}
	return ""
}

func (x *Revision) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Revision) GetTime() *timestamp.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *Revision) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

// AutoRollConfig describes the configuration for a roller.
type AutoRollConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// child_bug_link is a link to file a bug for the child project.
	ChildBugLink string `protobuf:"bytes,5,opt,name=child_bug_link,json=childBugLink,proto3" json:"child_bug_link,omitempty"`
	// parent_bug_link is a link to file a bug for the parent project.
	ParentBugLink string `protobuf:"bytes,6,opt,name=parent_bug_link,json=parentBugLink,proto3" json:"parent_bug_link,omitempty"`
	// parent_waterfall is the URL of the CI display for the parent repo.
	ParentWaterfall string `protobuf:"bytes,1,opt,name=parent_waterfall,json=parentWaterfall,proto3" json:"parent_waterfall,omitempty"`
	// roller_id is the unique identifier for the roller.
	RollerId string `protobuf:"bytes,2,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// supports_manual_rolls indicates whether this autoroller supports manually-
	// triggered rolls.
	SupportsManualRolls bool `protobuf:"varint,3,opt,name=supports_manual_rolls,json=supportsManualRolls,proto3" json:"supports_manual_rolls,omitempty"`
	// time_window describes the limitations, if any, on when the autoroller is
	// allowed to upload roll CLs.
	TimeWindow string `protobuf:"bytes,4,opt,name=time_window,json=timeWindow,proto3" json:"time_window,omitempty"`
}

func (x *AutoRollConfig) Reset() {
	*x = AutoRollConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutoRollConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollConfig) ProtoMessage() {}

func (x *AutoRollConfig) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollConfig.ProtoReflect.Descriptor instead.
func (*AutoRollConfig) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{4}
}

func (x *AutoRollConfig) GetChildBugLink() string {
	if x != nil {
		return x.ChildBugLink
	}
	return ""
}

func (x *AutoRollConfig) GetParentBugLink() string {
	if x != nil {
		return x.ParentBugLink
	}
	return ""
}

func (x *AutoRollConfig) GetParentWaterfall() string {
	if x != nil {
		return x.ParentWaterfall
	}
	return ""
}

func (x *AutoRollConfig) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *AutoRollConfig) GetSupportsManualRolls() bool {
	if x != nil {
		return x.SupportsManualRolls
	}
	return false
}

func (x *AutoRollConfig) GetTimeWindow() string {
	if x != nil {
		return x.TimeWindow
	}
	return ""
}

// ModeChange describes one instance of an autoroller's mode being changed.
type ModeChange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier for the autoroller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// mode is the operating mode of the autoroller which was set in this
	// ModeChange.
	Mode Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// user is the email address of the user who created this ModeChange.
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// time is the timestamp at which the ModeChange was created.
	Time *timestamp.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// message is a user-created message which describes the reason for changing
	// the mode.
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *ModeChange) Reset() {
	*x = ModeChange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ModeChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModeChange) ProtoMessage() {}

func (x *ModeChange) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModeChange.ProtoReflect.Descriptor instead.
func (*ModeChange) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{5}
}

func (x *ModeChange) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *ModeChange) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *ModeChange) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *ModeChange) GetTime() *timestamp.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *ModeChange) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// StrategyChange describes one instance of an autoroller's mode being changed.
type StrategyChange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier for the autoroller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// strategy is the strategy for choosing the next revision to roll which was
	// set in this StrategyChange.
	Strategy Strategy `protobuf:"varint,2,opt,name=strategy,proto3,enum=autoroll.rpc.Strategy" json:"strategy,omitempty"`
	// user is the email address of the user who created this StrategyChange.
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// time is the timestamp at which the StrategyChange was created.
	Time *timestamp.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// message is a user-created message which describes the reason for changing
	// the strategy.
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *StrategyChange) Reset() {
	*x = StrategyChange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StrategyChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StrategyChange) ProtoMessage() {}

func (x *StrategyChange) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StrategyChange.ProtoReflect.Descriptor instead.
func (*StrategyChange) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{6}
}

func (x *StrategyChange) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *StrategyChange) GetStrategy() Strategy {
	if x != nil {
		return x.Strategy
	}
	return Strategy_BATCH
}

func (x *StrategyChange) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *StrategyChange) GetTime() *timestamp.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *StrategyChange) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ManualRoll describes a manually-triggered roll and its results.
type ManualRoll struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique identifier for this ManualRoll.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// roller_id is the unique identifier for the autoroller on which this
	// ManualRoll was requested.
	RollerId string `protobuf:"bytes,2,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// revision is the ID of the revision to which this ManualRoll will roll.
	Revision string `protobuf:"bytes,3,opt,name=revision,proto3" json:"revision,omitempty"`
	// requester is the email address of the person who requested the ManualRoll.
	Requester string `protobuf:"bytes,4,opt,name=requester,proto3" json:"requester,omitempty"`
	// result of the ManualRoll.
	Result ManualRoll_Result `protobuf:"varint,5,opt,name=result,proto3,enum=autoroll.rpc.ManualRoll_Result" json:"result,omitempty"`
	// status of the ManualRoll.
	Status ManualRoll_Status `protobuf:"varint,6,opt,name=status,proto3,enum=autoroll.rpc.ManualRoll_Status" json:"status,omitempty"`
	// timestamp at which the ManualRoll was created.
	Timestamp *timestamp.Timestamp `protobuf:"bytes,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// url of the ManualRoll, if a roll has been uploaded.
	Url string `protobuf:"bytes,8,opt,name=url,proto3" json:"url,omitempty"`
	// dry_run indicates whether the ManualRoll should be performed as a dry run,
	// so that the commit queue runs but the CL is not landed.
	DryRun bool `protobuf:"varint,9,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// no_email specifies that the requester and reviewers should not receive
	// email related to this ManualRoll.
	NoEmail bool `protobuf:"varint,10,opt,name=no_email,json=noEmail,proto3" json:"no_email,omitempty"`
	// no_resolve_revision specifies that the autoroller should not attempt to
	// find the requested revision ID in the Child but should simply use it as
	// provided.
	NoResolveRevision bool `protobuf:"varint,11,opt,name=no_resolve_revision,json=noResolveRevision,proto3" json:"no_resolve_revision,omitempty"`
}

func (x *ManualRoll) Reset() {
	*x = ManualRoll{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ManualRoll) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManualRoll) ProtoMessage() {}

func (x *ManualRoll) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ManualRoll.ProtoReflect.Descriptor instead.
func (*ManualRoll) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7}
}

func (x *ManualRoll) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ManualRoll) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *ManualRoll) GetRevision() string {
	if x != nil {
		return x.Revision
	}
	return ""
}

func (x *ManualRoll) GetRequester() string {
	if x != nil {
		return x.Requester
	}
	return ""
}

func (x *ManualRoll) GetResult() ManualRoll_Result {
	if x != nil {
		return x.Result
	}
	return ManualRoll_UNKNOWN
}

func (x *ManualRoll) GetStatus() ManualRoll_Status {
	if x != nil {
		return x.Status
	}
	return ManualRoll_PENDING
}

func (x *ManualRoll) GetTimestamp() *timestamp.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *ManualRoll) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *ManualRoll) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *ManualRoll) GetNoEmail() bool {
	if x != nil {
		return x.NoEmail
	}
	return false
}

func (x *ManualRoll) GetNoResolveRevision() bool {
	if x != nil {
		return x.NoResolveRevision
	}
	return false
}

// AutoRollStatus describes the overall status of an autoroller.
type AutoRollStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// mini_status contains a subset of status information for the autoroller.
	MiniStatus *AutoRollMiniStatus `protobuf:"bytes,1,opt,name=mini_status,json=miniStatus,proto3" json:"mini_status,omitempty"`
	// status is the current status of the autoroller, as provided by the state
	// machine.
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// config provides configuration information for the autoroller.
	Config *AutoRollConfig `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	// full_history_url is the URL where the autoroller's history may be viewed.
	FullHistoryUrl string `protobuf:"bytes,4,opt,name=full_history_url,json=fullHistoryUrl,proto3" json:"full_history_url,omitempty"`
	// issue_url_base provides a base URL which can be used to construct URLs for
	// individual AutoRollCLs.
	IssueUrlBase string `protobuf:"bytes,5,opt,name=issue_url_base,json=issueUrlBase,proto3" json:"issue_url_base,omitempty"`
	// mode is the current operating mode of the autoroller.
	Mode *ModeChange `protobuf:"bytes,6,opt,name=mode,proto3" json:"mode,omitempty"`
	// strategy for choosing the next revision to roll.
	Strategy *StrategyChange `protobuf:"bytes,7,opt,name=strategy,proto3" json:"strategy,omitempty"`
	// not_rolled_revisions are the revisions of the Child which have not yet been
	// rolled.
	NotRolledRevisions []*Revision `protobuf:"bytes,8,rep,name=not_rolled_revisions,json=notRolledRevisions,proto3" json:"not_rolled_revisions,omitempty"`
	// current_roll is the active roll CL, if any.
	CurrentRoll *AutoRollCL `protobuf:"bytes,9,opt,name=current_roll,json=currentRoll,proto3" json:"current_roll,omitempty"`
	// last_roll is the previous roll CL.
	LastRoll *AutoRollCL `protobuf:"bytes,10,opt,name=last_roll,json=lastRoll,proto3" json:"last_roll,omitempty"`
	// recent_rolls contains a list of recent roll CLs.
	RecentRolls []*AutoRollCL `protobuf:"bytes,11,rep,name=recent_rolls,json=recentRolls,proto3" json:"recent_rolls,omitempty"`
	// manual_rolls contains a list of recent ManualRolls.
	ManualRolls []*ManualRoll `protobuf:"bytes,12,rep,name=manual_rolls,json=manualRolls,proto3" json:"manual_rolls,omitempty"`
	// error contains a detailed message if the autoroller is in an error state.
	Error string `protobuf:"bytes,13,opt,name=error,proto3" json:"error,omitempty"`
	// throttled_until is the timestamp at which the autoroller will no longer be
	// throttled, if the autoroller is currently throttled.
	ThrottledUntil *timestamp.Timestamp `protobuf:"bytes,14,opt,name=throttled_until,json=throttledUntil,proto3" json:"throttled_until,omitempty"`
}

func (x *AutoRollStatus) Reset() {
	*x = AutoRollStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutoRollStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollStatus) ProtoMessage() {}

func (x *AutoRollStatus) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollStatus.ProtoReflect.Descriptor instead.
func (*AutoRollStatus) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{8}
}

func (x *AutoRollStatus) GetMiniStatus() *AutoRollMiniStatus {
	if x != nil {
		return x.MiniStatus
	}
	return nil
}

func (x *AutoRollStatus) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *AutoRollStatus) GetConfig() *AutoRollConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *AutoRollStatus) GetFullHistoryUrl() string {
	if x != nil {
		return x.FullHistoryUrl
	}
	return ""
}

func (x *AutoRollStatus) GetIssueUrlBase() string {
	if x != nil {
		return x.IssueUrlBase
	}
	return ""
}

func (x *AutoRollStatus) GetMode() *ModeChange {
	if x != nil {
		return x.Mode
	}
	return nil
}

func (x *AutoRollStatus) GetStrategy() *StrategyChange {
	if x != nil {
		return x.Strategy
	}
	return nil
}

func (x *AutoRollStatus) GetNotRolledRevisions() []*Revision {
	if x != nil {
		return x.NotRolledRevisions
	}
	return nil
}

func (x *AutoRollStatus) GetCurrentRoll() *AutoRollCL {
	if x != nil {
		return x.CurrentRoll
	}
	return nil
}

func (x *AutoRollStatus) GetLastRoll() *AutoRollCL {
	if x != nil {
		return x.LastRoll
	}
	return nil
}

func (x *AutoRollStatus) GetRecentRolls() []*AutoRollCL {
	if x != nil {
		return x.RecentRolls
	}
	return nil
}

func (x *AutoRollStatus) GetManualRolls() []*ManualRoll {
	if x != nil {
		return x.ManualRolls
	}
	return nil
}

func (x *AutoRollStatus) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *AutoRollStatus) GetThrottledUntil() *timestamp.Timestamp {
	if x != nil {
		return x.ThrottledUntil
	}
	return nil
}

// GetRollersRequest is a request to GetRollers.
type GetRollersRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *GetRollersRequest) Reset() {
	*x = GetRollersRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetRollersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollersRequest) ProtoMessage() {}

func (x *GetRollersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollersRequest.ProtoReflect.Descriptor instead.
func (*GetRollersRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{9}
}

// GetRollersResponse is a response returned by GetRollers.
type GetRollersResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// rollers contains status information for all known autorollers.
	Rollers []*AutoRollMiniStatus `protobuf:"bytes,1,rep,name=rollers,proto3" json:"rollers,omitempty"`
}

func (x *GetRollersResponse) Reset() {
	*x = GetRollersResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetRollersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollersResponse) ProtoMessage() {}

func (x *GetRollersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollersResponse.ProtoReflect.Descriptor instead.
func (*GetRollersResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{10}
}

func (x *GetRollersResponse) GetRollers() []*AutoRollMiniStatus {
	if x != nil {
		return x.Rollers
	}
	return nil
}

// GetMiniStatusRequest is a request to GetMiniStatus.
type GetMiniStatusRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose MiniStatus is to
	// be retrieved.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
}

func (x *GetMiniStatusRequest) Reset() {
	*x = GetMiniStatusRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetMiniStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMiniStatusRequest) ProtoMessage() {}

func (x *GetMiniStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMiniStatusRequest.ProtoReflect.Descriptor instead.
func (*GetMiniStatusRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{11}
}

func (x *GetMiniStatusRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// GetMiniStatusResponse is a response returned by GetMiniStatus.
type GetMiniStatusResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status is a subset of status information for the autoroller in question.
	Status *AutoRollMiniStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *GetMiniStatusResponse) Reset() {
	*x = GetMiniStatusResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetMiniStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMiniStatusResponse) ProtoMessage() {}

func (x *GetMiniStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMiniStatusResponse.ProtoReflect.Descriptor instead.
func (*GetMiniStatusResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{12}
}

func (x *GetMiniStatusResponse) GetStatus() *AutoRollMiniStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetStatusRequest is a request to GetStatus.
type GetStatusRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose Status is to be
	// retrieved.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
}

func (x *GetStatusRequest) Reset() {
	*x = GetStatusRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatusRequest) ProtoMessage() {}

func (x *GetStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatusRequest.ProtoReflect.Descriptor instead.
func (*GetStatusRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{13}
}

func (x *GetStatusRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// GetStatusResponse is a response returned by GetStatus.
type GetStatusResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status information about the autoroller in question.
	Status *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *GetStatusResponse) Reset() {
	*x = GetStatusResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatusResponse) ProtoMessage() {}

func (x *GetStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatusResponse.ProtoReflect.Descriptor instead.
func (*GetStatusResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{14}
}

func (x *GetStatusResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// SetModeRequest is a request to SetMode.
type SetModeRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose mode is to be
	// changed.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// mode is the desired mode to set for the given autoroller.
	Mode Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// message describes the reason for changing the mode.
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *SetModeRequest) Reset() {
	*x = SetModeRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetModeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetModeRequest) ProtoMessage() {}

func (x *SetModeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetModeRequest.ProtoReflect.Descriptor instead.
func (*SetModeRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{15}
}

func (x *SetModeRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *SetModeRequest) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *SetModeRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// SetModeResponse is a response returned by SetMode.
type SetModeResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status is the updated status of the autoroller after changing its mode.
	Status *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SetModeResponse) Reset() {
	*x = SetModeResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetModeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetModeResponse) ProtoMessage() {}

func (x *SetModeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetModeResponse.ProtoReflect.Descriptor instead.
func (*SetModeResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{16}
}

func (x *SetModeResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// SetStrategyRequest is a request to SetStrategy.
type SetStrategyRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller whose strategy is to
	// be changed.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// strategy is the desired strategy to set for the given autoroller.
	Strategy Strategy `protobuf:"varint,2,opt,name=strategy,proto3,enum=autoroll.rpc.Strategy" json:"strategy,omitempty"`
	// message describes the reason for changing the strategy.
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *SetStrategyRequest) Reset() {
	*x = SetStrategyRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetStrategyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStrategyRequest) ProtoMessage() {}

func (x *SetStrategyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStrategyRequest.ProtoReflect.Descriptor instead.
func (*SetStrategyRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{17}
}

func (x *SetStrategyRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *SetStrategyRequest) GetStrategy() Strategy {
	if x != nil {
		return x.Strategy
	}
	return Strategy_BATCH
}

func (x *SetStrategyRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// SetStrategyResponse is a response returned by SetStrategy.
type SetStrategyResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// status is the updated status of the autoroller after changing its strategy.
	Status *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SetStrategyResponse) Reset() {
	*x = SetStrategyResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetStrategyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStrategyResponse) ProtoMessage() {}

func (x *SetStrategyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStrategyResponse.ProtoReflect.Descriptor instead.
func (*SetStrategyResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{18}
}

func (x *SetStrategyResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// CreateManualRollRequest is a request to CreateManualRoll.
type CreateManualRollRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller which should create
	// the manual roll.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// revision is the ID of the revision to be rolled.
	Revision string `protobuf:"bytes,2,opt,name=revision,proto3" json:"revision,omitempty"`
	// dry_run flag controls whether the roll is a dry-run.
	DryRun bool `protobuf:"varint,3,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (x *CreateManualRollRequest) Reset() {
	*x = CreateManualRollRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateManualRollRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateManualRollRequest) ProtoMessage() {}

func (x *CreateManualRollRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateManualRollRequest.ProtoReflect.Descriptor instead.
func (*CreateManualRollRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{19}
}

func (x *CreateManualRollRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *CreateManualRollRequest) GetRevision() string {
	if x != nil {
		return x.Revision
	}
	return ""
}

func (x *CreateManualRollRequest) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

// CreateManualRollResponse is a response returned by CreateManualRoll.
type CreateManualRollResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roll is the manual roll which was created.
	Roll *ManualRoll `protobuf:"bytes,1,opt,name=roll,proto3" json:"roll,omitempty"`
}

func (x *CreateManualRollResponse) Reset() {
	*x = CreateManualRollResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CreateManualRollResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateManualRollResponse) ProtoMessage() {}

func (x *CreateManualRollResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateManualRollResponse.ProtoReflect.Descriptor instead.
func (*CreateManualRollResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{20}
}

func (x *CreateManualRollResponse) GetRoll() *ManualRoll {
	if x != nil {
		return x.Roll
	}
	return nil
}

// UnthrottleRequest is a request to Unthrottle.
type UnthrottleRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// roller_id is the unique identifier of the autoroller which should be
	// unthrottled.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
}

func (x *UnthrottleRequest) Reset() {
	*x = UnthrottleRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UnthrottleRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnthrottleRequest) ProtoMessage() {}

func (x *UnthrottleRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnthrottleRequest.ProtoReflect.Descriptor instead.
func (*UnthrottleRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{21}
}

func (x *UnthrottleRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// UnthrottleResponse is a response returned by Unthrottle.
type UnthrottleResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *UnthrottleResponse) Reset() {
	*x = UnthrottleResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_rpc_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UnthrottleResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnthrottleResponse) ProtoMessage() {}

func (x *UnthrottleResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnthrottleResponse.ProtoReflect.Descriptor instead.
func (*UnthrottleResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{22}
}

var File_rpc_proto protoreflect.FileDescriptor

var file_rpc_proto_rawDesc = []byte{
	0x0a, 0x09, 0x72, 0x70, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa5, 0x02, 0x0a, 0x12, 0x41,
	0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1d,
	0x0a, 0x0a, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x09, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1f, 0x0a,
	0x0b, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x26,
	0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x65,
	0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x12, 0x28, 0x0a, 0x10, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
	0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x5f, 0x72, 0x65, 0x76, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x65, 0x76,
	0x12, 0x22, 0x0a, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x5f, 0x72, 0x65,
	0x76, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6c, 0x61, 0x73, 0x74, 0x52, 0x6f, 0x6c,
	0x6c, 0x52, 0x65, 0x76, 0x12, 0x1d, 0x0a, 0x0a, 0x6e, 0x75, 0x6d, 0x5f, 0x66, 0x61, 0x69, 0x6c,
	0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x6e, 0x75, 0x6d, 0x46, 0x61, 0x69,
	0x6c, 0x65, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x65, 0x68, 0x69, 0x6e,
	0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x6e, 0x75, 0x6d, 0x42, 0x65, 0x68, 0x69,
	0x6e, 0x64, 0x22, 0xa8, 0x02, 0x0a, 0x06, 0x54, 0x72, 0x79, 0x4a, 0x6f, 0x62, 0x12, 0x12, 0x0a,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
	0x65, 0x12, 0x33, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x1b, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63,
	0x2e, 0x54, 0x72, 0x79, 0x4a, 0x6f, 0x62, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06,
	0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x33, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c,
	0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x54, 0x72, 0x79, 0x4a, 0x6f, 0x62, 0x2e, 0x52, 0x65, 0x73,
	0x75, 0x6c, 0x74, 0x52, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x75,
	0x72, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x1a, 0x0a,
	0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x08, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x22, 0x3d, 0x0a, 0x06, 0x52, 0x65, 0x73,
	0x75, 0x6c, 0x74, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00,
	0x12, 0x0b, 0x0a, 0x07, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x10, 0x01, 0x12, 0x0b, 0x0a,
	0x07, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x43, 0x41,
	0x4e, 0x43, 0x45, 0x4c, 0x45, 0x44, 0x10, 0x03, 0x22, 0x33, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x0d, 0x0a, 0x09, 0x53, 0x43, 0x48, 0x45, 0x44, 0x55, 0x4c, 0x45, 0x44, 0x10,
	0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x54, 0x41, 0x52, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x0d,
	0x0a, 0x09, 0x43, 0x4f, 0x4d, 0x50, 0x4c, 0x45, 0x54, 0x45, 0x44, 0x10, 0x02, 0x22, 0xc8, 0x03,
	0x0a, 0x0a, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x4c, 0x12, 0x0e, 0x0a, 0x02,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x37, 0x0a, 0x06,
	0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f,
	0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x4c, 0x2e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x06, 0x72,
	0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x12,
	0x1d, 0x0a, 0x0a, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x6f, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x54, 0x6f, 0x12, 0x21,
	0x0a, 0x0c, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x46, 0x72, 0x6f,
	0x6d, 0x12, 0x34, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x07,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12, 0x36, 0x0a, 0x08, 0x6d, 0x6f, 0x64, 0x69, 0x66,
	0x69, 0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x08, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x12,
	0x2f, 0x0a, 0x08, 0x74, 0x72, 0x79, 0x5f, 0x6a, 0x6f, 0x62, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x14, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63,
	0x2e, 0x54, 0x72, 0x79, 0x4a, 0x6f, 0x62, 0x52, 0x07, 0x74, 0x72, 0x79, 0x4a, 0x6f, 0x62, 0x73,
	0x22, 0x76, 0x0a, 0x06, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x0f, 0x0a, 0x0b, 0x49, 0x4e,
	0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x45, 0x53, 0x53, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53,
	0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x46, 0x41, 0x49, 0x4c,
	0x55, 0x52, 0x45, 0x10, 0x02, 0x12, 0x17, 0x0a, 0x13, 0x44, 0x52, 0x59, 0x5f, 0x52, 0x55, 0x4e,
	0x5f, 0x49, 0x4e, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x45, 0x53, 0x53, 0x10, 0x03, 0x12, 0x13,
	0x0a, 0x0f, 0x44, 0x52, 0x59, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53,
	0x53, 0x10, 0x04, 0x12, 0x13, 0x0a, 0x0f, 0x44, 0x52, 0x59, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x46,
	0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x05, 0x22, 0x98, 0x01, 0x0a, 0x08, 0x52, 0x65, 0x76,
	0x69, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x12,
	0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x04, 0x74, 0x69, 0x6d,
	0x65, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x75, 0x72, 0x6c, 0x22, 0xfb, 0x01, 0x0a, 0x0e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x24, 0x0a, 0x0e, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x5f,
	0x62, 0x75, 0x67, 0x5f, 0x6c, 0x69, 0x6e, 0x6b, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
	0x63, 0x68, 0x69, 0x6c, 0x64, 0x42, 0x75, 0x67, 0x4c, 0x69, 0x6e, 0x6b, 0x12, 0x26, 0x0a, 0x0f,
	0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x62, 0x75, 0x67, 0x5f, 0x6c, 0x69, 0x6e, 0x6b, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x42, 0x75, 0x67,
	0x4c, 0x69, 0x6e, 0x6b, 0x12, 0x29, 0x0a, 0x10, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x77,
	0x61, 0x74, 0x65, 0x72, 0x66, 0x61, 0x6c, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f,
	0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x57, 0x61, 0x74, 0x65, 0x72, 0x66, 0x61, 0x6c, 0x6c, 0x12,
	0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x32, 0x0a, 0x15,
	0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x5f, 0x6d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x5f,
	0x72, 0x6f, 0x6c, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x73, 0x75, 0x70,
	0x70, 0x6f, 0x72, 0x74, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x73,
	0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x69, 0x6d, 0x65, 0x57, 0x69, 0x6e, 0x64, 0x6f,
	0x77, 0x22, 0xaf, 0x01, 0x0a, 0x0a, 0x4d, 0x6f, 0x64, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65,
	0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x26, 0x0a,
	0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x61, 0x75,
	0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x52,
	0x04, 0x6d, 0x6f, 0x64, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x69, 0x6d,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x22, 0xbf, 0x01, 0x0a, 0x0e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79,
	0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65,
	0x72, 0x49, 0x64, 0x12, 0x32, 0x0a, 0x08, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x52, 0x08, 0x73,
	0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x2e, 0x0a, 0x04, 0x74,
	0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65,
	0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0xf9, 0x03, 0x0a, 0x0a, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c,
	0x52, 0x6f, 0x6c, 0x6c, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x02, 0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49,
	0x64, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x0a,
	0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x72, 0x12, 0x37, 0x0a, 0x06, 0x72,
	0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x61, 0x75,
	0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x61, 0x6e, 0x75, 0x61,
	0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x2e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x06, 0x72, 0x65,
	0x73, 0x75, 0x6c, 0x74, 0x12, 0x37, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e,
	0x72, 0x70, 0x63, 0x2e, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x2e, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x38, 0x0a,
	0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x74, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79,
	0x5f, 0x72, 0x75, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52,
	0x75, 0x6e, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x6f, 0x5f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x0a,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x6e, 0x6f, 0x45, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x2e, 0x0a,
	0x13, 0x6e, 0x6f, 0x5f, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x5f, 0x72, 0x65, 0x76, 0x69,
	0x73, 0x69, 0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11, 0x6e, 0x6f, 0x52, 0x65,
	0x73, 0x6f, 0x6c, 0x76, 0x65, 0x52, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x2f, 0x0a,
	0x06, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f,
	0x57, 0x4e, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10,
	0x01, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x10, 0x02, 0x22, 0x31,
	0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x0b, 0x0a, 0x07, 0x50, 0x45, 0x4e, 0x44,
	0x49, 0x4e, 0x47, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x54, 0x41, 0x52, 0x54, 0x45, 0x44,
	0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x4f, 0x4d, 0x50, 0x4c, 0x45, 0x54, 0x45, 0x44, 0x10,
	0x02, 0x22, 0xec, 0x05, 0x0a, 0x0e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x12, 0x41, 0x0a, 0x0b, 0x6d, 0x69, 0x6e, 0x69, 0x5f, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x61, 0x75, 0x74, 0x6f,
	0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c,
	0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x0a, 0x6d, 0x69, 0x6e,
	0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12,
	0x34, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41,
	0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x28, 0x0a, 0x10, 0x66, 0x75, 0x6c, 0x6c, 0x5f, 0x68, 0x69,
	0x73, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0e, 0x66, 0x75, 0x6c, 0x6c, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x55, 0x72, 0x6c, 0x12,
	0x24, 0x0a, 0x0e, 0x69, 0x73, 0x73, 0x75, 0x65, 0x5f, 0x75, 0x72, 0x6c, 0x5f, 0x62, 0x61, 0x73,
	0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x69, 0x73, 0x73, 0x75, 0x65, 0x55, 0x72,
	0x6c, 0x42, 0x61, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72,
	0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x04, 0x6d,
	0x6f, 0x64, 0x65, 0x12, 0x38, 0x0a, 0x08, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x43, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x52, 0x08, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x48, 0x0a,
	0x14, 0x6e, 0x6f, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x76, 0x69,
	0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x61, 0x75,
	0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x52, 0x65, 0x76, 0x69, 0x73,
	0x69, 0x6f, 0x6e, 0x52, 0x12, 0x6e, 0x6f, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x65, 0x64, 0x52, 0x65,
	0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x3b, 0x0a, 0x0c, 0x63, 0x75, 0x72, 0x72, 0x65,
	0x6e, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e,
	0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74,
	0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x4c, 0x52, 0x0b, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74,
	0x52, 0x6f, 0x6c, 0x6c, 0x12, 0x35, 0x0a, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x72, 0x6f, 0x6c,
	0x6c, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f,
	0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43,
	0x4c, 0x52, 0x08, 0x6c, 0x61, 0x73, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x12, 0x3b, 0x0a, 0x0c, 0x72,
	0x65, 0x63, 0x65, 0x6e, 0x74, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x73, 0x18, 0x0b, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63,
	0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x43, 0x4c, 0x52, 0x0b, 0x72, 0x65, 0x63,
	0x65, 0x6e, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x73, 0x12, 0x3b, 0x0a, 0x0c, 0x6d, 0x61, 0x6e, 0x75,
	0x61, 0x6c, 0x5f, 0x72, 0x6f, 0x6c, 0x6c, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18,
	0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x61,
	0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x0b, 0x6d, 0x61, 0x6e, 0x75, 0x61, 0x6c,
	0x52, 0x6f, 0x6c, 0x6c, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x0d,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x43, 0x0a, 0x0f, 0x74,
	0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x5f, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x18, 0x0e,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x52, 0x0e, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x55, 0x6e, 0x74, 0x69, 0x6c,
	0x22, 0x13, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x50, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c,
	0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3a, 0x0a, 0x07, 0x72,
	0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f,
	0x52, 0x6f, 0x6c, 0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x07,
	0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x22, 0x33, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x4d, 0x69,
	0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x22, 0x51, 0x0a, 0x15,
	0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x4d, 0x69, 0x6e,
	0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22,
	0x2f, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64,
	0x22, 0x49, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x34, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x6f, 0x0a, 0x0e, 0x53,
	0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a,
	0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x26, 0x0a, 0x04, 0x6d, 0x6f,
	0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72,
	0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x04, 0x6d, 0x6f,
	0x64, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x47, 0x0a, 0x0f,
	0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x34, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41,
	0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x7f, 0x0a, 0x12, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72, 0x61,
	0x74, 0x65, 0x67, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72,
	0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
	0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x32, 0x0a, 0x08, 0x73, 0x74, 0x72, 0x61,
	0x74, 0x65, 0x67, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65,
	0x67, 0x79, 0x52, 0x08, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x18, 0x0a, 0x07,
	0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x4b, 0x0a, 0x13, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72,
	0x61, 0x74, 0x65, 0x67, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x34, 0x0a,
	0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e,
	0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x41, 0x75, 0x74,
	0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x22, 0x6b, 0x0a, 0x17, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e,
	0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b,
	0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x72,
	0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72,
	0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x17, 0x0a, 0x07, 0x64, 0x72, 0x79, 0x5f, 0x72,
	0x75, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e,
	0x22, 0x48, 0x0a, 0x18, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c,
	0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x04,
	0x72, 0x6f, 0x6c, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x61, 0x75, 0x74,
	0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c,
	0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x6c, 0x22, 0x30, 0x0a, 0x11, 0x55, 0x6e,
	0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x1b, 0x0a, 0x09, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x08, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x22, 0x14, 0x0a, 0x12,
	0x55, 0x6e, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x2a, 0x2d, 0x0a, 0x04, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x55,
	0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x54, 0x4f, 0x50, 0x50,
	0x45, 0x44, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x52, 0x59, 0x5f, 0x52, 0x55, 0x4e, 0x10,
	0x02, 0x2a, 0x2e, 0x0a, 0x08, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x09, 0x0a,
	0x05, 0x42, 0x41, 0x54, 0x43, 0x48, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x5f, 0x42, 0x41,
	0x54, 0x43, 0x48, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x49, 0x4e, 0x47, 0x4c, 0x45, 0x10,
	0x02, 0x32, 0xda, 0x04, 0x0a, 0x0f, 0x41, 0x75, 0x74, 0x6f, 0x52, 0x6f, 0x6c, 0x6c, 0x53, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x4f, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c,
	0x65, 0x72, 0x73, 0x12, 0x1f, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72,
	0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e,
	0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x58, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e,
	0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x22, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f,
	0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x69, 0x6e, 0x69, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e, 0x61, 0x75,
	0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x69,
	0x6e, 0x69, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x12, 0x4c, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1e, 0x2e,
	0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e,
	0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x47, 0x65, 0x74,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x46,
	0x0a, 0x07, 0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x1c, 0x2e, 0x61, 0x75, 0x74, 0x6f,
	0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f,
	0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x52, 0x0a, 0x0b, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72,
	0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x20, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f,
	0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65,
	0x67, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x61, 0x0a, 0x10, 0x43, 0x72,
	0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x12, 0x25,
	0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x72,
	0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c,
	0x2e, 0x72, 0x70, 0x63, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x75, 0x61,
	0x6c, 0x52, 0x6f, 0x6c, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4f, 0x0a,
	0x0a, 0x55, 0x6e, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x12, 0x1f, 0x2e, 0x61, 0x75,
	0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x55, 0x6e, 0x74, 0x68, 0x72,
	0x6f, 0x74, 0x74, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x61,
	0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2e, 0x72, 0x70, 0x63, 0x2e, 0x55, 0x6e, 0x74, 0x68,
	0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x23,
	0x5a, 0x21, 0x67, 0x6f, 0x2e, 0x73, 0x6b, 0x69, 0x61, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x69, 0x6e,
	0x66, 0x72, 0x61, 0x2f, 0x61, 0x75, 0x74, 0x6f, 0x72, 0x6f, 0x6c, 0x6c, 0x2f, 0x67, 0x6f, 0x2f,
	0x72, 0x70, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_rpc_proto_rawDescOnce sync.Once
	file_rpc_proto_rawDescData = file_rpc_proto_rawDesc
)

func file_rpc_proto_rawDescGZIP() []byte {
	file_rpc_proto_rawDescOnce.Do(func() {
		file_rpc_proto_rawDescData = protoimpl.X.CompressGZIP(file_rpc_proto_rawDescData)
	})
	return file_rpc_proto_rawDescData
}

var file_rpc_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_rpc_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_rpc_proto_goTypes = []interface{}{
	(Mode)(0),                        // 0: autoroll.rpc.Mode
	(Strategy)(0),                    // 1: autoroll.rpc.Strategy
	(TryJob_Result)(0),               // 2: autoroll.rpc.TryJob.Result
	(TryJob_Status)(0),               // 3: autoroll.rpc.TryJob.Status
	(AutoRollCL_Result)(0),           // 4: autoroll.rpc.AutoRollCL.Result
	(ManualRoll_Result)(0),           // 5: autoroll.rpc.ManualRoll.Result
	(ManualRoll_Status)(0),           // 6: autoroll.rpc.ManualRoll.Status
	(*AutoRollMiniStatus)(nil),       // 7: autoroll.rpc.AutoRollMiniStatus
	(*TryJob)(nil),                   // 8: autoroll.rpc.TryJob
	(*AutoRollCL)(nil),               // 9: autoroll.rpc.AutoRollCL
	(*Revision)(nil),                 // 10: autoroll.rpc.Revision
	(*AutoRollConfig)(nil),           // 11: autoroll.rpc.AutoRollConfig
	(*ModeChange)(nil),               // 12: autoroll.rpc.ModeChange
	(*StrategyChange)(nil),           // 13: autoroll.rpc.StrategyChange
	(*ManualRoll)(nil),               // 14: autoroll.rpc.ManualRoll
	(*AutoRollStatus)(nil),           // 15: autoroll.rpc.AutoRollStatus
	(*GetRollersRequest)(nil),        // 16: autoroll.rpc.GetRollersRequest
	(*GetRollersResponse)(nil),       // 17: autoroll.rpc.GetRollersResponse
	(*GetMiniStatusRequest)(nil),     // 18: autoroll.rpc.GetMiniStatusRequest
	(*GetMiniStatusResponse)(nil),    // 19: autoroll.rpc.GetMiniStatusResponse
	(*GetStatusRequest)(nil),         // 20: autoroll.rpc.GetStatusRequest
	(*GetStatusResponse)(nil),        // 21: autoroll.rpc.GetStatusResponse
	(*SetModeRequest)(nil),           // 22: autoroll.rpc.SetModeRequest
	(*SetModeResponse)(nil),          // 23: autoroll.rpc.SetModeResponse
	(*SetStrategyRequest)(nil),       // 24: autoroll.rpc.SetStrategyRequest
	(*SetStrategyResponse)(nil),      // 25: autoroll.rpc.SetStrategyResponse
	(*CreateManualRollRequest)(nil),  // 26: autoroll.rpc.CreateManualRollRequest
	(*CreateManualRollResponse)(nil), // 27: autoroll.rpc.CreateManualRollResponse
	(*UnthrottleRequest)(nil),        // 28: autoroll.rpc.UnthrottleRequest
	(*UnthrottleResponse)(nil),       // 29: autoroll.rpc.UnthrottleResponse
	(*timestamp.Timestamp)(nil),      // 30: google.protobuf.Timestamp
}
var file_rpc_proto_depIdxs = []int32{
	0,  // 0: autoroll.rpc.AutoRollMiniStatus.mode:type_name -> autoroll.rpc.Mode
	3,  // 1: autoroll.rpc.TryJob.status:type_name -> autoroll.rpc.TryJob.Status
	2,  // 2: autoroll.rpc.TryJob.result:type_name -> autoroll.rpc.TryJob.Result
	4,  // 3: autoroll.rpc.AutoRollCL.result:type_name -> autoroll.rpc.AutoRollCL.Result
	30, // 4: autoroll.rpc.AutoRollCL.created:type_name -> google.protobuf.Timestamp
	30, // 5: autoroll.rpc.AutoRollCL.modified:type_name -> google.protobuf.Timestamp
	8,  // 6: autoroll.rpc.AutoRollCL.try_jobs:type_name -> autoroll.rpc.TryJob
	30, // 7: autoroll.rpc.Revision.time:type_name -> google.protobuf.Timestamp
	0,  // 8: autoroll.rpc.ModeChange.mode:type_name -> autoroll.rpc.Mode
	30, // 9: autoroll.rpc.ModeChange.time:type_name -> google.protobuf.Timestamp
	1,  // 10: autoroll.rpc.StrategyChange.strategy:type_name -> autoroll.rpc.Strategy
	30, // 11: autoroll.rpc.StrategyChange.time:type_name -> google.protobuf.Timestamp
	5,  // 12: autoroll.rpc.ManualRoll.result:type_name -> autoroll.rpc.ManualRoll.Result
	6,  // 13: autoroll.rpc.ManualRoll.status:type_name -> autoroll.rpc.ManualRoll.Status
	30, // 14: autoroll.rpc.ManualRoll.timestamp:type_name -> google.protobuf.Timestamp
	7,  // 15: autoroll.rpc.AutoRollStatus.mini_status:type_name -> autoroll.rpc.AutoRollMiniStatus
	11, // 16: autoroll.rpc.AutoRollStatus.config:type_name -> autoroll.rpc.AutoRollConfig
	12, // 17: autoroll.rpc.AutoRollStatus.mode:type_name -> autoroll.rpc.ModeChange
	13, // 18: autoroll.rpc.AutoRollStatus.strategy:type_name -> autoroll.rpc.StrategyChange
	10, // 19: autoroll.rpc.AutoRollStatus.not_rolled_revisions:type_name -> autoroll.rpc.Revision
	9,  // 20: autoroll.rpc.AutoRollStatus.current_roll:type_name -> autoroll.rpc.AutoRollCL
	9,  // 21: autoroll.rpc.AutoRollStatus.last_roll:type_name -> autoroll.rpc.AutoRollCL
	9,  // 22: autoroll.rpc.AutoRollStatus.recent_rolls:type_name -> autoroll.rpc.AutoRollCL
	14, // 23: autoroll.rpc.AutoRollStatus.manual_rolls:type_name -> autoroll.rpc.ManualRoll
	30, // 24: autoroll.rpc.AutoRollStatus.throttled_until:type_name -> google.protobuf.Timestamp
	7,  // 25: autoroll.rpc.GetRollersResponse.rollers:type_name -> autoroll.rpc.AutoRollMiniStatus
	7,  // 26: autoroll.rpc.GetMiniStatusResponse.status:type_name -> autoroll.rpc.AutoRollMiniStatus
	15, // 27: autoroll.rpc.GetStatusResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	0,  // 28: autoroll.rpc.SetModeRequest.mode:type_name -> autoroll.rpc.Mode
	15, // 29: autoroll.rpc.SetModeResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	1,  // 30: autoroll.rpc.SetStrategyRequest.strategy:type_name -> autoroll.rpc.Strategy
	15, // 31: autoroll.rpc.SetStrategyResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	14, // 32: autoroll.rpc.CreateManualRollResponse.roll:type_name -> autoroll.rpc.ManualRoll
	16, // 33: autoroll.rpc.AutoRollService.GetRollers:input_type -> autoroll.rpc.GetRollersRequest
	18, // 34: autoroll.rpc.AutoRollService.GetMiniStatus:input_type -> autoroll.rpc.GetMiniStatusRequest
	20, // 35: autoroll.rpc.AutoRollService.GetStatus:input_type -> autoroll.rpc.GetStatusRequest
	22, // 36: autoroll.rpc.AutoRollService.SetMode:input_type -> autoroll.rpc.SetModeRequest
	24, // 37: autoroll.rpc.AutoRollService.SetStrategy:input_type -> autoroll.rpc.SetStrategyRequest
	26, // 38: autoroll.rpc.AutoRollService.CreateManualRoll:input_type -> autoroll.rpc.CreateManualRollRequest
	28, // 39: autoroll.rpc.AutoRollService.Unthrottle:input_type -> autoroll.rpc.UnthrottleRequest
	17, // 40: autoroll.rpc.AutoRollService.GetRollers:output_type -> autoroll.rpc.GetRollersResponse
	19, // 41: autoroll.rpc.AutoRollService.GetMiniStatus:output_type -> autoroll.rpc.GetMiniStatusResponse
	21, // 42: autoroll.rpc.AutoRollService.GetStatus:output_type -> autoroll.rpc.GetStatusResponse
	23, // 43: autoroll.rpc.AutoRollService.SetMode:output_type -> autoroll.rpc.SetModeResponse
	25, // 44: autoroll.rpc.AutoRollService.SetStrategy:output_type -> autoroll.rpc.SetStrategyResponse
	27, // 45: autoroll.rpc.AutoRollService.CreateManualRoll:output_type -> autoroll.rpc.CreateManualRollResponse
	29, // 46: autoroll.rpc.AutoRollService.Unthrottle:output_type -> autoroll.rpc.UnthrottleResponse
	40, // [40:47] is the sub-list for method output_type
	33, // [33:40] is the sub-list for method input_type
	33, // [33:33] is the sub-list for extension type_name
	33, // [33:33] is the sub-list for extension extendee
	0,  // [0:33] is the sub-list for field type_name
}

func init() { file_rpc_proto_init() }
func file_rpc_proto_init() {
	if File_rpc_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_rpc_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutoRollMiniStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TryJob); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutoRollCL); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Revision); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutoRollConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ModeChange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StrategyChange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ManualRoll); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutoRollStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetRollersRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetRollersResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetMiniStatusRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetMiniStatusResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetStatusRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetStatusResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetModeRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetModeResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetStrategyRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetStrategyResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateManualRollRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CreateManualRollResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UnthrottleRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_rpc_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UnthrottleResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_rpc_proto_rawDesc,
			NumEnums:      7,
			NumMessages:   23,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_rpc_proto_goTypes,
		DependencyIndexes: file_rpc_proto_depIdxs,
		EnumInfos:         file_rpc_proto_enumTypes,
		MessageInfos:      file_rpc_proto_msgTypes,
	}.Build()
	File_rpc_proto = out.File
	file_rpc_proto_rawDesc = nil
	file_rpc_proto_goTypes = nil
	file_rpc_proto_depIdxs = nil
}
