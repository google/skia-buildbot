// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: rpc.proto

package rpc

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Mode describes the valid operating modes of an autoroller.
// These must be kept in sync with autoroll/go/modes/modes.go.
type Mode int32

const (
	// RUNNING is the typical operating mode of the autoroller. It will upload and
	// land CLs as new revisions appear in the Child.
	Mode_RUNNING Mode = 0
	// STOPPED prevents the autoroller from uploading any CLs. The roller will
	// continue to update any local checkouts to prevent them from getting too far
	// out of date, and any requested manual rolls will be fulfilled.
	Mode_STOPPED Mode = 1
	// DRY_RUN is similar to RUNNING but does not land the roll CLs after the
	// commit queue finishes. Instead, the active roll is left open until new
	// revisions appear in the child, at which point the roll is closed and a new
	// one is uploaded.
	Mode_DRY_RUN Mode = 2
	// OFFLINE is similar to STOPPED, but the roller does not update its checkouts
	// and requests for manual rolls are ignored.
	Mode_OFFLINE Mode = 3
)

// Enum value maps for Mode.
var (
	Mode_name = map[int32]string{
		0: "RUNNING",
		1: "STOPPED",
		2: "DRY_RUN",
		3: "OFFLINE",
	}
	Mode_value = map[string]int32{
		"RUNNING": 0,
		"STOPPED": 1,
		"DRY_RUN": 2,
		"OFFLINE": 3,
	}
)

func (x Mode) Enum() *Mode {
	p := new(Mode)
	*p = x
	return p
}

func (x Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[0].Descriptor()
}

func (Mode) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[0]
}

func (x Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Mode.Descriptor instead.
func (Mode) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{0}
}

// Strategy describes the valid strategies for choosing the next revision to
// roll. These must be kept in sync with autoroll/go/strategy/strategies.go.
type Strategy int32

const (
	// BATCH indicates that all not-yet-rolled revisions should be rolled in a
	// single CL.
	Strategy_BATCH Strategy = 0
	// N_BATCH is similar to BATCH but puts a limit on the number of revisions in
	// a single CL.
	Strategy_N_BATCH Strategy = 1
	// SINGLE indicates that a single revision is rolled in each CL.
	Strategy_SINGLE Strategy = 2
)

// Enum value maps for Strategy.
var (
	Strategy_name = map[int32]string{
		0: "BATCH",
		1: "N_BATCH",
		2: "SINGLE",
	}
	Strategy_value = map[string]int32{
		"BATCH":   0,
		"N_BATCH": 1,
		"SINGLE":  2,
	}
)

func (x Strategy) Enum() *Strategy {
	p := new(Strategy)
	*p = x
	return p
}

func (x Strategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Strategy) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[1].Descriptor()
}

func (Strategy) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[1]
}

func (x Strategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Strategy.Descriptor instead.
func (Strategy) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1}
}

// Result describes the possible results for a TryJob.
// These must be kept in sync with go/autoroll/autoroll.go.
type TryJob_Result int32

const (
	// UNKNOWN indicates that the result of the TryJob is unknown, ie. it has
	// not yet finished.
	TryJob_UNKNOWN TryJob_Result = 0
	// SUCCESS indicates that that TryJob completed successfully.
	TryJob_SUCCESS TryJob_Result = 1
	// FAILURE indicates that that TryJob failed.
	TryJob_FAILURE TryJob_Result = 2
	// CANCELED indicates that that TryJob was canceled.
	TryJob_CANCELED TryJob_Result = 3
)

// Enum value maps for TryJob_Result.
var (
	TryJob_Result_name = map[int32]string{
		0: "UNKNOWN",
		1: "SUCCESS",
		2: "FAILURE",
		3: "CANCELED",
	}
	TryJob_Result_value = map[string]int32{
		"UNKNOWN":  0,
		"SUCCESS":  1,
		"FAILURE":  2,
		"CANCELED": 3,
	}
)

func (x TryJob_Result) Enum() *TryJob_Result {
	p := new(TryJob_Result)
	*p = x
	return p
}

func (x TryJob_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TryJob_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[2].Descriptor()
}

func (TryJob_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[2]
}

func (x TryJob_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TryJob_Result.Descriptor instead.
func (TryJob_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1, 0}
}

// Status describes the lifecycle states of a TryJob.
// These must be kept in sync with go/autoroll/autoroll.go.
type TryJob_Status int32

const (
	// SCHEDULED indicates that the TryJob has been scheduled but has not yet
	// started.
	TryJob_SCHEDULED TryJob_Status = 0
	// STARTED indicates that the TryJob is currently running.
	TryJob_STARTED TryJob_Status = 1
	// COMPLETED indicates that the TryJob is finishes.
	TryJob_COMPLETED TryJob_Status = 2
)

// Enum value maps for TryJob_Status.
var (
	TryJob_Status_name = map[int32]string{
		0: "SCHEDULED",
		1: "STARTED",
		2: "COMPLETED",
	}
	TryJob_Status_value = map[string]int32{
		"SCHEDULED": 0,
		"STARTED":   1,
		"COMPLETED": 2,
	}
)

func (x TryJob_Status) Enum() *TryJob_Status {
	p := new(TryJob_Status)
	*p = x
	return p
}

func (x TryJob_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TryJob_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[3].Descriptor()
}

func (TryJob_Status) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[3]
}

func (x TryJob_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TryJob_Status.Descriptor instead.
func (TryJob_Status) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1, 1}
}

// Result describes the possible results for an AutoRollCL.
type AutoRollCL_Result int32

const (
	// IN_PROGRESS indicates that the commit queue is still running for this
	// AutoRollCL.
	AutoRollCL_IN_PROGRESS AutoRollCL_Result = 0
	// SUCCESS indicates that this AutoRollCL landed successfully.
	AutoRollCL_SUCCESS AutoRollCL_Result = 1
	// FAILURE indicates that the commit queue failed for  this AutoRollCL.
	AutoRollCL_FAILURE AutoRollCL_Result = 2
	// DRY_RUN_IN_PROGRESS indicates that the commit queue dry run is still
	// running for this AutoRollCL.
	AutoRollCL_DRY_RUN_IN_PROGRESS AutoRollCL_Result = 3
	// DRY_RUN_SUCCESS indicates that the commit queue dry run succeeded for
	// this AutoRollCL.
	AutoRollCL_DRY_RUN_SUCCESS AutoRollCL_Result = 4
	// DRY_RUN_FAILURE indicates that the commit queue dry run failed for this
	// AutoRollCL.
	AutoRollCL_DRY_RUN_FAILURE AutoRollCL_Result = 5
	// HUMAN_INTERVENED indicates that a human has modified the AutoRollCL and
	// the roller is no longer able to take action on it.
	AutoRollCL_HUMAN_INTERVENED AutoRollCL_Result = 6
)

// Enum value maps for AutoRollCL_Result.
var (
	AutoRollCL_Result_name = map[int32]string{
		0: "IN_PROGRESS",
		1: "SUCCESS",
		2: "FAILURE",
		3: "DRY_RUN_IN_PROGRESS",
		4: "DRY_RUN_SUCCESS",
		5: "DRY_RUN_FAILURE",
		6: "HUMAN_INTERVENED",
	}
	AutoRollCL_Result_value = map[string]int32{
		"IN_PROGRESS":         0,
		"SUCCESS":             1,
		"FAILURE":             2,
		"DRY_RUN_IN_PROGRESS": 3,
		"DRY_RUN_SUCCESS":     4,
		"DRY_RUN_FAILURE":     5,
		"HUMAN_INTERVENED":    6,
	}
)

func (x AutoRollCL_Result) Enum() *AutoRollCL_Result {
	p := new(AutoRollCL_Result)
	*p = x
	return p
}

func (x AutoRollCL_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AutoRollCL_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[4].Descriptor()
}

func (AutoRollCL_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[4]
}

func (x AutoRollCL_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AutoRollCL_Result.Descriptor instead.
func (AutoRollCL_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{2, 0}
}

// Result describes the possible results for a manual roll.
// These must be kept in sync with autoroll/go/manual/db.go.
type ManualRoll_Result int32

const (
	// UNKNOWN indicates that the result of the ManualRoll is unknown, ie. it
	// has not yet finished.
	ManualRoll_UNKNOWN ManualRoll_Result = 0
	// FAILURE indicates that the ManualRoll has failed.
	ManualRoll_FAILURE ManualRoll_Result = 1
	// SUCCESS indicates that the ManualRoll landed successfully.
	ManualRoll_SUCCESS ManualRoll_Result = 2
)

// Enum value maps for ManualRoll_Result.
var (
	ManualRoll_Result_name = map[int32]string{
		0: "UNKNOWN",
		1: "FAILURE",
		2: "SUCCESS",
	}
	ManualRoll_Result_value = map[string]int32{
		"UNKNOWN": 0,
		"FAILURE": 1,
		"SUCCESS": 2,
	}
)

func (x ManualRoll_Result) Enum() *ManualRoll_Result {
	p := new(ManualRoll_Result)
	*p = x
	return p
}

func (x ManualRoll_Result) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ManualRoll_Result) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[5].Descriptor()
}

func (ManualRoll_Result) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[5]
}

func (x ManualRoll_Result) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ManualRoll_Result.Descriptor instead.
func (ManualRoll_Result) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7, 0}
}

// Status describes the lifecycle states of a manual roll.
// These must be kept in sync with autoroll/go/manual/db.go.
type ManualRoll_Status int32

const (
	// PENDING indicates that the ManualRoll has been requested but no CL has
	// been uploaded.
	ManualRoll_PENDING ManualRoll_Status = 0
	// STARTED indicates that a CL has been uploaded for this ManualRoll.
	ManualRoll_STARTED ManualRoll_Status = 1
	// COMPLETED indicates that the ManualRoll has finished and either landed
	// successfully or failed.
	ManualRoll_COMPLETED ManualRoll_Status = 2
)

// Enum value maps for ManualRoll_Status.
var (
	ManualRoll_Status_name = map[int32]string{
		0: "PENDING",
		1: "STARTED",
		2: "COMPLETED",
	}
	ManualRoll_Status_value = map[string]int32{
		"PENDING":   0,
		"STARTED":   1,
		"COMPLETED": 2,
	}
)

func (x ManualRoll_Status) Enum() *ManualRoll_Status {
	p := new(ManualRoll_Status)
	*p = x
	return p
}

func (x ManualRoll_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ManualRoll_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_rpc_proto_enumTypes[6].Descriptor()
}

func (ManualRoll_Status) Type() protoreflect.EnumType {
	return &file_rpc_proto_enumTypes[6]
}

func (x ManualRoll_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ManualRoll_Status.Descriptor instead.
func (ManualRoll_Status) EnumDescriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7, 1}
}

// AutoRollMiniStatus contains a subset of the information of AutoRollStatus.
type AutoRollMiniStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique ID for this roller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// child_name is the display name of the child.
	ChildName string `protobuf:"bytes,2,opt,name=child_name,json=childName,proto3" json:"child_name,omitempty"`
	// parent_name is the display name of the parent.
	ParentName string `protobuf:"bytes,3,opt,name=parent_name,json=parentName,proto3" json:"parent_name,omitempty"`
	// mode is the currently-set operating mode of the roller.
	Mode Mode `protobuf:"varint,4,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// current_roll_rev is the ID of the child revision which is being rolled in
	// the active roll CL.
	CurrentRollRev string `protobuf:"bytes,5,opt,name=current_roll_rev,json=currentRollRev,proto3" json:"current_roll_rev,omitempty"`
	// last_roll_rev is the ID of the child revision which is currently pinned by
	// the parent.
	LastRollRev string `protobuf:"bytes,6,opt,name=last_roll_rev,json=lastRollRev,proto3" json:"last_roll_rev,omitempty"`
	// num_failed is the number of consecutive roll failures.
	NumFailed int32 `protobuf:"varint,7,opt,name=num_failed,json=numFailed,proto3" json:"num_failed,omitempty"`
	// num_behind is the number of not-yet-rolled revisions.
	NumBehind int32 `protobuf:"varint,8,opt,name=num_behind,json=numBehind,proto3" json:"num_behind,omitempty"`
	// timestamp is the time at which the roller last reported its status.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// last_successful_roll_timestamp is the time at which the roller last rolled
	// successfully.
	LastSuccessfulRollTimestamp *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=last_successful_roll_timestamp,json=lastSuccessfulRollTimestamp,proto3" json:"last_successful_roll_timestamp,omitempty"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *AutoRollMiniStatus) Reset() {
	*x = AutoRollMiniStatus{}
	mi := &file_rpc_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoRollMiniStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollMiniStatus) ProtoMessage() {}

func (x *AutoRollMiniStatus) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollMiniStatus.ProtoReflect.Descriptor instead.
func (*AutoRollMiniStatus) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{0}
}

func (x *AutoRollMiniStatus) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *AutoRollMiniStatus) GetChildName() string {
	if x != nil {
		return x.ChildName
	}
	return ""
}

func (x *AutoRollMiniStatus) GetParentName() string {
	if x != nil {
		return x.ParentName
	}
	return ""
}

func (x *AutoRollMiniStatus) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *AutoRollMiniStatus) GetCurrentRollRev() string {
	if x != nil {
		return x.CurrentRollRev
	}
	return ""
}

func (x *AutoRollMiniStatus) GetLastRollRev() string {
	if x != nil {
		return x.LastRollRev
	}
	return ""
}

func (x *AutoRollMiniStatus) GetNumFailed() int32 {
	if x != nil {
		return x.NumFailed
	}
	return 0
}

func (x *AutoRollMiniStatus) GetNumBehind() int32 {
	if x != nil {
		return x.NumBehind
	}
	return 0
}

func (x *AutoRollMiniStatus) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *AutoRollMiniStatus) GetLastSuccessfulRollTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSuccessfulRollTimestamp
	}
	return nil
}

type TryJob struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name of the TryJob.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// status of the TryJob.
	Status TryJob_Status `protobuf:"varint,2,opt,name=status,proto3,enum=autoroll.rpc.TryJob_Status" json:"status,omitempty"`
	// result of the TryJob.
	Result TryJob_Result `protobuf:"varint,3,opt,name=result,proto3,enum=autoroll.rpc.TryJob_Result" json:"result,omitempty"`
	// url where more details can be found about the TryJob.
	Url string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	// category of the TryJob, eg. "cq".
	Category      string `protobuf:"bytes,5,opt,name=category,proto3" json:"category,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TryJob) Reset() {
	*x = TryJob{}
	mi := &file_rpc_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TryJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TryJob) ProtoMessage() {}

func (x *TryJob) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TryJob.ProtoReflect.Descriptor instead.
func (*TryJob) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{1}
}

func (x *TryJob) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TryJob) GetStatus() TryJob_Status {
	if x != nil {
		return x.Status
	}
	return TryJob_SCHEDULED
}

func (x *TryJob) GetResult() TryJob_Result {
	if x != nil {
		return x.Result
	}
	return TryJob_UNKNOWN
}

func (x *TryJob) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *TryJob) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

// AutoRoll CL describes a CL uploaded by the autoroller.
type AutoRollCL struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique identifier for the CL.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// result of the AutoRollCL.
	Result AutoRollCL_Result `protobuf:"varint,2,opt,name=result,proto3,enum=autoroll.rpc.AutoRollCL_Result" json:"result,omitempty"`
	// subject line of the commit message of the AutoRollCL.
	Subject string `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
	// rolling_to is the ID of the revision being rolled.
	RollingTo string `protobuf:"bytes,4,opt,name=rolling_to,json=rollingTo,proto3" json:"rolling_to,omitempty"`
	// rolling_from is the ID of the currently-pinned revision.
	RollingFrom string `protobuf:"bytes,5,opt,name=rolling_from,json=rollingFrom,proto3" json:"rolling_from,omitempty"`
	// created is the timestamp at which the AutoRollCL was created.
	Created *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	// created is the timestamp at which the AutoRollCL was last modified.
	Modified *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=modified,proto3" json:"modified,omitempty"`
	// try_jobs contains results of any try jobs for the AutoRollCL.
	TryJobs       []*TryJob `protobuf:"bytes,8,rep,name=try_jobs,json=tryJobs,proto3" json:"try_jobs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutoRollCL) Reset() {
	*x = AutoRollCL{}
	mi := &file_rpc_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoRollCL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollCL) ProtoMessage() {}

func (x *AutoRollCL) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollCL.ProtoReflect.Descriptor instead.
func (*AutoRollCL) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{2}
}

func (x *AutoRollCL) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AutoRollCL) GetResult() AutoRollCL_Result {
	if x != nil {
		return x.Result
	}
	return AutoRollCL_IN_PROGRESS
}

func (x *AutoRollCL) GetSubject() string {
	if x != nil {
		return x.Subject
	}
	return ""
}

func (x *AutoRollCL) GetRollingTo() string {
	if x != nil {
		return x.RollingTo
	}
	return ""
}

func (x *AutoRollCL) GetRollingFrom() string {
	if x != nil {
		return x.RollingFrom
	}
	return ""
}

func (x *AutoRollCL) GetCreated() *timestamppb.Timestamp {
	if x != nil {
		return x.Created
	}
	return nil
}

func (x *AutoRollCL) GetModified() *timestamppb.Timestamp {
	if x != nil {
		return x.Modified
	}
	return nil
}

func (x *AutoRollCL) GetTryJobs() []*TryJob {
	if x != nil {
		return x.TryJobs
	}
	return nil
}

// Revision describes a single revision in a given Child. This may be a Git
// commit, CIPD package instance, a file uploaded to GCS, etc.
type Revision struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique identifier for the Revision.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// display is a human-friendly display name for the Revision.
	Display string `protobuf:"bytes,2,opt,name=display,proto3" json:"display,omitempty"`
	// description is a longer description of the Revision.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// time is the timestamp at which the Revision was created.
	Time *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// url where more details can be found about the Revision.
	Url string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
	// invalid_reason, if set, indicates why this Revision is not valid.
	InvalidReason string `protobuf:"bytes,6,opt,name=invalid_reason,json=invalidReason,proto3" json:"invalid_reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Revision) Reset() {
	*x = Revision{}
	mi := &file_rpc_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Revision) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Revision) ProtoMessage() {}

func (x *Revision) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Revision.ProtoReflect.Descriptor instead.
func (*Revision) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{3}
}

func (x *Revision) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Revision) GetDisplay() string {
	if x != nil {
		return x.Display
	}
	return ""
}

func (x *Revision) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Revision) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *Revision) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *Revision) GetInvalidReason() string {
	if x != nil {
		return x.InvalidReason
	}
	return ""
}

// AutoRollConfig describes the configuration for a roller.
type AutoRollConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// child_bug_link is a link to file a bug for the child project.
	ChildBugLink string `protobuf:"bytes,5,opt,name=child_bug_link,json=childBugLink,proto3" json:"child_bug_link,omitempty"`
	// parent_bug_link is a link to file a bug for the parent project.
	ParentBugLink string `protobuf:"bytes,6,opt,name=parent_bug_link,json=parentBugLink,proto3" json:"parent_bug_link,omitempty"`
	// parent_waterfall is the URL of the CI display for the parent repo.
	ParentWaterfall string `protobuf:"bytes,1,opt,name=parent_waterfall,json=parentWaterfall,proto3" json:"parent_waterfall,omitempty"`
	// roller_id is the unique identifier for the roller.
	RollerId string `protobuf:"bytes,2,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// supports_manual_rolls indicates whether this autoroller supports manually-
	// triggered rolls.
	SupportsManualRolls bool `protobuf:"varint,3,opt,name=supports_manual_rolls,json=supportsManualRolls,proto3" json:"supports_manual_rolls,omitempty"`
	// time_window describes the limitations, if any, on when the autoroller is
	// allowed to upload roll CLs.
	TimeWindow string `protobuf:"bytes,4,opt,name=time_window,json=timeWindow,proto3" json:"time_window,omitempty"`
	// valid_modes lists the valid modes for the roller. If not specified, all
	// modes are allowed.
	ValidModes    []Mode `protobuf:"varint,7,rep,packed,name=valid_modes,json=validModes,proto3,enum=autoroll.rpc.Mode" json:"valid_modes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutoRollConfig) Reset() {
	*x = AutoRollConfig{}
	mi := &file_rpc_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoRollConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollConfig) ProtoMessage() {}

func (x *AutoRollConfig) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollConfig.ProtoReflect.Descriptor instead.
func (*AutoRollConfig) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{4}
}

func (x *AutoRollConfig) GetChildBugLink() string {
	if x != nil {
		return x.ChildBugLink
	}
	return ""
}

func (x *AutoRollConfig) GetParentBugLink() string {
	if x != nil {
		return x.ParentBugLink
	}
	return ""
}

func (x *AutoRollConfig) GetParentWaterfall() string {
	if x != nil {
		return x.ParentWaterfall
	}
	return ""
}

func (x *AutoRollConfig) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *AutoRollConfig) GetSupportsManualRolls() bool {
	if x != nil {
		return x.SupportsManualRolls
	}
	return false
}

func (x *AutoRollConfig) GetTimeWindow() string {
	if x != nil {
		return x.TimeWindow
	}
	return ""
}

func (x *AutoRollConfig) GetValidModes() []Mode {
	if x != nil {
		return x.ValidModes
	}
	return nil
}

// ModeChange describes one instance of an autoroller's mode being changed.
type ModeChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier for the autoroller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// mode is the operating mode of the autoroller which was set in this
	// ModeChange.
	Mode Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// user is the email address of the user who created this ModeChange.
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// time is the timestamp at which the ModeChange was created.
	Time *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// message is a user-created message which describes the reason for changing
	// the mode.
	Message       string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModeChange) Reset() {
	*x = ModeChange{}
	mi := &file_rpc_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModeChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModeChange) ProtoMessage() {}

func (x *ModeChange) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModeChange.ProtoReflect.Descriptor instead.
func (*ModeChange) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{5}
}

func (x *ModeChange) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *ModeChange) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *ModeChange) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *ModeChange) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *ModeChange) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// StrategyChange describes one instance of an autoroller's mode being changed.
type StrategyChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier for the autoroller.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// strategy is the strategy for choosing the next revision to roll which was
	// set in this StrategyChange.
	Strategy Strategy `protobuf:"varint,2,opt,name=strategy,proto3,enum=autoroll.rpc.Strategy" json:"strategy,omitempty"`
	// user is the email address of the user who created this StrategyChange.
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// time is the timestamp at which the StrategyChange was created.
	Time *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// message is a user-created message which describes the reason for changing
	// the strategy.
	Message       string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StrategyChange) Reset() {
	*x = StrategyChange{}
	mi := &file_rpc_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StrategyChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StrategyChange) ProtoMessage() {}

func (x *StrategyChange) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StrategyChange.ProtoReflect.Descriptor instead.
func (*StrategyChange) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{6}
}

func (x *StrategyChange) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *StrategyChange) GetStrategy() Strategy {
	if x != nil {
		return x.Strategy
	}
	return Strategy_BATCH
}

func (x *StrategyChange) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *StrategyChange) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *StrategyChange) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ManualRoll describes a manually-triggered roll and its results.
type ManualRoll struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique identifier for this ManualRoll.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// roller_id is the unique identifier for the autoroller on which this
	// ManualRoll was requested.
	RollerId string `protobuf:"bytes,2,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// revision is the ID of the revision to which this ManualRoll will roll.
	Revision string `protobuf:"bytes,3,opt,name=revision,proto3" json:"revision,omitempty"`
	// requester is the email address of the person who requested the ManualRoll.
	Requester string `protobuf:"bytes,4,opt,name=requester,proto3" json:"requester,omitempty"`
	// result of the ManualRoll.
	Result ManualRoll_Result `protobuf:"varint,5,opt,name=result,proto3,enum=autoroll.rpc.ManualRoll_Result" json:"result,omitempty"`
	// status of the ManualRoll.
	Status ManualRoll_Status `protobuf:"varint,6,opt,name=status,proto3,enum=autoroll.rpc.ManualRoll_Status" json:"status,omitempty"`
	// timestamp at which the ManualRoll was created.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// url of the ManualRoll, if a roll has been uploaded.
	Url string `protobuf:"bytes,8,opt,name=url,proto3" json:"url,omitempty"`
	// dry_run indicates whether the ManualRoll should be performed as a dry run,
	// so that the commit queue runs but the CL is not landed.
	DryRun bool `protobuf:"varint,9,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// no_email specifies that the requester and reviewers should not receive
	// email related to this ManualRoll.
	NoEmail bool `protobuf:"varint,10,opt,name=no_email,json=noEmail,proto3" json:"no_email,omitempty"`
	// no_resolve_revision specifies that the autoroller should not attempt to
	// find the requested revision ID in the Child but should simply use it as
	// provided.
	NoResolveRevision bool `protobuf:"varint,11,opt,name=no_resolve_revision,json=noResolveRevision,proto3" json:"no_resolve_revision,omitempty"`
	// canary indicates that this manual roll was a canary request.
	Canary        bool `protobuf:"varint,12,opt,name=canary,proto3" json:"canary,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ManualRoll) Reset() {
	*x = ManualRoll{}
	mi := &file_rpc_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ManualRoll) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManualRoll) ProtoMessage() {}

func (x *ManualRoll) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ManualRoll.ProtoReflect.Descriptor instead.
func (*ManualRoll) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{7}
}

func (x *ManualRoll) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ManualRoll) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *ManualRoll) GetRevision() string {
	if x != nil {
		return x.Revision
	}
	return ""
}

func (x *ManualRoll) GetRequester() string {
	if x != nil {
		return x.Requester
	}
	return ""
}

func (x *ManualRoll) GetResult() ManualRoll_Result {
	if x != nil {
		return x.Result
	}
	return ManualRoll_UNKNOWN
}

func (x *ManualRoll) GetStatus() ManualRoll_Status {
	if x != nil {
		return x.Status
	}
	return ManualRoll_PENDING
}

func (x *ManualRoll) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *ManualRoll) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *ManualRoll) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

func (x *ManualRoll) GetNoEmail() bool {
	if x != nil {
		return x.NoEmail
	}
	return false
}

func (x *ManualRoll) GetNoResolveRevision() bool {
	if x != nil {
		return x.NoResolveRevision
	}
	return false
}

func (x *ManualRoll) GetCanary() bool {
	if x != nil {
		return x.Canary
	}
	return false
}

// AutoRollStatus describes the overall status of an autoroller.
type AutoRollStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mini_status contains a subset of status information for the autoroller.
	MiniStatus *AutoRollMiniStatus `protobuf:"bytes,1,opt,name=mini_status,json=miniStatus,proto3" json:"mini_status,omitempty"`
	// status is the current status of the autoroller, as provided by the state
	// machine.
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// config provides configuration information for the autoroller.
	Config *AutoRollConfig `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	// full_history_url is the URL where the autoroller's history may be viewed.
	FullHistoryUrl string `protobuf:"bytes,4,opt,name=full_history_url,json=fullHistoryUrl,proto3" json:"full_history_url,omitempty"`
	// issue_url_base provides a base URL which can be used to construct URLs for
	// individual AutoRollCLs.
	IssueUrlBase string `protobuf:"bytes,5,opt,name=issue_url_base,json=issueUrlBase,proto3" json:"issue_url_base,omitempty"`
	// mode is the current operating mode of the autoroller.
	Mode *ModeChange `protobuf:"bytes,6,opt,name=mode,proto3" json:"mode,omitempty"`
	// strategy for choosing the next revision to roll.
	Strategy *StrategyChange `protobuf:"bytes,7,opt,name=strategy,proto3" json:"strategy,omitempty"`
	// not_rolled_revisions are the revisions of the Child which have not yet been
	// rolled.
	NotRolledRevisions []*Revision `protobuf:"bytes,8,rep,name=not_rolled_revisions,json=notRolledRevisions,proto3" json:"not_rolled_revisions,omitempty"`
	// current_roll is the active roll CL, if any.
	CurrentRoll *AutoRollCL `protobuf:"bytes,9,opt,name=current_roll,json=currentRoll,proto3" json:"current_roll,omitempty"`
	// last_roll is the previous roll CL.
	LastRoll *AutoRollCL `protobuf:"bytes,10,opt,name=last_roll,json=lastRoll,proto3" json:"last_roll,omitempty"`
	// recent_rolls contains a list of recent roll CLs.
	RecentRolls []*AutoRollCL `protobuf:"bytes,11,rep,name=recent_rolls,json=recentRolls,proto3" json:"recent_rolls,omitempty"`
	// manual_rolls contains a list of recent ManualRolls.
	ManualRolls []*ManualRoll `protobuf:"bytes,12,rep,name=manual_rolls,json=manualRolls,proto3" json:"manual_rolls,omitempty"`
	// error contains a detailed message if the autoroller is in an error state.
	Error string `protobuf:"bytes,13,opt,name=error,proto3" json:"error,omitempty"`
	// throttled_until is the timestamp at which the autoroller will no longer be
	// throttled, if the autoroller is currently throttled.
	ThrottledUntil *timestamppb.Timestamp `protobuf:"bytes,14,opt,name=throttled_until,json=throttledUntil,proto3" json:"throttled_until,omitempty"`
	// cleanup_requested is the most recent request for cleanup of this roller, if
	// any.
	CleanupRequested *CleanupRequest `protobuf:"bytes,15,opt,name=cleanup_requested,json=cleanupRequested,proto3" json:"cleanup_requested,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *AutoRollStatus) Reset() {
	*x = AutoRollStatus{}
	mi := &file_rpc_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoRollStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoRollStatus) ProtoMessage() {}

func (x *AutoRollStatus) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoRollStatus.ProtoReflect.Descriptor instead.
func (*AutoRollStatus) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{8}
}

func (x *AutoRollStatus) GetMiniStatus() *AutoRollMiniStatus {
	if x != nil {
		return x.MiniStatus
	}
	return nil
}

func (x *AutoRollStatus) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *AutoRollStatus) GetConfig() *AutoRollConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *AutoRollStatus) GetFullHistoryUrl() string {
	if x != nil {
		return x.FullHistoryUrl
	}
	return ""
}

func (x *AutoRollStatus) GetIssueUrlBase() string {
	if x != nil {
		return x.IssueUrlBase
	}
	return ""
}

func (x *AutoRollStatus) GetMode() *ModeChange {
	if x != nil {
		return x.Mode
	}
	return nil
}

func (x *AutoRollStatus) GetStrategy() *StrategyChange {
	if x != nil {
		return x.Strategy
	}
	return nil
}

func (x *AutoRollStatus) GetNotRolledRevisions() []*Revision {
	if x != nil {
		return x.NotRolledRevisions
	}
	return nil
}

func (x *AutoRollStatus) GetCurrentRoll() *AutoRollCL {
	if x != nil {
		return x.CurrentRoll
	}
	return nil
}

func (x *AutoRollStatus) GetLastRoll() *AutoRollCL {
	if x != nil {
		return x.LastRoll
	}
	return nil
}

func (x *AutoRollStatus) GetRecentRolls() []*AutoRollCL {
	if x != nil {
		return x.RecentRolls
	}
	return nil
}

func (x *AutoRollStatus) GetManualRolls() []*ManualRoll {
	if x != nil {
		return x.ManualRolls
	}
	return nil
}

func (x *AutoRollStatus) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *AutoRollStatus) GetThrottledUntil() *timestamppb.Timestamp {
	if x != nil {
		return x.ThrottledUntil
	}
	return nil
}

func (x *AutoRollStatus) GetCleanupRequested() *CleanupRequest {
	if x != nil {
		return x.CleanupRequested
	}
	return nil
}

// GetRollersRequest is a request to GetRollers.
type GetRollersRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRollersRequest) Reset() {
	*x = GetRollersRequest{}
	mi := &file_rpc_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRollersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollersRequest) ProtoMessage() {}

func (x *GetRollersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollersRequest.ProtoReflect.Descriptor instead.
func (*GetRollersRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{9}
}

// GetRollersResponse is a response returned by GetRollers.
type GetRollersResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// rollers contains status information for all known autorollers.
	Rollers       []*AutoRollMiniStatus `protobuf:"bytes,1,rep,name=rollers,proto3" json:"rollers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRollersResponse) Reset() {
	*x = GetRollersResponse{}
	mi := &file_rpc_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRollersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollersResponse) ProtoMessage() {}

func (x *GetRollersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollersResponse.ProtoReflect.Descriptor instead.
func (*GetRollersResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{10}
}

func (x *GetRollersResponse) GetRollers() []*AutoRollMiniStatus {
	if x != nil {
		return x.Rollers
	}
	return nil
}

// GetRollsRequest is a request to GetRolls.
type GetRollsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller whose rolls are to be
	// retrieved.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// cursor is a database-provided cursor used for pagination.
	Cursor        string `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRollsRequest) Reset() {
	*x = GetRollsRequest{}
	mi := &file_rpc_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRollsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollsRequest) ProtoMessage() {}

func (x *GetRollsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollsRequest.ProtoReflect.Descriptor instead.
func (*GetRollsRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{11}
}

func (x *GetRollsRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *GetRollsRequest) GetCursor() string {
	if x != nil {
		return x.Cursor
	}
	return ""
}

// GetRollsResponse is a response returned by GetRolls.
type GetRollsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// rolls are the rolls retrieved from the database.
	Rolls []*AutoRollCL `protobuf:"bytes,1,rep,name=rolls,proto3" json:"rolls,omitempty"`
	// cursor is a database-provided cursor which can be provided to the next call
	// to GetRolls to load more rolls.
	Cursor        string `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRollsResponse) Reset() {
	*x = GetRollsResponse{}
	mi := &file_rpc_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRollsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRollsResponse) ProtoMessage() {}

func (x *GetRollsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRollsResponse.ProtoReflect.Descriptor instead.
func (*GetRollsResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{12}
}

func (x *GetRollsResponse) GetRolls() []*AutoRollCL {
	if x != nil {
		return x.Rolls
	}
	return nil
}

func (x *GetRollsResponse) GetCursor() string {
	if x != nil {
		return x.Cursor
	}
	return ""
}

// GetMiniStatusRequest is a request to GetMiniStatus.
type GetMiniStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller whose MiniStatus is to
	// be retrieved.
	RollerId      string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMiniStatusRequest) Reset() {
	*x = GetMiniStatusRequest{}
	mi := &file_rpc_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMiniStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMiniStatusRequest) ProtoMessage() {}

func (x *GetMiniStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMiniStatusRequest.ProtoReflect.Descriptor instead.
func (*GetMiniStatusRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{13}
}

func (x *GetMiniStatusRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// GetMiniStatusResponse is a response returned by GetMiniStatus.
type GetMiniStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// status is a subset of status information for the autoroller in question.
	Status        *AutoRollMiniStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMiniStatusResponse) Reset() {
	*x = GetMiniStatusResponse{}
	mi := &file_rpc_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMiniStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMiniStatusResponse) ProtoMessage() {}

func (x *GetMiniStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMiniStatusResponse.ProtoReflect.Descriptor instead.
func (*GetMiniStatusResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{14}
}

func (x *GetMiniStatusResponse) GetStatus() *AutoRollMiniStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetStatusRequest is a request to GetStatus.
type GetStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller whose Status is to be
	// retrieved.
	RollerId      string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStatusRequest) Reset() {
	*x = GetStatusRequest{}
	mi := &file_rpc_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatusRequest) ProtoMessage() {}

func (x *GetStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatusRequest.ProtoReflect.Descriptor instead.
func (*GetStatusRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{15}
}

func (x *GetStatusRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// GetStatusResponse is a response returned by GetStatus.
type GetStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// status information about the autoroller in question.
	Status        *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStatusResponse) Reset() {
	*x = GetStatusResponse{}
	mi := &file_rpc_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatusResponse) ProtoMessage() {}

func (x *GetStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatusResponse.ProtoReflect.Descriptor instead.
func (*GetStatusResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{16}
}

func (x *GetStatusResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// SetModeRequest is a request to SetMode.
type SetModeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller whose mode is to be
	// changed.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// mode is the desired mode to set for the given autoroller.
	Mode Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=autoroll.rpc.Mode" json:"mode,omitempty"`
	// message describes the reason for changing the mode.
	Message       string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetModeRequest) Reset() {
	*x = SetModeRequest{}
	mi := &file_rpc_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetModeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetModeRequest) ProtoMessage() {}

func (x *SetModeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetModeRequest.ProtoReflect.Descriptor instead.
func (*SetModeRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{17}
}

func (x *SetModeRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *SetModeRequest) GetMode() Mode {
	if x != nil {
		return x.Mode
	}
	return Mode_RUNNING
}

func (x *SetModeRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// SetModeResponse is a response returned by SetMode.
type SetModeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// status is the updated status of the autoroller after changing its mode.
	Status        *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetModeResponse) Reset() {
	*x = SetModeResponse{}
	mi := &file_rpc_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetModeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetModeResponse) ProtoMessage() {}

func (x *SetModeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetModeResponse.ProtoReflect.Descriptor instead.
func (*SetModeResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{18}
}

func (x *SetModeResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetModeHistoryRequest is a request to GetModeHistory.
type GetModeHistoryRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RollerId      string                 `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	Offset        int32                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetModeHistoryRequest) Reset() {
	*x = GetModeHistoryRequest{}
	mi := &file_rpc_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetModeHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetModeHistoryRequest) ProtoMessage() {}

func (x *GetModeHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetModeHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetModeHistoryRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{19}
}

func (x *GetModeHistoryRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *GetModeHistoryRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// GetModeHistoryResponse is a response returned by GetModeHistory.
type GetModeHistoryResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	History       []*ModeChange          `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
	NextOffset    int32                  `protobuf:"varint,2,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetModeHistoryResponse) Reset() {
	*x = GetModeHistoryResponse{}
	mi := &file_rpc_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetModeHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetModeHistoryResponse) ProtoMessage() {}

func (x *GetModeHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetModeHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetModeHistoryResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{20}
}

func (x *GetModeHistoryResponse) GetHistory() []*ModeChange {
	if x != nil {
		return x.History
	}
	return nil
}

func (x *GetModeHistoryResponse) GetNextOffset() int32 {
	if x != nil {
		return x.NextOffset
	}
	return 0
}

// SetStrategyRequest is a request to SetStrategy.
type SetStrategyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller whose strategy is to
	// be changed.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// strategy is the desired strategy to set for the given autoroller.
	Strategy Strategy `protobuf:"varint,2,opt,name=strategy,proto3,enum=autoroll.rpc.Strategy" json:"strategy,omitempty"`
	// message describes the reason for changing the strategy.
	Message       string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetStrategyRequest) Reset() {
	*x = SetStrategyRequest{}
	mi := &file_rpc_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetStrategyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStrategyRequest) ProtoMessage() {}

func (x *SetStrategyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStrategyRequest.ProtoReflect.Descriptor instead.
func (*SetStrategyRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{21}
}

func (x *SetStrategyRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *SetStrategyRequest) GetStrategy() Strategy {
	if x != nil {
		return x.Strategy
	}
	return Strategy_BATCH
}

func (x *SetStrategyRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// SetStrategyResponse is a response returned by SetStrategy.
type SetStrategyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// status is the updated status of the autoroller after changing its strategy.
	Status        *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetStrategyResponse) Reset() {
	*x = SetStrategyResponse{}
	mi := &file_rpc_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetStrategyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStrategyResponse) ProtoMessage() {}

func (x *SetStrategyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStrategyResponse.ProtoReflect.Descriptor instead.
func (*SetStrategyResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{22}
}

func (x *SetStrategyResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetStrategyHistoryRequest is a request to GetStrategyHistory.
type GetStrategyHistoryRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RollerId      string                 `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	Offset        int32                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStrategyHistoryRequest) Reset() {
	*x = GetStrategyHistoryRequest{}
	mi := &file_rpc_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStrategyHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStrategyHistoryRequest) ProtoMessage() {}

func (x *GetStrategyHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStrategyHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetStrategyHistoryRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{23}
}

func (x *GetStrategyHistoryRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *GetStrategyHistoryRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// GetStrategyHistoryResponse is a response returned by GetStrategyHistory.
type GetStrategyHistoryResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	History       []*StrategyChange      `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
	NextOffset    int32                  `protobuf:"varint,2,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStrategyHistoryResponse) Reset() {
	*x = GetStrategyHistoryResponse{}
	mi := &file_rpc_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStrategyHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStrategyHistoryResponse) ProtoMessage() {}

func (x *GetStrategyHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStrategyHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetStrategyHistoryResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{24}
}

func (x *GetStrategyHistoryResponse) GetHistory() []*StrategyChange {
	if x != nil {
		return x.History
	}
	return nil
}

func (x *GetStrategyHistoryResponse) GetNextOffset() int32 {
	if x != nil {
		return x.NextOffset
	}
	return 0
}

// CreateManualRollRequest is a request to CreateManualRoll.
type CreateManualRollRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller which should create
	// the manual roll.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// revision is the ID of the revision to be rolled.
	Revision string `protobuf:"bytes,2,opt,name=revision,proto3" json:"revision,omitempty"`
	// dry_run flag controls whether the roll is a dry-run.
	DryRun        bool `protobuf:"varint,3,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateManualRollRequest) Reset() {
	*x = CreateManualRollRequest{}
	mi := &file_rpc_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateManualRollRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateManualRollRequest) ProtoMessage() {}

func (x *CreateManualRollRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateManualRollRequest.ProtoReflect.Descriptor instead.
func (*CreateManualRollRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{25}
}

func (x *CreateManualRollRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *CreateManualRollRequest) GetRevision() string {
	if x != nil {
		return x.Revision
	}
	return ""
}

func (x *CreateManualRollRequest) GetDryRun() bool {
	if x != nil {
		return x.DryRun
	}
	return false
}

// CreateManualRollResponse is a response returned by CreateManualRoll.
type CreateManualRollResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roll is the manual roll which was created.
	Roll          *ManualRoll `protobuf:"bytes,1,opt,name=roll,proto3" json:"roll,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateManualRollResponse) Reset() {
	*x = CreateManualRollResponse{}
	mi := &file_rpc_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateManualRollResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateManualRollResponse) ProtoMessage() {}

func (x *CreateManualRollResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateManualRollResponse.ProtoReflect.Descriptor instead.
func (*CreateManualRollResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{26}
}

func (x *CreateManualRollResponse) GetRoll() *ManualRoll {
	if x != nil {
		return x.Roll
	}
	return nil
}

// UnthrottleRequest is a request to Unthrottle.
type UnthrottleRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller which should be
	// unthrottled.
	RollerId      string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnthrottleRequest) Reset() {
	*x = UnthrottleRequest{}
	mi := &file_rpc_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnthrottleRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnthrottleRequest) ProtoMessage() {}

func (x *UnthrottleRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnthrottleRequest.ProtoReflect.Descriptor instead.
func (*UnthrottleRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{27}
}

func (x *UnthrottleRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

// UnthrottleResponse is a response returned by Unthrottle.
type UnthrottleResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnthrottleResponse) Reset() {
	*x = UnthrottleResponse{}
	mi := &file_rpc_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnthrottleResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnthrottleResponse) ProtoMessage() {}

func (x *UnthrottleResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnthrottleResponse.ProtoReflect.Descriptor instead.
func (*UnthrottleResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{28}
}

// AddCleanupRequestRequest is a request to AddCleanupRequest.
type AddCleanupRequestRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller in question.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// justification is the reason that cleanup is being requested.
	Justification string `protobuf:"bytes,2,opt,name=justification,proto3" json:"justification,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddCleanupRequestRequest) Reset() {
	*x = AddCleanupRequestRequest{}
	mi := &file_rpc_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddCleanupRequestRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddCleanupRequestRequest) ProtoMessage() {}

func (x *AddCleanupRequestRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddCleanupRequestRequest.ProtoReflect.Descriptor instead.
func (*AddCleanupRequestRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{29}
}

func (x *AddCleanupRequestRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *AddCleanupRequestRequest) GetJustification() string {
	if x != nil {
		return x.Justification
	}
	return ""
}

// AddCleanupRequestResponse is a response returned by AddCleanupRequest.
type AddCleanupRequestResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// status is the updated status of the autoroller.
	Status        *AutoRollStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddCleanupRequestResponse) Reset() {
	*x = AddCleanupRequestResponse{}
	mi := &file_rpc_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddCleanupRequestResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddCleanupRequestResponse) ProtoMessage() {}

func (x *AddCleanupRequestResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddCleanupRequestResponse.ProtoReflect.Descriptor instead.
func (*AddCleanupRequestResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{30}
}

func (x *AddCleanupRequestResponse) GetStatus() *AutoRollStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// GetCleanupHistoryRequest is a request to GetCleanupHistory.
type GetCleanupHistoryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roller_id is the unique identifier of the autoroller in question.
	RollerId string `protobuf:"bytes,1,opt,name=roller_id,json=rollerId,proto3" json:"roller_id,omitempty"`
	// limit is the maximum number of results to return.
	Limit         uint32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetCleanupHistoryRequest) Reset() {
	*x = GetCleanupHistoryRequest{}
	mi := &file_rpc_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCleanupHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCleanupHistoryRequest) ProtoMessage() {}

func (x *GetCleanupHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCleanupHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetCleanupHistoryRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{31}
}

func (x *GetCleanupHistoryRequest) GetRollerId() string {
	if x != nil {
		return x.RollerId
	}
	return ""
}

func (x *GetCleanupHistoryRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type GetCleanupHistoryResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	History       []*CleanupRequest      `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetCleanupHistoryResponse) Reset() {
	*x = GetCleanupHistoryResponse{}
	mi := &file_rpc_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCleanupHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCleanupHistoryResponse) ProtoMessage() {}

func (x *GetCleanupHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCleanupHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetCleanupHistoryResponse) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{32}
}

func (x *GetCleanupHistoryResponse) GetHistory() []*CleanupRequest {
	if x != nil {
		return x.History
	}
	return nil
}

type CleanupRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// needs_cleanup indicates whether this request wants the roller to be cleaned up.
	NeedsCleanup bool `protobuf:"varint,1,opt,name=needs_cleanup,json=needsCleanup,proto3" json:"needs_cleanup,omitempty"`
	// user is the user who requests the cleanup.
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// timestamp is the time at which cleanup was requested.
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// justification is the reason that cleanup was requested.
	Justification string `protobuf:"bytes,4,opt,name=justification,proto3" json:"justification,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupRequest) Reset() {
	*x = CleanupRequest{}
	mi := &file_rpc_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupRequest) ProtoMessage() {}

func (x *CleanupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rpc_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupRequest.ProtoReflect.Descriptor instead.
func (*CleanupRequest) Descriptor() ([]byte, []int) {
	return file_rpc_proto_rawDescGZIP(), []int{33}
}

func (x *CleanupRequest) GetNeedsCleanup() bool {
	if x != nil {
		return x.NeedsCleanup
	}
	return false
}

func (x *CleanupRequest) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *CleanupRequest) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *CleanupRequest) GetJustification() string {
	if x != nil {
		return x.Justification
	}
	return ""
}

var File_rpc_proto protoreflect.FileDescriptor

const file_rpc_proto_rawDesc = "" +
	"\n" +
	"\trpc.proto\x12\fautoroll.rpc\x1a\x1fgoogle/protobuf/timestamp.proto\"\xc0\x03\n" +
	"\x12AutoRollMiniStatus\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12\x1d\n" +
	"\n" +
	"child_name\x18\x02 \x01(\tR\tchildName\x12\x1f\n" +
	"\vparent_name\x18\x03 \x01(\tR\n" +
	"parentName\x12&\n" +
	"\x04mode\x18\x04 \x01(\x0e2\x12.autoroll.rpc.ModeR\x04mode\x12(\n" +
	"\x10current_roll_rev\x18\x05 \x01(\tR\x0ecurrentRollRev\x12\"\n" +
	"\rlast_roll_rev\x18\x06 \x01(\tR\vlastRollRev\x12\x1d\n" +
	"\n" +
	"num_failed\x18\a \x01(\x05R\tnumFailed\x12\x1d\n" +
	"\n" +
	"num_behind\x18\b \x01(\x05R\tnumBehind\x128\n" +
	"\ttimestamp\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12_\n" +
	"\x1elast_successful_roll_timestamp\x18\n" +
	" \x01(\v2\x1a.google.protobuf.TimestampR\x1blastSuccessfulRollTimestamp\"\xa8\x02\n" +
	"\x06TryJob\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x123\n" +
	"\x06status\x18\x02 \x01(\x0e2\x1b.autoroll.rpc.TryJob.StatusR\x06status\x123\n" +
	"\x06result\x18\x03 \x01(\x0e2\x1b.autoroll.rpc.TryJob.ResultR\x06result\x12\x10\n" +
	"\x03url\x18\x04 \x01(\tR\x03url\x12\x1a\n" +
	"\bcategory\x18\x05 \x01(\tR\bcategory\"=\n" +
	"\x06Result\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aSUCCESS\x10\x01\x12\v\n" +
	"\aFAILURE\x10\x02\x12\f\n" +
	"\bCANCELED\x10\x03\"3\n" +
	"\x06Status\x12\r\n" +
	"\tSCHEDULED\x10\x00\x12\v\n" +
	"\aSTARTED\x10\x01\x12\r\n" +
	"\tCOMPLETED\x10\x02\"\xdf\x03\n" +
	"\n" +
	"AutoRollCL\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x127\n" +
	"\x06result\x18\x02 \x01(\x0e2\x1f.autoroll.rpc.AutoRollCL.ResultR\x06result\x12\x18\n" +
	"\asubject\x18\x03 \x01(\tR\asubject\x12\x1d\n" +
	"\n" +
	"rolling_to\x18\x04 \x01(\tR\trollingTo\x12!\n" +
	"\frolling_from\x18\x05 \x01(\tR\vrollingFrom\x124\n" +
	"\acreated\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\acreated\x126\n" +
	"\bmodified\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\bmodified\x12/\n" +
	"\btry_jobs\x18\b \x03(\v2\x14.autoroll.rpc.TryJobR\atryJobs\"\x8c\x01\n" +
	"\x06Result\x12\x0f\n" +
	"\vIN_PROGRESS\x10\x00\x12\v\n" +
	"\aSUCCESS\x10\x01\x12\v\n" +
	"\aFAILURE\x10\x02\x12\x17\n" +
	"\x13DRY_RUN_IN_PROGRESS\x10\x03\x12\x13\n" +
	"\x0fDRY_RUN_SUCCESS\x10\x04\x12\x13\n" +
	"\x0fDRY_RUN_FAILURE\x10\x05\x12\x14\n" +
	"\x10HUMAN_INTERVENED\x10\x06\"\xbf\x01\n" +
	"\bRevision\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\adisplay\x18\x02 \x01(\tR\adisplay\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12.\n" +
	"\x04time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\x12\x10\n" +
	"\x03url\x18\x05 \x01(\tR\x03url\x12%\n" +
	"\x0einvalid_reason\x18\x06 \x01(\tR\rinvalidReason\"\xb0\x02\n" +
	"\x0eAutoRollConfig\x12$\n" +
	"\x0echild_bug_link\x18\x05 \x01(\tR\fchildBugLink\x12&\n" +
	"\x0fparent_bug_link\x18\x06 \x01(\tR\rparentBugLink\x12)\n" +
	"\x10parent_waterfall\x18\x01 \x01(\tR\x0fparentWaterfall\x12\x1b\n" +
	"\troller_id\x18\x02 \x01(\tR\brollerId\x122\n" +
	"\x15supports_manual_rolls\x18\x03 \x01(\bR\x13supportsManualRolls\x12\x1f\n" +
	"\vtime_window\x18\x04 \x01(\tR\n" +
	"timeWindow\x123\n" +
	"\vvalid_modes\x18\a \x03(\x0e2\x12.autoroll.rpc.ModeR\n" +
	"validModes\"\xaf\x01\n" +
	"\n" +
	"ModeChange\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12&\n" +
	"\x04mode\x18\x02 \x01(\x0e2\x12.autoroll.rpc.ModeR\x04mode\x12\x12\n" +
	"\x04user\x18\x03 \x01(\tR\x04user\x12.\n" +
	"\x04time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\"\xbf\x01\n" +
	"\x0eStrategyChange\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x122\n" +
	"\bstrategy\x18\x02 \x01(\x0e2\x16.autoroll.rpc.StrategyR\bstrategy\x12\x12\n" +
	"\x04user\x18\x03 \x01(\tR\x04user\x12.\n" +
	"\x04time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\"\x91\x04\n" +
	"\n" +
	"ManualRoll\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\troller_id\x18\x02 \x01(\tR\brollerId\x12\x1a\n" +
	"\brevision\x18\x03 \x01(\tR\brevision\x12\x1c\n" +
	"\trequester\x18\x04 \x01(\tR\trequester\x127\n" +
	"\x06result\x18\x05 \x01(\x0e2\x1f.autoroll.rpc.ManualRoll.ResultR\x06result\x127\n" +
	"\x06status\x18\x06 \x01(\x0e2\x1f.autoroll.rpc.ManualRoll.StatusR\x06status\x128\n" +
	"\ttimestamp\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x10\n" +
	"\x03url\x18\b \x01(\tR\x03url\x12\x17\n" +
	"\adry_run\x18\t \x01(\bR\x06dryRun\x12\x19\n" +
	"\bno_email\x18\n" +
	" \x01(\bR\anoEmail\x12.\n" +
	"\x13no_resolve_revision\x18\v \x01(\bR\x11noResolveRevision\x12\x16\n" +
	"\x06canary\x18\f \x01(\bR\x06canary\"/\n" +
	"\x06Result\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aFAILURE\x10\x01\x12\v\n" +
	"\aSUCCESS\x10\x02\"1\n" +
	"\x06Status\x12\v\n" +
	"\aPENDING\x10\x00\x12\v\n" +
	"\aSTARTED\x10\x01\x12\r\n" +
	"\tCOMPLETED\x10\x02\"\xb7\x06\n" +
	"\x0eAutoRollStatus\x12A\n" +
	"\vmini_status\x18\x01 \x01(\v2 .autoroll.rpc.AutoRollMiniStatusR\n" +
	"miniStatus\x12\x16\n" +
	"\x06status\x18\x02 \x01(\tR\x06status\x124\n" +
	"\x06config\x18\x03 \x01(\v2\x1c.autoroll.rpc.AutoRollConfigR\x06config\x12(\n" +
	"\x10full_history_url\x18\x04 \x01(\tR\x0efullHistoryUrl\x12$\n" +
	"\x0eissue_url_base\x18\x05 \x01(\tR\fissueUrlBase\x12,\n" +
	"\x04mode\x18\x06 \x01(\v2\x18.autoroll.rpc.ModeChangeR\x04mode\x128\n" +
	"\bstrategy\x18\a \x01(\v2\x1c.autoroll.rpc.StrategyChangeR\bstrategy\x12H\n" +
	"\x14not_rolled_revisions\x18\b \x03(\v2\x16.autoroll.rpc.RevisionR\x12notRolledRevisions\x12;\n" +
	"\fcurrent_roll\x18\t \x01(\v2\x18.autoroll.rpc.AutoRollCLR\vcurrentRoll\x125\n" +
	"\tlast_roll\x18\n" +
	" \x01(\v2\x18.autoroll.rpc.AutoRollCLR\blastRoll\x12;\n" +
	"\frecent_rolls\x18\v \x03(\v2\x18.autoroll.rpc.AutoRollCLR\vrecentRolls\x12;\n" +
	"\fmanual_rolls\x18\f \x03(\v2\x18.autoroll.rpc.ManualRollR\vmanualRolls\x12\x14\n" +
	"\x05error\x18\r \x01(\tR\x05error\x12C\n" +
	"\x0fthrottled_until\x18\x0e \x01(\v2\x1a.google.protobuf.TimestampR\x0ethrottledUntil\x12I\n" +
	"\x11cleanup_requested\x18\x0f \x01(\v2\x1c.autoroll.rpc.CleanupRequestR\x10cleanupRequested\"\x13\n" +
	"\x11GetRollersRequest\"P\n" +
	"\x12GetRollersResponse\x12:\n" +
	"\arollers\x18\x01 \x03(\v2 .autoroll.rpc.AutoRollMiniStatusR\arollers\"F\n" +
	"\x0fGetRollsRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12\x16\n" +
	"\x06cursor\x18\x02 \x01(\tR\x06cursor\"Z\n" +
	"\x10GetRollsResponse\x12.\n" +
	"\x05rolls\x18\x01 \x03(\v2\x18.autoroll.rpc.AutoRollCLR\x05rolls\x12\x16\n" +
	"\x06cursor\x18\x02 \x01(\tR\x06cursor\"3\n" +
	"\x14GetMiniStatusRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\"Q\n" +
	"\x15GetMiniStatusResponse\x128\n" +
	"\x06status\x18\x01 \x01(\v2 .autoroll.rpc.AutoRollMiniStatusR\x06status\"/\n" +
	"\x10GetStatusRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\"I\n" +
	"\x11GetStatusResponse\x124\n" +
	"\x06status\x18\x01 \x01(\v2\x1c.autoroll.rpc.AutoRollStatusR\x06status\"o\n" +
	"\x0eSetModeRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12&\n" +
	"\x04mode\x18\x02 \x01(\x0e2\x12.autoroll.rpc.ModeR\x04mode\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"G\n" +
	"\x0fSetModeResponse\x124\n" +
	"\x06status\x18\x01 \x01(\v2\x1c.autoroll.rpc.AutoRollStatusR\x06status\"L\n" +
	"\x15GetModeHistoryRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x05R\x06offset\"m\n" +
	"\x16GetModeHistoryResponse\x122\n" +
	"\ahistory\x18\x01 \x03(\v2\x18.autoroll.rpc.ModeChangeR\ahistory\x12\x1f\n" +
	"\vnext_offset\x18\x02 \x01(\x05R\n" +
	"nextOffset\"\x7f\n" +
	"\x12SetStrategyRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x122\n" +
	"\bstrategy\x18\x02 \x01(\x0e2\x16.autoroll.rpc.StrategyR\bstrategy\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"K\n" +
	"\x13SetStrategyResponse\x124\n" +
	"\x06status\x18\x01 \x01(\v2\x1c.autoroll.rpc.AutoRollStatusR\x06status\"P\n" +
	"\x19GetStrategyHistoryRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x05R\x06offset\"u\n" +
	"\x1aGetStrategyHistoryResponse\x126\n" +
	"\ahistory\x18\x01 \x03(\v2\x1c.autoroll.rpc.StrategyChangeR\ahistory\x12\x1f\n" +
	"\vnext_offset\x18\x02 \x01(\x05R\n" +
	"nextOffset\"k\n" +
	"\x17CreateManualRollRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12\x1a\n" +
	"\brevision\x18\x02 \x01(\tR\brevision\x12\x17\n" +
	"\adry_run\x18\x03 \x01(\bR\x06dryRun\"H\n" +
	"\x18CreateManualRollResponse\x12,\n" +
	"\x04roll\x18\x01 \x01(\v2\x18.autoroll.rpc.ManualRollR\x04roll\"0\n" +
	"\x11UnthrottleRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\"\x14\n" +
	"\x12UnthrottleResponse\"]\n" +
	"\x18AddCleanupRequestRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12$\n" +
	"\rjustification\x18\x02 \x01(\tR\rjustification\"Q\n" +
	"\x19AddCleanupRequestResponse\x124\n" +
	"\x06status\x18\x01 \x01(\v2\x1c.autoroll.rpc.AutoRollStatusR\x06status\"M\n" +
	"\x18GetCleanupHistoryRequest\x12\x1b\n" +
	"\troller_id\x18\x01 \x01(\tR\brollerId\x12\x14\n" +
	"\x05limit\x18\x02 \x01(\rR\x05limit\"S\n" +
	"\x19GetCleanupHistoryResponse\x126\n" +
	"\ahistory\x18\x01 \x03(\v2\x1c.autoroll.rpc.CleanupRequestR\ahistory\"\xa9\x01\n" +
	"\x0eCleanupRequest\x12#\n" +
	"\rneeds_cleanup\x18\x01 \x01(\bR\fneedsCleanup\x12\x12\n" +
	"\x04user\x18\x02 \x01(\tR\x04user\x128\n" +
	"\ttimestamp\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12$\n" +
	"\rjustification\x18\x04 \x01(\tR\rjustification*:\n" +
	"\x04Mode\x12\v\n" +
	"\aRUNNING\x10\x00\x12\v\n" +
	"\aSTOPPED\x10\x01\x12\v\n" +
	"\aDRY_RUN\x10\x02\x12\v\n" +
	"\aOFFLINE\x10\x03*.\n" +
	"\bStrategy\x12\t\n" +
	"\x05BATCH\x10\x00\x12\v\n" +
	"\aN_BATCH\x10\x01\x12\n" +
	"\n" +
	"\x06SINGLE\x10\x022\xb7\b\n" +
	"\x0fAutoRollService\x12d\n" +
	"\x11AddCleanupRequest\x12&.autoroll.rpc.AddCleanupRequestRequest\x1a'.autoroll.rpc.AddCleanupRequestResponse\x12d\n" +
	"\x11GetCleanupHistory\x12&.autoroll.rpc.GetCleanupHistoryRequest\x1a'.autoroll.rpc.GetCleanupHistoryResponse\x12O\n" +
	"\n" +
	"GetRollers\x12\x1f.autoroll.rpc.GetRollersRequest\x1a .autoroll.rpc.GetRollersResponse\x12I\n" +
	"\bGetRolls\x12\x1d.autoroll.rpc.GetRollsRequest\x1a\x1e.autoroll.rpc.GetRollsResponse\x12X\n" +
	"\rGetMiniStatus\x12\".autoroll.rpc.GetMiniStatusRequest\x1a#.autoroll.rpc.GetMiniStatusResponse\x12L\n" +
	"\tGetStatus\x12\x1e.autoroll.rpc.GetStatusRequest\x1a\x1f.autoroll.rpc.GetStatusResponse\x12F\n" +
	"\aSetMode\x12\x1c.autoroll.rpc.SetModeRequest\x1a\x1d.autoroll.rpc.SetModeResponse\x12[\n" +
	"\x0eGetModeHistory\x12#.autoroll.rpc.GetModeHistoryRequest\x1a$.autoroll.rpc.GetModeHistoryResponse\x12R\n" +
	"\vSetStrategy\x12 .autoroll.rpc.SetStrategyRequest\x1a!.autoroll.rpc.SetStrategyResponse\x12g\n" +
	"\x12GetStrategyHistory\x12'.autoroll.rpc.GetStrategyHistoryRequest\x1a(.autoroll.rpc.GetStrategyHistoryResponse\x12a\n" +
	"\x10CreateManualRoll\x12%.autoroll.rpc.CreateManualRollRequest\x1a&.autoroll.rpc.CreateManualRollResponse\x12O\n" +
	"\n" +
	"Unthrottle\x12\x1f.autoroll.rpc.UnthrottleRequest\x1a .autoroll.rpc.UnthrottleResponseB#Z!go.skia.org/infra/autoroll/go/rpcb\x06proto3"

var (
	file_rpc_proto_rawDescOnce sync.Once
	file_rpc_proto_rawDescData []byte
)

func file_rpc_proto_rawDescGZIP() []byte {
	file_rpc_proto_rawDescOnce.Do(func() {
		file_rpc_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_rpc_proto_rawDesc), len(file_rpc_proto_rawDesc)))
	})
	return file_rpc_proto_rawDescData
}

var file_rpc_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_rpc_proto_msgTypes = make([]protoimpl.MessageInfo, 34)
var file_rpc_proto_goTypes = []any{
	(Mode)(0),                          // 0: autoroll.rpc.Mode
	(Strategy)(0),                      // 1: autoroll.rpc.Strategy
	(TryJob_Result)(0),                 // 2: autoroll.rpc.TryJob.Result
	(TryJob_Status)(0),                 // 3: autoroll.rpc.TryJob.Status
	(AutoRollCL_Result)(0),             // 4: autoroll.rpc.AutoRollCL.Result
	(ManualRoll_Result)(0),             // 5: autoroll.rpc.ManualRoll.Result
	(ManualRoll_Status)(0),             // 6: autoroll.rpc.ManualRoll.Status
	(*AutoRollMiniStatus)(nil),         // 7: autoroll.rpc.AutoRollMiniStatus
	(*TryJob)(nil),                     // 8: autoroll.rpc.TryJob
	(*AutoRollCL)(nil),                 // 9: autoroll.rpc.AutoRollCL
	(*Revision)(nil),                   // 10: autoroll.rpc.Revision
	(*AutoRollConfig)(nil),             // 11: autoroll.rpc.AutoRollConfig
	(*ModeChange)(nil),                 // 12: autoroll.rpc.ModeChange
	(*StrategyChange)(nil),             // 13: autoroll.rpc.StrategyChange
	(*ManualRoll)(nil),                 // 14: autoroll.rpc.ManualRoll
	(*AutoRollStatus)(nil),             // 15: autoroll.rpc.AutoRollStatus
	(*GetRollersRequest)(nil),          // 16: autoroll.rpc.GetRollersRequest
	(*GetRollersResponse)(nil),         // 17: autoroll.rpc.GetRollersResponse
	(*GetRollsRequest)(nil),            // 18: autoroll.rpc.GetRollsRequest
	(*GetRollsResponse)(nil),           // 19: autoroll.rpc.GetRollsResponse
	(*GetMiniStatusRequest)(nil),       // 20: autoroll.rpc.GetMiniStatusRequest
	(*GetMiniStatusResponse)(nil),      // 21: autoroll.rpc.GetMiniStatusResponse
	(*GetStatusRequest)(nil),           // 22: autoroll.rpc.GetStatusRequest
	(*GetStatusResponse)(nil),          // 23: autoroll.rpc.GetStatusResponse
	(*SetModeRequest)(nil),             // 24: autoroll.rpc.SetModeRequest
	(*SetModeResponse)(nil),            // 25: autoroll.rpc.SetModeResponse
	(*GetModeHistoryRequest)(nil),      // 26: autoroll.rpc.GetModeHistoryRequest
	(*GetModeHistoryResponse)(nil),     // 27: autoroll.rpc.GetModeHistoryResponse
	(*SetStrategyRequest)(nil),         // 28: autoroll.rpc.SetStrategyRequest
	(*SetStrategyResponse)(nil),        // 29: autoroll.rpc.SetStrategyResponse
	(*GetStrategyHistoryRequest)(nil),  // 30: autoroll.rpc.GetStrategyHistoryRequest
	(*GetStrategyHistoryResponse)(nil), // 31: autoroll.rpc.GetStrategyHistoryResponse
	(*CreateManualRollRequest)(nil),    // 32: autoroll.rpc.CreateManualRollRequest
	(*CreateManualRollResponse)(nil),   // 33: autoroll.rpc.CreateManualRollResponse
	(*UnthrottleRequest)(nil),          // 34: autoroll.rpc.UnthrottleRequest
	(*UnthrottleResponse)(nil),         // 35: autoroll.rpc.UnthrottleResponse
	(*AddCleanupRequestRequest)(nil),   // 36: autoroll.rpc.AddCleanupRequestRequest
	(*AddCleanupRequestResponse)(nil),  // 37: autoroll.rpc.AddCleanupRequestResponse
	(*GetCleanupHistoryRequest)(nil),   // 38: autoroll.rpc.GetCleanupHistoryRequest
	(*GetCleanupHistoryResponse)(nil),  // 39: autoroll.rpc.GetCleanupHistoryResponse
	(*CleanupRequest)(nil),             // 40: autoroll.rpc.CleanupRequest
	(*timestamppb.Timestamp)(nil),      // 41: google.protobuf.Timestamp
}
var file_rpc_proto_depIdxs = []int32{
	0,  // 0: autoroll.rpc.AutoRollMiniStatus.mode:type_name -> autoroll.rpc.Mode
	41, // 1: autoroll.rpc.AutoRollMiniStatus.timestamp:type_name -> google.protobuf.Timestamp
	41, // 2: autoroll.rpc.AutoRollMiniStatus.last_successful_roll_timestamp:type_name -> google.protobuf.Timestamp
	3,  // 3: autoroll.rpc.TryJob.status:type_name -> autoroll.rpc.TryJob.Status
	2,  // 4: autoroll.rpc.TryJob.result:type_name -> autoroll.rpc.TryJob.Result
	4,  // 5: autoroll.rpc.AutoRollCL.result:type_name -> autoroll.rpc.AutoRollCL.Result
	41, // 6: autoroll.rpc.AutoRollCL.created:type_name -> google.protobuf.Timestamp
	41, // 7: autoroll.rpc.AutoRollCL.modified:type_name -> google.protobuf.Timestamp
	8,  // 8: autoroll.rpc.AutoRollCL.try_jobs:type_name -> autoroll.rpc.TryJob
	41, // 9: autoroll.rpc.Revision.time:type_name -> google.protobuf.Timestamp
	0,  // 10: autoroll.rpc.AutoRollConfig.valid_modes:type_name -> autoroll.rpc.Mode
	0,  // 11: autoroll.rpc.ModeChange.mode:type_name -> autoroll.rpc.Mode
	41, // 12: autoroll.rpc.ModeChange.time:type_name -> google.protobuf.Timestamp
	1,  // 13: autoroll.rpc.StrategyChange.strategy:type_name -> autoroll.rpc.Strategy
	41, // 14: autoroll.rpc.StrategyChange.time:type_name -> google.protobuf.Timestamp
	5,  // 15: autoroll.rpc.ManualRoll.result:type_name -> autoroll.rpc.ManualRoll.Result
	6,  // 16: autoroll.rpc.ManualRoll.status:type_name -> autoroll.rpc.ManualRoll.Status
	41, // 17: autoroll.rpc.ManualRoll.timestamp:type_name -> google.protobuf.Timestamp
	7,  // 18: autoroll.rpc.AutoRollStatus.mini_status:type_name -> autoroll.rpc.AutoRollMiniStatus
	11, // 19: autoroll.rpc.AutoRollStatus.config:type_name -> autoroll.rpc.AutoRollConfig
	12, // 20: autoroll.rpc.AutoRollStatus.mode:type_name -> autoroll.rpc.ModeChange
	13, // 21: autoroll.rpc.AutoRollStatus.strategy:type_name -> autoroll.rpc.StrategyChange
	10, // 22: autoroll.rpc.AutoRollStatus.not_rolled_revisions:type_name -> autoroll.rpc.Revision
	9,  // 23: autoroll.rpc.AutoRollStatus.current_roll:type_name -> autoroll.rpc.AutoRollCL
	9,  // 24: autoroll.rpc.AutoRollStatus.last_roll:type_name -> autoroll.rpc.AutoRollCL
	9,  // 25: autoroll.rpc.AutoRollStatus.recent_rolls:type_name -> autoroll.rpc.AutoRollCL
	14, // 26: autoroll.rpc.AutoRollStatus.manual_rolls:type_name -> autoroll.rpc.ManualRoll
	41, // 27: autoroll.rpc.AutoRollStatus.throttled_until:type_name -> google.protobuf.Timestamp
	40, // 28: autoroll.rpc.AutoRollStatus.cleanup_requested:type_name -> autoroll.rpc.CleanupRequest
	7,  // 29: autoroll.rpc.GetRollersResponse.rollers:type_name -> autoroll.rpc.AutoRollMiniStatus
	9,  // 30: autoroll.rpc.GetRollsResponse.rolls:type_name -> autoroll.rpc.AutoRollCL
	7,  // 31: autoroll.rpc.GetMiniStatusResponse.status:type_name -> autoroll.rpc.AutoRollMiniStatus
	15, // 32: autoroll.rpc.GetStatusResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	0,  // 33: autoroll.rpc.SetModeRequest.mode:type_name -> autoroll.rpc.Mode
	15, // 34: autoroll.rpc.SetModeResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	12, // 35: autoroll.rpc.GetModeHistoryResponse.history:type_name -> autoroll.rpc.ModeChange
	1,  // 36: autoroll.rpc.SetStrategyRequest.strategy:type_name -> autoroll.rpc.Strategy
	15, // 37: autoroll.rpc.SetStrategyResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	13, // 38: autoroll.rpc.GetStrategyHistoryResponse.history:type_name -> autoroll.rpc.StrategyChange
	14, // 39: autoroll.rpc.CreateManualRollResponse.roll:type_name -> autoroll.rpc.ManualRoll
	15, // 40: autoroll.rpc.AddCleanupRequestResponse.status:type_name -> autoroll.rpc.AutoRollStatus
	40, // 41: autoroll.rpc.GetCleanupHistoryResponse.history:type_name -> autoroll.rpc.CleanupRequest
	41, // 42: autoroll.rpc.CleanupRequest.timestamp:type_name -> google.protobuf.Timestamp
	36, // 43: autoroll.rpc.AutoRollService.AddCleanupRequest:input_type -> autoroll.rpc.AddCleanupRequestRequest
	38, // 44: autoroll.rpc.AutoRollService.GetCleanupHistory:input_type -> autoroll.rpc.GetCleanupHistoryRequest
	16, // 45: autoroll.rpc.AutoRollService.GetRollers:input_type -> autoroll.rpc.GetRollersRequest
	18, // 46: autoroll.rpc.AutoRollService.GetRolls:input_type -> autoroll.rpc.GetRollsRequest
	20, // 47: autoroll.rpc.AutoRollService.GetMiniStatus:input_type -> autoroll.rpc.GetMiniStatusRequest
	22, // 48: autoroll.rpc.AutoRollService.GetStatus:input_type -> autoroll.rpc.GetStatusRequest
	24, // 49: autoroll.rpc.AutoRollService.SetMode:input_type -> autoroll.rpc.SetModeRequest
	26, // 50: autoroll.rpc.AutoRollService.GetModeHistory:input_type -> autoroll.rpc.GetModeHistoryRequest
	28, // 51: autoroll.rpc.AutoRollService.SetStrategy:input_type -> autoroll.rpc.SetStrategyRequest
	30, // 52: autoroll.rpc.AutoRollService.GetStrategyHistory:input_type -> autoroll.rpc.GetStrategyHistoryRequest
	32, // 53: autoroll.rpc.AutoRollService.CreateManualRoll:input_type -> autoroll.rpc.CreateManualRollRequest
	34, // 54: autoroll.rpc.AutoRollService.Unthrottle:input_type -> autoroll.rpc.UnthrottleRequest
	37, // 55: autoroll.rpc.AutoRollService.AddCleanupRequest:output_type -> autoroll.rpc.AddCleanupRequestResponse
	39, // 56: autoroll.rpc.AutoRollService.GetCleanupHistory:output_type -> autoroll.rpc.GetCleanupHistoryResponse
	17, // 57: autoroll.rpc.AutoRollService.GetRollers:output_type -> autoroll.rpc.GetRollersResponse
	19, // 58: autoroll.rpc.AutoRollService.GetRolls:output_type -> autoroll.rpc.GetRollsResponse
	21, // 59: autoroll.rpc.AutoRollService.GetMiniStatus:output_type -> autoroll.rpc.GetMiniStatusResponse
	23, // 60: autoroll.rpc.AutoRollService.GetStatus:output_type -> autoroll.rpc.GetStatusResponse
	25, // 61: autoroll.rpc.AutoRollService.SetMode:output_type -> autoroll.rpc.SetModeResponse
	27, // 62: autoroll.rpc.AutoRollService.GetModeHistory:output_type -> autoroll.rpc.GetModeHistoryResponse
	29, // 63: autoroll.rpc.AutoRollService.SetStrategy:output_type -> autoroll.rpc.SetStrategyResponse
	31, // 64: autoroll.rpc.AutoRollService.GetStrategyHistory:output_type -> autoroll.rpc.GetStrategyHistoryResponse
	33, // 65: autoroll.rpc.AutoRollService.CreateManualRoll:output_type -> autoroll.rpc.CreateManualRollResponse
	35, // 66: autoroll.rpc.AutoRollService.Unthrottle:output_type -> autoroll.rpc.UnthrottleResponse
	55, // [55:67] is the sub-list for method output_type
	43, // [43:55] is the sub-list for method input_type
	43, // [43:43] is the sub-list for extension type_name
	43, // [43:43] is the sub-list for extension extendee
	0,  // [0:43] is the sub-list for field type_name
}

func init() { file_rpc_proto_init() }
func file_rpc_proto_init() {
	if File_rpc_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_rpc_proto_rawDesc), len(file_rpc_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   34,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_rpc_proto_goTypes,
		DependencyIndexes: file_rpc_proto_depIdxs,
		EnumInfos:         file_rpc_proto_enumTypes,
		MessageInfos:      file_rpc_proto_msgTypes,
	}.Build()
	File_rpc_proto = out.File
	file_rpc_proto_goTypes = nil
	file_rpc_proto_depIdxs = nil
}
